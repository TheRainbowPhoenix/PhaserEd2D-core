var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        function PhaserHelp(key) {
            if (key === undefined) {
                return undefined;
            }
            const prefix = "phaser:";
            if (key.startsWith(prefix)) {
                return scene.ScenePlugin.getInstance().getPhaserDocs().getDoc(key.substring(prefix.length));
            }
            return key;
        }
        scene.PhaserHelp = PhaserHelp;
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_1) {
        var ide = colibri.ui.ide;
        var controls = colibri.ui.controls;
        scene_1.ICON_GROUP = "group";
        scene_1.ICON_TRANSLATE = "translate";
        scene_1.ICON_ANGLE = "angle";
        scene_1.ICON_SCALE = "scale";
        scene_1.ICON_ORIGIN = "origin";
        scene_1.ICON_SELECT_REGION = "select-region";
        scene_1.ICON_BUILD = "build";
        scene_1.ICON_LOCKED = "locked";
        scene_1.ICON_UNLOCKED = "unlocked";
        scene_1.ICON_LIST = "list";
        scene_1.ICON_USER_COMPONENT = "user-component";
        scene_1.ICON_IMAGE_TYPE = "image-type";
        scene_1.ICON_SPRITE_TYPE = "sprite-type";
        scene_1.ICON_TILESPRITE_TYPE = "tilesprite";
        scene_1.ICON_TEXT_TYPE = "text-type";
        scene_1.ICON_BITMAP_FONT_TYPE = "bitmapfont-type";
        scene_1.ICON_LAYER = "layer";
        scene_1.ICON_ALIGN_LEFT = "align-left";
        scene_1.ICON_ALIGN_CENTER = "align-center";
        scene_1.ICON_ALIGN_RIGHT = "align-right";
        scene_1.ICON_ALIGN_TOP = "align-top";
        scene_1.ICON_ALIGN_MIDDLE = "align-middle";
        scene_1.ICON_ALIGN_BOTTOM = "align-bottom";
        scene_1.ICON_BORDER_LEFT = "border-left";
        scene_1.ICON_BORDER_CENTER = "border-center";
        scene_1.ICON_BORDER_RIGHT = "border-right";
        scene_1.ICON_BORDER_TOP = "border-top";
        scene_1.ICON_BORDER_MIDDLE = "border-middle";
        scene_1.ICON_BORDER_BOTTOM = "border-bottom";
        scene_1.ICON_GRID = "grid";
        scene_1.ICON_COLUMN = "column";
        scene_1.ICON_ROW = "row";
        scene_1.SCENE_OBJECT_IMAGE_CATEGORY = "Texture";
        scene_1.SCENE_OBJECT_TEXT_CATEGORY = "String";
        scene_1.SCENE_OBJECT_GROUPING_CATEGORY = "Grouping";
        scene_1.SCENE_OBJECT_TILEMAP_CATEGORY = "Tile Map";
        scene_1.SCENE_OBJECT_SHAPE_CATEGORY = "Shape";
        scene_1.SCENE_OBJECT_CATEGORIES = [
            scene_1.SCENE_OBJECT_IMAGE_CATEGORY,
            scene_1.SCENE_OBJECT_GROUPING_CATEGORY,
            scene_1.SCENE_OBJECT_TEXT_CATEGORY,
            scene_1.SCENE_OBJECT_SHAPE_CATEGORY,
            scene_1.SCENE_OBJECT_TILEMAP_CATEGORY,
        ];
        scene_1.SCENE_OBJECT_CATEGORY_SET = new Set(scene_1.SCENE_OBJECT_CATEGORIES);
        class ScenePlugin extends colibri.Plugin {
            constructor() {
                super("phasereditor2d.scene");
                this._docs = new phasereditor2d.ide.core.PhaserDocs(this, "data/phaser-docs.json");
            }
            static getInstance() {
                return this._instance;
            }
            async starting() {
                const type = window.localStorage.getItem("phasereditor2d.scene.RENDER_TYPE");
                console.log("ScenePlugin: default render type: " + (type === "canvas" ? "Phaser.CANVAS" : "Phaser.WEBGL"));
                this.setDefaultRenderType(type);
            }
            setDefaultRenderType(type) {
                window.localStorage.setItem("phasereditor2d.scene.RENDER_TYPE", type);
                ScenePlugin.DEFAULT_CANVAS_CONTEXT = type === "canvas" ? Phaser.CANVAS : Phaser.WEBGL;
                ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT = ScenePlugin.DEFAULT_CANVAS_CONTEXT;
            }
            getPhaserDocs() {
                return this._docs;
            }
            registerExtensions(reg) {
                this._sceneFinder = new scene_1.core.json.SceneFinder();
                // migrations
                reg.addExtension(new scene_1.core.migrations.OriginMigration_v2_to_v3());
                // preload docs
                reg.addExtension(new ide.PluginResourceLoaderExtension(async () => {
                    await ScenePlugin.getInstance().getPhaserDocs().preload();
                }));
                // preload UserComponent files
                reg.addExtension(new ide.PluginResourceLoaderExtension(async () => {
                    await scene_1.ui.editor.usercomponent.UserComponentCodeResources.getInstance().preload();
                }));
                // preload project
                reg.addExtension(this._sceneFinder.getProjectPreloader());
                // content type resolvers
                reg.addExtension(new colibri.core.ContentTypeExtension([new scene_1.core.SceneContentTypeResolver()], 5));
                reg.addExtension(new colibri.core.ContentTypeExtension([new colibri.core.ContentTypeResolverByExtension(scene_1.core.CONTENT_TYPE_USER_COMPONENTS + "Resolver", [
                        ["components", scene_1.core.CONTENT_TYPE_USER_COMPONENTS]
                    ])
                ]));
                // content type renderer
                reg.addExtension(new phasereditor2d.files.ui.viewers.SimpleContentTypeCellRendererExtension(scene_1.core.CONTENT_TYPE_SCENE, new scene_1.ui.viewers.SceneFileCellRenderer()));
                // icons loader
                reg.addExtension(ide.IconLoaderExtension.withPluginFiles(this, [
                    scene_1.ICON_USER_COMPONENT,
                    scene_1.ICON_SELECT_REGION,
                    scene_1.ICON_TRANSLATE,
                    scene_1.ICON_SCALE,
                    scene_1.ICON_ANGLE,
                    scene_1.ICON_ORIGIN,
                    scene_1.ICON_TEXT_TYPE,
                    scene_1.ICON_BITMAP_FONT_TYPE,
                    scene_1.ICON_SPRITE_TYPE,
                    scene_1.ICON_TILESPRITE_TYPE,
                    scene_1.ICON_LIST,
                    scene_1.ICON_IMAGE_TYPE,
                    scene_1.ICON_GROUP,
                    scene_1.ICON_BUILD,
                    scene_1.ICON_LAYER,
                    scene_1.ICON_ALIGN_LEFT,
                    scene_1.ICON_ALIGN_CENTER,
                    scene_1.ICON_ALIGN_RIGHT,
                    scene_1.ICON_ALIGN_TOP,
                    scene_1.ICON_ALIGN_MIDDLE,
                    scene_1.ICON_ALIGN_BOTTOM,
                    scene_1.ICON_BORDER_LEFT,
                    scene_1.ICON_BORDER_CENTER,
                    scene_1.ICON_BORDER_RIGHT,
                    scene_1.ICON_BORDER_TOP,
                    scene_1.ICON_BORDER_MIDDLE,
                    scene_1.ICON_BORDER_BOTTOM,
                    scene_1.ICON_GRID,
                    scene_1.ICON_COLUMN,
                    scene_1.ICON_ROW
                ]));
                reg.addExtension(ide.IconLoaderExtension.withPluginFiles(this, [
                    scene_1.ICON_LOCKED,
                    scene_1.ICON_UNLOCKED
                ]));
                reg.addExtension(colibri.ui.ide.ContentTypeIconExtension.withPluginIcons(this, [
                    {
                        iconName: scene_1.ICON_USER_COMPONENT,
                        contentType: scene_1.core.CONTENT_TYPE_USER_COMPONENTS
                    }
                ]));
                // loader updates
                reg.addExtension(new scene_1.ui.sceneobjects.ImageLoaderExtension(), new scene_1.ui.sceneobjects.BitmapFontLoaderUpdater(), new scene_1.ui.sceneobjects.TilemapLoaderUpdater());
                // outline extensions
                reg.addExtension(new scene_1.ui.sceneobjects.TilemapOutlineExtension());
                // commands
                reg.addExtension(new ide.commands.CommandExtension(m => scene_1.ui.editor.commands.SceneEditorCommands.registerCommands(m)));
                reg.addExtension(new ide.commands.CommandExtension(m => scene_1.ui.editor.usercomponent.UserComponentsEditor.registerCommands(m)));
                // compile project
                reg.addExtension(new scene_1.ui.editor.usercomponent.UserComponentCompileAllExtension(), new scene_1.core.code.SceneCompileAllExtension());
                // editors
                reg.addExtension(new ide.EditorExtension([
                    scene_1.ui.editor.SceneEditor.getFactory(),
                    scene_1.ui.editor.usercomponent.UserComponentsEditor.getFactory()
                ]));
                // new file wizards
                reg.addExtension(new scene_1.ui.dialogs.NewSceneFileDialogExtension(), new scene_1.ui.dialogs.NewPrefabFileDialogExtension(), new scene_1.ui.dialogs.NewUserComponentsFileDialogExtension());
                // file properties
                reg.addExtension(new phasereditor2d.files.ui.views.FilePropertySectionExtension(page => new scene_1.ui.SceneFileSection(page), page => new scene_1.ui.ManySceneFileSection(page)));
                // scene game object extensions
                reg.addExtension(scene_1.ui.sceneobjects.ImageExtension.getInstance(), scene_1.ui.sceneobjects.SpriteExtension.getInstance(), scene_1.ui.sceneobjects.TileSpriteExtension.getInstance(), scene_1.ui.sceneobjects.TextExtension.getInstance(), scene_1.ui.sceneobjects.BitmapTextExtension.getInstance(), scene_1.ui.sceneobjects.ContainerExtension.getInstance(), scene_1.ui.sceneobjects.LayerExtension.getInstance(), scene_1.ui.sceneobjects.TilemapLayerExtension.getInstance(), scene_1.ui.sceneobjects.RectangleExtension.getInstance(), scene_1.ui.sceneobjects.EllipseExtension.getInstance(), scene_1.ui.sceneobjects.TriangleExtension.getInstance());
                // scene plain object extensions
                reg.addExtension(scene_1.ui.sceneobjects.TilemapExtension.getInstance());
                // align extensions
                reg.addExtension(...scene_1.ui.editor.layout.DefaultLayoutExtensions.ALL);
                // property sections
                reg.addExtension(new scene_1.ui.editor.properties.SceneEditorPropertySectionExtension(page => new scene_1.ui.sceneobjects.GameObjectVariableSection(page), page => new scene_1.ui.sceneobjects.PrefabInstanceSection(page), page => new scene_1.ui.sceneobjects.UserComponentInstancePropertySection(page), page => new scene_1.ui.sceneobjects.ListVariableSection(page), page => new scene_1.ui.sceneobjects.GameObjectListSection(page), page => new scene_1.ui.sceneobjects.ParentSection(page), page => new scene_1.ui.sceneobjects.ChildrenSection(page), page => new scene_1.ui.sceneobjects.TransformSection(page), page => new scene_1.ui.sceneobjects.OriginSection(page), page => new scene_1.ui.sceneobjects.FlipSection(page), page => new scene_1.ui.sceneobjects.VisibleSection(page), page => new scene_1.ui.sceneobjects.AlphaSection(page), page => new scene_1.ui.sceneobjects.AlphaSingleSection(page), page => new scene_1.ui.sceneobjects.TintSection(page), page => new scene_1.ui.sceneobjects.SizeSection(page), page => new scene_1.ui.sceneobjects.TileSpriteSection(page), page => new scene_1.ui.sceneobjects.TextureSection(page), page => new scene_1.ui.sceneobjects.TextContentSection(page), page => new scene_1.ui.sceneobjects.TextSection(page), page => new scene_1.ui.sceneobjects.BitmapTextSection(page), page => new scene_1.ui.sceneobjects.ListSection(page), page => new scene_1.ui.sceneobjects.ScenePlainObjectVariableSection(page), page => new scene_1.ui.sceneobjects.TilemapSection(page), page => new scene_1.ui.sceneobjects.TilesetSection(page), page => new scene_1.ui.sceneobjects.TilesetPreviewSection(page), page => new scene_1.ui.sceneobjects.TilemapLayerSection(page), page => new scene_1.ui.sceneobjects.ShapeSection(page), page => new scene_1.ui.sceneobjects.EllipseSection(page), page => new scene_1.ui.sceneobjects.TriangleSection(page)));
                // scene tools
                reg.addExtension(new scene_1.ui.editor.tools.SceneToolExtension(new scene_1.ui.sceneobjects.TranslateTool(), new scene_1.ui.sceneobjects.RotateTool(), new scene_1.ui.sceneobjects.ScaleTool(), new scene_1.ui.sceneobjects.OriginTool(), new scene_1.ui.sceneobjects.SizeTool(), new scene_1.ui.sceneobjects.SelectionRegionTool(), new scene_1.ui.sceneobjects.PanTool()));
                // files view sections
                reg.addExtension(new phasereditor2d.files.ui.views.ContentTypeSectionExtension({
                    section: phasereditor2d.files.ui.views.TAB_SECTION_DESIGN,
                    contentType: scene_1.core.CONTENT_TYPE_SCENE
                }, {
                    section: phasereditor2d.files.ui.views.TAB_SECTION_DESIGN,
                    contentType: scene_1.core.CONTENT_TYPE_USER_COMPONENTS
                }));
            }
            getTools() {
                return colibri.Platform.getExtensions(scene_1.ui.editor.tools.SceneToolExtension.POINT_ID)
                    .flatMap(ext => ext.getTools());
            }
            getTool(toolId) {
                return this.getTools().find(tool => tool.getId() === toolId);
            }
            getDefaultSceneSettings() {
                const settings = new scene_1.core.json.SceneSettings();
                try {
                    const finder = ScenePlugin.getInstance().getSceneFinder();
                    const files = [...finder.getSceneFiles()];
                    files.sort((a, b) => b.getModTime() - a.getModTime());
                    if (files.length > 0) {
                        const file = files[0];
                        settings.readJSON(finder.getSceneData(file).settings);
                    }
                }
                catch (e) {
                    console.error(e);
                }
                return settings;
            }
            createUserPropertyTypes() {
                // TODO: we should do this via extension
                return [
                    new scene_1.ui.sceneobjects.NumberPropertyType(),
                    new scene_1.ui.sceneobjects.StringPropertyType(),
                    new scene_1.ui.sceneobjects.BooleanPropertyType(),
                    new scene_1.ui.sceneobjects.ColorPropertyType(),
                    new scene_1.ui.sceneobjects.ExpressionPropertyType(),
                    new scene_1.ui.sceneobjects.OptionPropertyType(),
                    new scene_1.ui.sceneobjects.ObjectVarPropertyType(),
                    new scene_1.ui.sceneobjects.ObjectConstructorPropertyType(),
                    new scene_1.ui.sceneobjects.TextureConfigPropertyType(),
                    new scene_1.ui.sceneobjects.AnimationKeyPropertyType(),
                    new scene_1.ui.sceneobjects.AudioKeyPropertyType(),
                    new scene_1.ui.sceneobjects.AssetKeyPropertyType(),
                    new scene_1.ui.sceneobjects.SceneKeyPropertyType()
                ];
            }
            createUserPropertyType(typeId) {
                return this.createUserPropertyTypes().find(t => t.getId() === typeId);
            }
            getSceneFinder() {
                return this._sceneFinder;
            }
            isSceneContentType(file) {
                return !file.isFolder() && colibri.Platform.getWorkbench().getContentTypeRegistry().getCachedContentType(file) === scene_1.core.CONTENT_TYPE_SCENE;
            }
            getPlainObjectExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.ScenePlainObjectExtension.POINT_ID);
            }
            getPlainObjectCategories() {
                return this.getPlainObjectExtensions().map(e => e.getCategory());
            }
            getPlainObjectExtensionByObjectType(type) {
                return this.getPlainObjectExtensions().find(ext => ext.getTypeName() === type);
            }
            getGameObjectExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.SceneGameObjectExtension.POINT_ID);
            }
            getGameObjectExtensionByObjectType(type) {
                return this.getGameObjectExtensions().find(ext => {
                    if (ext.getTypeName() === type) {
                        return ext;
                    }
                    if (ext.getTypeNameAlias().indexOf(type) >= 0) {
                        return ext;
                    }
                });
            }
            getSceneEditorOutlineExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.editor.outline.SceneEditorOutlineExtension.POINT_ID);
            }
            getLayoutExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.editor.layout.LayoutExtension.POINT_ID);
            }
            getLayoutExtensionsByGroup() {
                const allExtensions = ScenePlugin.getInstance().getLayoutExtensions();
                const groups = [];
                for (const ext of allExtensions) {
                    if (groups.indexOf(ext.getConfig().group) < 0) {
                        groups.push(ext.getConfig().group);
                    }
                }
                const result = [];
                for (const group of groups) {
                    const extensions = allExtensions.filter(e => e.getConfig().group === group);
                    result.push({ group, extensions });
                }
                return result;
            }
            getLoaderUpdaterForAsset(asset) {
                const exts = colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.LoaderUpdaterExtension.POINT_ID);
                for (const ext of exts) {
                    if (ext.acceptAsset(asset)) {
                        return ext;
                    }
                }
                return null;
            }
            getLoaderUpdaters() {
                const exts = colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.LoaderUpdaterExtension.POINT_ID);
                return exts;
            }
            async compileAll() {
                const files = this._sceneFinder.getSceneFiles();
                const dlg = new controls.dialogs.ProgressDialog();
                dlg.create();
                dlg.setTitle("Compiling Scene Files");
                const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                monitor.addTotal(files.length);
                for (const file of files) {
                    const data = this.getSceneFinder().getSceneData(file);
                    const scene = await scene_1.ui.OfflineScene.createScene(data);
                    const compiler = new scene_1.core.code.SceneCompiler(scene, file);
                    await compiler.compile();
                    scene.destroyGame();
                    monitor.step();
                }
                dlg.close();
            }
            async runSceneDataMigrations(sceneData) {
                const migrations = colibri.Platform.getExtensionRegistry()
                    .getExtensions(scene_1.ui.SceneDataMigrationExtension.POINT_ID);
                for (const migration of migrations) {
                    try {
                        await migration.migrate(sceneData);
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
            }
        }
        ScenePlugin._instance = new ScenePlugin();
        ScenePlugin.DEFAULT_CANVAS_CONTEXT = Phaser.WEBGL;
        ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT = Phaser.WEBGL;
        scene_1.ScenePlugin = ScenePlugin;
        colibri.Platform.addPlugin(ScenePlugin.getInstance());
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/* tslint:disable */
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core_1) {
            var core = colibri.core;
            core_1.CONTENT_TYPE_SCENE = "phasereditor2d.core.scene.SceneContentType";
            core_1.CONTENT_TYPE_USER_COMPONENTS = "phasereditor2d.core.scene.UserComponents";
            class SceneContentTypeResolver extends core.ContentTypeResolver {
                constructor() {
                    super("phasereditor2d.scene.core.SceneContentTypeResolver");
                }
                async computeContentType(file) {
                    if (file.getExtension() === "scene") {
                        const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                        if (content !== null) {
                            try {
                                const data = JSON.parse(content);
                                if (data.meta.contentType === core_1.CONTENT_TYPE_SCENE) {
                                    return core_1.CONTENT_TYPE_SCENE;
                                }
                            }
                            catch (e) {
                                // nothing
                            }
                        }
                    }
                    return core.CONTENT_TYPE_ANY;
                }
            }
            core_1.SceneContentTypeResolver = SceneContentTypeResolver;
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code_1) {
                class CodeDOM {
                    getOffset() {
                        return this._offset;
                    }
                    setOffset(offset) {
                        this._offset = offset;
                    }
                    static isBlankLine(codeDom) {
                        if (codeDom instanceof code_1.RawCodeDOM) {
                            const code = codeDom.getCode();
                            return code === "";
                        }
                        return false;
                    }
                    static removeBlankLines(list) {
                        const list2 = [];
                        let lastIsBlankLine = false;
                        for (const item of list) {
                            if (this.isBlankLine(item)) {
                                if (lastIsBlankLine) {
                                    continue;
                                }
                                lastIsBlankLine = true;
                            }
                            else {
                                lastIsBlankLine = false;
                            }
                            list2.push(item);
                        }
                        return list2;
                    }
                    static toHex(n) {
                        const hex = n.toString(16);
                        if (hex.length < 2) {
                            return "0" + hex;
                        }
                        return hex;
                    }
                    static quote(s) {
                        if (s === null || s === undefined || s.length === 0) {
                            return '""';
                        }
                        let b;
                        let c;
                        let i;
                        const len = s.length;
                        let result = '"';
                        for (i = 0; i < len; i += 1) {
                            b = c;
                            c = s.charAt(i);
                            switch (c) {
                                case "\\":
                                case '"':
                                    result += "\\";
                                    result += c;
                                    break;
                                case "/":
                                    if (b === "<") {
                                        result += "\\";
                                    }
                                    result += c;
                                    break;
                                case "\b":
                                    result += "\\b";
                                    break;
                                case "\t":
                                    result += "\\t";
                                    break;
                                case "\n":
                                    result += "\\n";
                                    break;
                                case "\f":
                                    result += "\\f";
                                    break;
                                case "\r":
                                    result += "\\r";
                                    break;
                                default:
                                    result += c;
                            }
                        }
                        result += '"';
                        return result;
                    }
                }
                code_1.CodeDOM = CodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./CodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class AssignPropertyCodeDOM extends code.CodeDOM {
                    constructor(propertyName, context) {
                        super();
                        this._propertyName = propertyName;
                        this._contextExpr = context;
                    }
                    value(expr) {
                        this._propertyValueExpr = expr;
                    }
                    valueLiteral(expr) {
                        this._propertyValueExpr = code.CodeDOM.quote(expr);
                    }
                    valueFloat(n) {
                        // tslint:disable-next-line:no-construct
                        this._propertyValueExpr = new Number(n).toString();
                    }
                    valueInt(n) {
                        // tslint:disable-next-line:no-construct
                        this._propertyValueExpr = new Number(Math.floor(n)).toString();
                    }
                    valueBool(b) {
                        // tslint:disable-next-line:no-construct
                        this._propertyValueExpr = new Boolean(b).toString();
                    }
                    getPropertyName() {
                        return this._propertyName;
                    }
                    getContextExpr() {
                        return this._contextExpr;
                    }
                    setContextExpr(contextExpr) {
                        this._contextExpr = contextExpr;
                    }
                    getPropertyValueExpr() {
                        return this._propertyValueExpr;
                    }
                    getPropertyType() {
                        return this._propertyType;
                    }
                    setPropertyType(propertyType) {
                        this._propertyType = propertyType;
                    }
                }
                code.AssignPropertyCodeDOM = AssignPropertyCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class BaseCodeGenerator {
                    constructor() {
                        this._text = "";
                        this._indent = 0;
                    }
                    getOffset() {
                        return this._text.length;
                    }
                    generate(replace) {
                        this._replace = replace ?? "";
                        this.internalGenerate();
                        this.cleanCode();
                        return this._text;
                    }
                    cleanCode() {
                        // clean the empty lines
                        const lines = this._text.split("\n").map(line => {
                            if (line.trim() === "") {
                                return "";
                            }
                            return line;
                        });
                        this._text = lines.join("\n");
                    }
                    length() {
                        return this._text.length;
                    }
                    getStartSectionContent(endTag, defaultContent) {
                        const j = this._replace.indexOf(endTag);
                        const size = this._replace.length;
                        if (size > 0 && j !== -1) {
                            const section = this._replace.substring(0, j);
                            return section;
                        }
                        return defaultContent;
                    }
                    getSectionContent(openTag, closeTag, defaultContent) {
                        const i = this._replace.indexOf(openTag);
                        let j = this._replace.indexOf(closeTag);
                        if (j === -1) {
                            j = this._replace.length;
                        }
                        if (i !== -1 && j !== -1) {
                            const section = this._replace.substring(i + openTag.length, j);
                            return section;
                        }
                        return defaultContent;
                    }
                    getReplaceContent() {
                        return this._replace;
                    }
                    userCode(text) {
                        const lines = text.split("\n");
                        for (const line of lines) {
                            this.line(line);
                        }
                    }
                    sectionStart(endTag, defaultContent) {
                        this.append(this.getStartSectionContent(endTag, defaultContent));
                        this.append(endTag);
                    }
                    sectionEnd(openTag, defaultContent) {
                        this.append(openTag);
                        this.append(this.getSectionContent(openTag, "papa(--o^^o--)pig", defaultContent));
                    }
                    section(openTag, closeTag, defaultContent) {
                        const content = this.getSectionContent(openTag, closeTag, defaultContent);
                        this.append(openTag);
                        this.append(content);
                        this.append(closeTag);
                    }
                    cut(start, end) {
                        const str = this._text.substring(start, end);
                        const s1 = this._text.slice(0, start);
                        const s2 = this._text.slice(end, this._text.length);
                        this._text = s1 + s2;
                        // _sb.delete(start, end);
                        return str;
                    }
                    trim(run) {
                        const a = this.length();
                        run();
                        const b = this.length();
                        const str = this._text.substring(a, b);
                        if (str.trim().length === 0) {
                            this.cut(a, b);
                        }
                    }
                    append(str) {
                        this._text += str;
                    }
                    join(list) {
                        for (let i = 0; i < list.length; i++) {
                            if (i > 0) {
                                this.append(", ");
                            }
                            this.append(list[i]);
                        }
                    }
                    line(line = "") {
                        this.append(line);
                        this.append("\n");
                        this.append(this.getIndentTabs());
                    }
                    lineIfNeeded() {
                        if (!this.lastIsEmptyLine()) {
                            this.line();
                        }
                    }
                    lastIsEmptyLine() {
                        let i = this._text.length - 1;
                        let n = 0;
                        while (i > 0) {
                            const c = this._text[i];
                            if (c === "\n") {
                                n++;
                            }
                            if (c.trim().length > 0) {
                                break;
                            }
                            i--;
                        }
                        return n > 1;
                    }
                    static escapeStringLiterals(str) {
                        return str.replace("\\", "\\\\").replace("\\R", "\n").replace("'", "\\'").replace("\"", "\\\"");
                    }
                    openIndent(line = "") {
                        this._indent++;
                        this.line(line);
                    }
                    closeIndent(str = "") {
                        this._indent--;
                        const i = this._text.lastIndexOf("\n");
                        if (i >= 0) {
                            const last = this._text.substring(i);
                            if (last.trim() === "") {
                                // removes the extra blank line
                                this._text = this._text.substring(0, i);
                            }
                        }
                        this.line();
                        this.line(str);
                    }
                    getIndentTabs() {
                        return "\t".repeat(this._indent);
                    }
                    static emptyStringToNull(str) {
                        return str == null ? null : (str.trim().length === 0 ? null : str);
                    }
                }
                code.BaseCodeGenerator = BaseCodeGenerator;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./CodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class MemberDeclCodeDOM extends code.CodeDOM {
                    constructor(name) {
                        super();
                        this._name = name;
                    }
                    getName() {
                        return this._name;
                    }
                }
                code.MemberDeclCodeDOM = MemberDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./MemberDeclCodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class ClassDeclCodeDOM extends code.MemberDeclCodeDOM {
                    constructor(name) {
                        super(name);
                        this._body = [];
                        this._exportClass = false;
                    }
                    isExportClass() {
                        return this._exportClass;
                    }
                    setExportClass(exportClass) {
                        this._exportClass = exportClass;
                    }
                    getConstructor() {
                        return this._constructor;
                    }
                    setConstructor(constructor) {
                        this._constructor = constructor;
                    }
                    getSuperClass() {
                        return this._superClass;
                    }
                    setSuperClass(superClass) {
                        this._superClass = superClass;
                    }
                    getBody() {
                        return this._body;
                    }
                }
                code.ClassDeclCodeDOM = ClassDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var controls = colibri.ui.controls;
                const SPEC_EXT = {
                    "js": "js",
                    "js-module": "js",
                    "ts": "ts",
                    "ts-module": "ts"
                };
                class CodeResources {
                    constructor(plugin) {
                        this._plugin = plugin;
                        this._resources = [];
                        this._resDataMap = new Map();
                    }
                    addResource(id, path) {
                        this._resources.push({ id, path });
                    }
                    addCodeResource(fileName) {
                        for (const spec of ["js", "ts", "js-module", "ts-module"]) {
                            const ext = SPEC_EXT[spec];
                            this.addResource(`${spec}/${fileName}`, `code-resources/${spec}/${fileName}.${ext}`);
                        }
                    }
                    addCodeDefsResource(fileName) {
                        this.addResource(`defs/${fileName}`, `code-resources/defs/${fileName}.d.ts`);
                    }
                    async preload() {
                        for (const res of this._resources) {
                            const data = await this._plugin.getString(res.path);
                            this._resDataMap.set(res.id, data);
                        }
                    }
                    async createFile(resId, parent, name) {
                        const data = this._resDataMap.get(resId);
                        return await colibri.ui.ide.FileUtils.createFile_async(parent, name, data);
                    }
                    async createCodeFiles(spec, dlgTitle) {
                        try {
                            const filesView = colibri.Platform.getWorkbench().getActiveWindow()
                                .getView(phasereditor2d.files.ui.views.FilesView.ID);
                            const sel = filesView.getSelection();
                            let folder;
                            if (sel.length > 0) {
                                const file = sel[0];
                                if (file.isFolder()) {
                                    folder = file;
                                }
                                else {
                                    folder = file.getParent();
                                }
                            }
                            else {
                                alert("Please, select a folder in the Files view.");
                                return;
                            }
                            const dlg = new controls.dialogs.ProgressDialog();
                            dlg.create();
                            dlg.setTitle(dlgTitle);
                            const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                            const newFiles = [];
                            const resources = this._resources.filter(r => r.id.startsWith(`${spec}/`));
                            resources.push(this._resources.find(r => r.id.startsWith("defs")));
                            monitor.addTotal(resources.length + 1);
                            await this.preload();
                            monitor.step();
                            for (const resource of resources) {
                                const fileName = resource.path.split("/").pop();
                                newFiles.push(await this.createFile(resource.id, folder, fileName));
                                monitor.step();
                            }
                            dlg.close();
                            const viewer = filesView.getViewer();
                            viewer.setExpanded(folder, true);
                            await viewer.repaint();
                            viewer.setSelection(newFiles);
                        }
                        catch (e) {
                            alert("Error: " + e.message);
                        }
                    }
                    registerCommands(categoryId, categoryName, reg) {
                        reg.addExtension(new colibri.ui.ide.commands.CommandExtension(manager => {
                            manager.addCategory({
                                id: categoryId,
                                name: categoryName,
                            });
                            for (const spec of ["js", "js-module", "ts", "ts-module"]) {
                                manager.add({
                                    command: {
                                        id: categoryId + "." + spec,
                                        category: categoryId,
                                        name: `Create User Files (${spec})`,
                                        tooltip: `Create the user files with the ${categoryName} API.`
                                    },
                                    handler: {
                                        executeFunc: args => {
                                            this.createCodeFiles(spec, `Creating ${categoryName} files`);
                                        }
                                    }
                                });
                            }
                        }));
                    }
                }
                code.CodeResources = CodeResources;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var io = colibri.core.io;
                function getImportPath(file, importFile) {
                    const parent = file.getParent();
                    const parentPath = parent.getFullName();
                    const parentElements = parentPath.split("/");
                    const importFilePath = io.FilePath.join(importFile.getParent().getFullName(), importFile.getNameWithoutExtension());
                    const importFileElements = importFilePath.split("/");
                    if (parent === importFile.getParent()) {
                        return "./" + importFile.getNameWithoutExtension();
                    }
                    if (importFilePath.startsWith(parentPath)) {
                        return "./" + importFileElements.slice(parentElements.length).join("/");
                    }
                    while (parentElements.length > 0) {
                        const parentFirst = parentElements.shift();
                        const importFileFirst = importFileElements.shift();
                        if (parentFirst !== importFileFirst) {
                            importFileElements.unshift(importFileFirst);
                            return "../".repeat(parentElements.length + 1) + importFileElements.join("/");
                        }
                    }
                    return "";
                }
                code.getImportPath = getImportPath;
                function isAlphaNumeric(c) {
                    const n = c.charCodeAt(0);
                    return (n > 47 && n < 58) // 0-9
                        || (n > 64 && n < 91) // a-z
                        || (n > 96 && n < 123); // A-Z
                }
                const validCharsMap = new Map();
                function isValidChar(c) {
                    if (validCharsMap.has(c)) {
                        return validCharsMap.get(c);
                    }
                    let result = true;
                    try {
                        // tslint:disable
                        eval("() => {  function pe" + c + "pe() {} }");
                    }
                    catch (e) {
                        result = false;
                        return false;
                    }
                    validCharsMap.set(c, result);
                    return result;
                }
                function formatToValidVarName(name) {
                    let s = "";
                    for (const c of name) {
                        // TODO: use isValidChar, but first we have to ask to the user if he wants to do it.
                        if (isAlphaNumeric(c)) {
                            s += (s.length === 0 ? c.toLowerCase() : c);
                        }
                        else {
                            s += "_";
                        }
                    }
                    return s;
                }
                code.formatToValidVarName = formatToValidVarName;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class FieldDeclCodeDOM extends code.MemberDeclCodeDOM {
                    constructor(name, type, publicScope = false) {
                        super(name);
                        this._type = type;
                        this._publicScope = publicScope;
                        this._initialValueExpr = null;
                        this._allowUndefined = false;
                    }
                    isAllowUndefined() {
                        return this._allowUndefined;
                    }
                    setAllowUndefined(allowUndefined) {
                        this._allowUndefined = allowUndefined;
                    }
                    isInitialized() {
                        return this._initialValueExpr !== null && this._initialValueExpr !== undefined && this._initialValueExpr.length > 0;
                    }
                    getInitialValueExpr() {
                        return this._initialValueExpr;
                    }
                    setInitialValueExpr(expr) {
                        this._initialValueExpr = expr;
                    }
                    isPublic() {
                        return this._publicScope;
                    }
                    setPublic(publicScope) {
                        this._publicScope = publicScope;
                    }
                    getType() {
                        return this._type;
                    }
                    setType(type) {
                        this._type = type;
                    }
                    getStrictType() {
                        if (this.isAllowUndefined()) {
                            return this._type + " | undefined";
                        }
                        return this._type;
                    }
                }
                code.FieldDeclCodeDOM = FieldDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class ImportCodeDOM extends code.CodeDOM {
                    constructor(elementName, filePath) {
                        super();
                        this._elementName = elementName;
                        this._filePath = filePath;
                    }
                    getElementName() {
                        return this._elementName;
                    }
                    getFilePath() {
                        return this._filePath;
                    }
                }
                code.ImportCodeDOM = ImportCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code_2) {
                class JavaScriptUnitCodeGenerator extends code_2.BaseCodeGenerator {
                    constructor(unit) {
                        super();
                        this._unit = unit;
                        this._generateImports = true;
                    }
                    setInitFieldInConstructor(initFieldInConstructor) {
                        this._initFieldsInConstructor = initFieldInConstructor;
                    }
                    isInitFieldInConstructor() {
                        return this._initFieldsInConstructor;
                    }
                    setGenerateImports(generateImports) {
                        this._generateImports = generateImports;
                    }
                    isGenerateImports() {
                        return this._generateImports;
                    }
                    internalGenerate() {
                        this.sectionStart("/* START OF COMPILED CODE */", "\n// You can write more code here\n\n");
                        this.line();
                        this.line();
                        const body = code_2.CodeDOM.removeBlankLines(this._unit.getBody());
                        for (const elem of body) {
                            this.generateUnitElement(elem);
                        }
                        this.sectionEnd("/* END OF COMPILED CODE */", "\n\n// You can write more code here\n");
                    }
                    generateUnitElement(elem) {
                        if (this._generateImports) {
                            this.generateImports();
                        }
                        if (elem instanceof code_2.ClassDeclCodeDOM) {
                            this.generateClass(elem);
                        }
                        else if (elem instanceof code_2.MethodDeclCodeDOM) {
                            this.line();
                            this.generateMethodDecl(null, elem, true);
                            this.line();
                        }
                    }
                    generateImports() {
                        const imports = this._unit.getImports();
                        for (const importDom of imports) {
                            this.line(`import ${importDom.getElementName()} from "${importDom.getFilePath()}";`);
                        }
                        this.section("/* START-USER-IMPORTS */", "/* END-USER-IMPORTS */", "\n");
                        this.line();
                        this.line();
                    }
                    generateClass(clsDecl) {
                        if (clsDecl.isExportClass()) {
                            this.append("export default ");
                        }
                        this.append("class " + clsDecl.getName() + " ");
                        if (clsDecl.getSuperClass() && clsDecl.getSuperClass().trim().length > 0) {
                            this.append("extends " + clsDecl.getSuperClass() + " ");
                        }
                        this.openIndent("{");
                        this.line();
                        const body = code_2.CodeDOM.removeBlankLines(clsDecl.getBody());
                        // methods
                        for (const memberDecl of body) {
                            if (memberDecl instanceof code_2.MethodDeclCodeDOM) {
                                this.generateMethodDecl(clsDecl, memberDecl, false);
                                this.line();
                            }
                        }
                        // fields
                        for (const memberDecl of body) {
                            if (memberDecl instanceof code_2.FieldDeclCodeDOM) {
                                this.generateFieldDecl(memberDecl);
                            }
                        }
                        if (body.find(m => m instanceof code_2.FieldDeclCodeDOM)) {
                            this.line();
                        }
                        // user section
                        for (const memberDecl of body) {
                            if (memberDecl instanceof code_2.UserSectionCodeDOM) {
                                this.generateSection(memberDecl);
                            }
                        }
                        // close body
                        this.closeIndent("}");
                        this.line();
                    }
                    generateFieldDecl(fieldDecl) {
                        if (this._initFieldsInConstructor) {
                            return;
                        }
                        this.line(`/** @type {${fieldDecl.getType()}} */`);
                        if (fieldDecl.isInitialized()) {
                            this.line(fieldDecl.getName() + " = " + fieldDecl.getInitialValueExpr() + ";");
                        }
                        else {
                            this.line(fieldDecl.getName() + ";");
                        }
                    }
                    generateMethodDecl(classDecl, methodDecl, isFunction) {
                        if (methodDecl.getReturnType()) {
                            this.generateMethodReturnTypeJSDoc(methodDecl);
                        }
                        for (const modifier of methodDecl.getModifiers()) {
                            this.append(modifier + " ");
                        }
                        if (isFunction) {
                            this.append("function ");
                        }
                        this.append(methodDecl.getName() + "(");
                        this.generateMethodDeclArgs(methodDecl);
                        const methodReturnDeclText = this.getMethodReturnDeclText(methodDecl);
                        this.openIndent(")" + methodReturnDeclText + "{");
                        let body = code_2.CodeDOM.removeBlankLines(methodDecl.getBody());
                        if (this._initFieldsInConstructor && methodDecl.getName() === "constructor") {
                            const superCall = body.find(instr => instr instanceof code_2.MethodCallCodeDOM && instr.getMethodName() === "super");
                            if (superCall) {
                                this.generateMethodCall(superCall);
                                body = body.filter(instr => instr !== superCall);
                            }
                            this.generateFieldInitInConstructor(classDecl, methodDecl);
                        }
                        // never add a blank line at the end of a method body
                        if (body.length > 0) {
                            const last = body.pop();
                            if (last instanceof code_2.RawCodeDOM) {
                                if (!code_2.CodeDOM.isBlankLine(last)) {
                                    body.push(last);
                                }
                            }
                            else {
                                body.push(last);
                            }
                            for (const instr of body) {
                                this.generateInstr(instr);
                            }
                        }
                        this.closeIndent("}");
                    }
                    generateMethodReturnTypeJSDoc(methodDecl) {
                        this.line(`/** @returns {${methodDecl.getReturnType()}} */`);
                    }
                    getMethodReturnDeclText(methodDecl) {
                        return " ";
                    }
                    generateFieldInitInConstructor(classDecl, ctrDecl) {
                        const fields = classDecl.getBody()
                            .filter(obj => obj instanceof code_2.FieldDeclCodeDOM);
                        if (fields.length > 0) {
                            this.line();
                            for (const field of fields) {
                                const assign = new code_2.AssignPropertyCodeDOM(field.getName(), "this");
                                assign.setPropertyType(field.getType());
                                assign.value(field.getInitialValueExpr());
                                this.generateAssignProperty(assign);
                            }
                            this.line();
                        }
                    }
                    generateMethodDeclArgs(methodDecl) {
                        this.append(methodDecl.getArgs()
                            .map(arg => arg.name)
                            .join(", "));
                    }
                    generateInstr(instr) {
                        instr.setOffset(this.getOffset());
                        if (instr instanceof code_2.RawCodeDOM) {
                            this.generateRawCode(instr);
                        }
                        else if (instr instanceof code_2.MethodCallCodeDOM) {
                            this.generateMethodCall(instr);
                        }
                        else if (instr instanceof code_2.AssignPropertyCodeDOM) {
                            this.generateAssignProperty(instr);
                        }
                        else if (instr instanceof code_2.UserSectionCodeDOM) {
                            this.generateSection(instr);
                        }
                    }
                    generateSection(section) {
                        this.section(section.getOpenTag(), section.getCloseTag(), section.getDefaultContent());
                    }
                    generateAssignProperty(assign) {
                        this.generateTypeAnnotation(assign);
                        if (assign.getContextExpr()) {
                            this.append(assign.getContextExpr());
                            this.append(".");
                        }
                        this.append(assign.getPropertyName());
                        if (assign.getPropertyValueExpr()) {
                            this.append(" = ");
                            this.append(assign.getPropertyValueExpr());
                        }
                        this.append(";");
                        this.line();
                    }
                    generateTypeAnnotation(assign) {
                        const type = assign.getPropertyType();
                        if (type != null) {
                            this.line("/** @type {" + type + "} */");
                        }
                    }
                    generateMethodCall(call) {
                        if (call.getReturnToVar()) {
                            if (call.isDeclareReturnToVar()) {
                                this.append("const ");
                            }
                            this.append(call.getReturnToVar());
                            this.append(" = ");
                        }
                        if (call.isConstructor()) {
                            this.append("new ");
                        }
                        if (call.getContextExpr() && call.getContextExpr().length > 0) {
                            this.append(call.getContextExpr());
                            this.append(".");
                        }
                        this.append(call.getMethodName());
                        this.append("(");
                        const args = [...call.getArgs()];
                        while (args.length > 0 && args[args.length - 1] === "undefined") {
                            args.pop();
                        }
                        this.join(args);
                        this.line(");");
                    }
                    generateRawCode(raw) {
                        const code = raw.getCode();
                        const lines = code.split("\\R");
                        for (const line of lines) {
                            this.line(line);
                        }
                    }
                }
                code_2.JavaScriptUnitCodeGenerator = JavaScriptUnitCodeGenerator;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class MethodCallCodeDOM extends code.CodeDOM {
                    constructor(methodName, contextExpr = "") {
                        super();
                        this._methodName = methodName;
                        this._contextExpr = contextExpr;
                        this._args = [];
                        this._declareReturnToVar = false;
                        this._isConstructor = false;
                        this._declareReturnToField = false;
                    }
                    isConstructor() {
                        return this._isConstructor;
                    }
                    setConstructor(isConstructor) {
                        this._isConstructor = isConstructor;
                    }
                    getReturnToVar() {
                        return this._returnToVar;
                    }
                    setReturnToVar(returnToVar) {
                        this._returnToVar = returnToVar;
                    }
                    setDeclareReturnToVar(declareReturnToVar) {
                        this._declareReturnToVar = declareReturnToVar;
                    }
                    isDeclareReturnToVar() {
                        return this._declareReturnToVar;
                    }
                    setDeclareReturnToField(declareReturnToField) {
                        this._declareReturnToField = declareReturnToField;
                    }
                    isDeclareReturnToField() {
                        return this._declareReturnToField;
                    }
                    arg(expr) {
                        this._args.push(expr);
                    }
                    argStringOrFloat(expr) {
                        switch (typeof expr) {
                            case "string":
                                this.argLiteral(expr);
                                break;
                            case "number":
                                this.argFloat(expr);
                                break;
                        }
                    }
                    argStringOrInt(expr) {
                        switch (typeof expr) {
                            case "string":
                                this.argLiteral(expr);
                                break;
                            case "number":
                                this.argInt(expr);
                                break;
                        }
                    }
                    argLiteral(expr) {
                        this._args.push(code.CodeDOM.quote(expr));
                    }
                    argFloat(n) {
                        this._args.push(n + "");
                    }
                    argInt(n) {
                        this._args.push(Math.floor(n) + "");
                    }
                    getMethodName() {
                        return this._methodName;
                    }
                    setMethodName(methodName) {
                        this._methodName = methodName;
                    }
                    getContextExpr() {
                        return this._contextExpr;
                    }
                    getArgs() {
                        return this._args;
                    }
                }
                code.MethodCallCodeDOM = MethodCallCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class MethodDeclCodeDOM extends code.MemberDeclCodeDOM {
                    constructor(name) {
                        super(name);
                        this._modifiers = [];
                        this._args = [];
                        this._body = [];
                    }
                    getReturnType() {
                        return this._returnType;
                    }
                    setReturnType(returnType) {
                        this._returnType = returnType;
                    }
                    getModifiers() {
                        return this._modifiers;
                    }
                    arg(name, type, optional = false) {
                        this._args.push({
                            name, type, optional
                        });
                    }
                    getArgs() {
                        return this._args;
                    }
                    getBody() {
                        return this._body;
                    }
                    setBody(body) {
                        this._body = body;
                    }
                }
                code.MethodDeclCodeDOM = MethodDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code_3) {
                class RawCodeDOM extends code_3.CodeDOM {
                    constructor(code = "") {
                        super();
                        this._code = code;
                    }
                    static many(...codes) {
                        return codes.map(code => new RawCodeDOM(code));
                    }
                    getCode() {
                        return this._code;
                    }
                }
                code_3.RawCodeDOM = RawCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_2) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Container extends Phaser.GameObjects.Container {
                    constructor(scene, x, y, children) {
                        super(scene, x, y, children);
                        this._editorSupport = new sceneobjects.ContainerEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    getChildren() {
                        return this.list;
                    }
                }
                sceneobjects.Container = Container;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_2.ui || (scene_2.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_3) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Layer extends Phaser.GameObjects.Layer {
                    constructor(scene, list) {
                        super(scene, list);
                        this._editorSupport = new sceneobjects.LayerEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    getChildren() {
                        return super.getChildren();
                    }
                    replace(oldChild, newChild) {
                        newChild.displayList = this;
                        return super.replace(oldChild, newChild);
                    }
                    setInteractive(hitArea, callback, dropZone) {
                        return this;
                    }
                    disableInteractive() {
                        return this;
                    }
                    removeInteractive() {
                        return this;
                    }
                    getIndexList() {
                        return [];
                    }
                    eventNames() {
                        return super["evenNames"]();
                    }
                    // tslint:disable-next-line:ban-types
                    listeners(event) {
                        return super["listeners"](event);
                    }
                    listenerCount(event) {
                        return super["listenerCount"](event);
                    }
                    emit(event, ...args) {
                        return super["emit"](event, ...args);
                    }
                    // tslint:disable-next-line:ban-types
                    on(event, fn, context) {
                        return super["on"](event, fn, context);
                    }
                    // tslint:disable-next-line:ban-types
                    addListener(event, fn, context) {
                        return super["addListener"](event, fn, context);
                    }
                    // tslint:disable-next-line:ban-types
                    once(event, fn, context) {
                        return super["once"](event, fn, context);
                    }
                    // tslint:disable-next-line:ban-types
                    removeListener(event, fn, context, once) {
                        return super["removeListener"](event, fn, context, once);
                    }
                    // tslint:disable-next-line:ban-types
                    off(event, fn, context, once) {
                        return super["off"](event, fn, context, once);
                    }
                    // tslint:disable-next-line:ban-types
                    removeAllListeners(event) {
                        return super["removeAllListeners"](event);
                    }
                    // tslint:disable-next-line:ban-types
                    addToDisplayList(displayList) {
                        return super["addToDisplayList"](displayList);
                    }
                    // tslint:disable-next-line:ban-types
                    addToUpdateList() {
                        return super["addToUpdateList"]();
                    }
                    // tslint:disable-next-line:ban-types
                    removeFromDisplayList() {
                        return Phaser.GameObjects.GameObject.prototype.removeFromDisplayList.call(this);
                    }
                    // tslint:disable-next-line:ban-types
                    removeFromUpdateList() {
                        return Phaser.GameObjects.GameObject.prototype.removeFromUpdateList.call(this);
                    }
                }
                sceneobjects.Layer = Layer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_3.ui || (scene_3.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../ui/sceneobjects/container/Container.ts"/>
/// <reference path="../../ui/sceneobjects/layer/Layer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_4) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var Container = scene_4.ui.sceneobjects.Container;
                var Layer = scene_4.ui.sceneobjects.Layer;
                class SceneCodeDOMBuilder {
                    constructor(scene, file) {
                        this._scene = scene;
                        this._sceneFile = file;
                        this._isPrefabScene = this._scene.isPrefabSceneType();
                        this._fileNameMap = new Map();
                    }
                    async build() {
                        colibri.ui.ide.Workbench.getWorkbench().getFileStorage().getRoot().visit(file => {
                            if (file.isFile()) {
                                this._fileNameMap.set(file.getNameWithoutExtension(), file);
                            }
                        });
                        const settings = this._scene.getSettings();
                        const methods = [];
                        const unit = new code.UnitCodeDOM([]);
                        this._unit = unit;
                        if (settings.onlyGenerateMethods) {
                            const createMethodDecl = this.buildCreateMethod();
                            await this.buildPreloadMethod(unit.getBody());
                            unit.getBody().push(createMethodDecl);
                        }
                        else {
                            const clsName = this._sceneFile.getNameWithoutExtension();
                            const clsDecl = new code.ClassDeclCodeDOM(clsName);
                            clsDecl.setExportClass(settings.exportClass);
                            let superCls;
                            if (this._isPrefabScene) {
                                const obj = this._scene.getPrefabObject();
                                if (!obj) {
                                    return null;
                                }
                                const support = obj.getEditorSupport();
                                if (obj.getEditorSupport().isPrefabInstance()) {
                                    superCls = support.getPrefabName();
                                }
                                else {
                                    superCls = support.getPhaserType();
                                }
                                superCls = settings.superClassName.trim().length === 0 ?
                                    superCls : settings.superClassName;
                            }
                            else {
                                superCls = settings.superClassName.trim().length === 0 ?
                                    "Phaser.Scene" : settings.superClassName;
                            }
                            clsDecl.setSuperClass(superCls);
                            if (superCls.startsWith("Phaser.")) {
                                unit.addImport("Phaser", "phaser");
                            }
                            else {
                                const superClsFile = this._fileNameMap.get(superCls);
                                if (superClsFile) {
                                    const filePath = code.getImportPath(this._sceneFile, superClsFile);
                                    unit.addImport(superCls, filePath);
                                }
                            }
                            if (this._isPrefabScene) {
                                // prefab constructor
                                const ctrMethod = this.buildPrefabConstructorMethod();
                                methods.push(ctrMethod);
                            }
                            else {
                                // scene constructor
                                const key = settings.sceneKey;
                                if (key.trim().length > 0) {
                                    const ctrMethod = this.buildSceneConstructorMethod(key);
                                    methods.push(ctrMethod);
                                }
                                // scene preload method
                                await this.buildPreloadMethod(methods);
                                // scene create method
                                const createMethodDecl = this.buildCreateMethod();
                                methods.push(createMethodDecl);
                            }
                            const fields = [];
                            this.buildObjectClassFields(fields, this._scene.getDisplayListChildren());
                            this.buildPlainObjectsClassFields(fields);
                            this.buildListClassFields(fields);
                            if (this._isPrefabScene) {
                                this.buildPrefabPropertiesFields(fields);
                            }
                            clsDecl.getBody().push(...methods);
                            clsDecl.getBody().push(...fields);
                            if (this._isPrefabScene) {
                                clsDecl.getBody().push(new code.UserSectionCodeDOM("/* START-USER-CODE */", "/* END-USER-CODE */", "\n\n\t// Write your code here.\n\n\t"));
                            }
                            else {
                                const defaultContent = [
                                    "",
                                    "",
                                    "// Write your code here",
                                    "",
                                    "create() {",
                                    "",
                                    "\tthis.editorCreate();",
                                    "}",
                                    "",
                                    ""
                                ].join("\n\t");
                                clsDecl.getBody().push(new code.UserSectionCodeDOM("/* START-USER-CODE */", "/* END-USER-CODE */", defaultContent));
                            }
                            unit.getBody().push(clsDecl);
                        }
                        return unit;
                    }
                    buildPrefabPropertiesFields(fields) {
                        const decls = this._scene.getPrefabUserProperties()
                            .getProperties()
                            .filter(prop => !prop.isCustomDefinition())
                            .flatMap(prop => prop.buildFieldDeclarationCode());
                        fields.push(...decls);
                    }
                    buildPlainObjectsClassFields(fields) {
                        for (const obj of this._scene.getPlainObjects()) {
                            const editorSupport = obj.getEditorSupport();
                            const scope = editorSupport.getScope();
                            if (scope !== scene_4.ui.sceneobjects.ObjectScope.METHOD) {
                                const objType = editorSupport.getPhaserType();
                                const dom = new code.FieldDeclCodeDOM(code.formatToValidVarName(editorSupport.getLabel()), objType, scope === scene_4.ui.sceneobjects.ObjectScope.PUBLIC);
                                dom.setAllowUndefined(!this._scene.isPrefabSceneType());
                                fields.push(dom);
                            }
                        }
                    }
                    buildListClassFields(fields) {
                        const objMap = this._scene.buildObjectIdMap();
                        for (const list of this._scene.getObjectLists().getLists()) {
                            if (list.getScope() !== scene_4.ui.sceneobjects.ObjectScope.METHOD) {
                                const listType = list.inferType(objMap);
                                const dom = new code.FieldDeclCodeDOM(code.formatToValidVarName(list.getLabel()), listType, list.getScope() === scene_4.ui.sceneobjects.ObjectScope.PUBLIC);
                                dom.setAllowUndefined(!this._scene.isPrefabSceneType());
                                fields.push(dom);
                            }
                        }
                    }
                    buildObjectClassFields(fields, children) {
                        for (const obj of children) {
                            const support = obj.getEditorSupport();
                            const isMethodScope = support.getScope() === scene_4.ui.sceneobjects.ObjectScope.METHOD;
                            const isPrefabObj = this._scene.isPrefabSceneType() && this._scene.getPrefabObject() === obj;
                            const isPrefabScene = this._scene.isPrefabSceneType();
                            if (!isMethodScope && !isPrefabObj) {
                                const varName = code.formatToValidVarName(support.getLabel());
                                const type = support.isPrefabInstance()
                                    ? support.getPrefabName()
                                    : support.getPhaserType();
                                const isPublic = support.isPublic();
                                const field = new code.FieldDeclCodeDOM(varName, type, isPublic);
                                // Allow undefined if the object is part of a scene.
                                // In a prefab, the objects are created in the constructor
                                field.setAllowUndefined(!isPrefabScene);
                                fields.push(field);
                            }
                            if ((obj instanceof Container || obj instanceof Layer)
                                && !obj.getEditorSupport().isPrefabInstance()) {
                                this.buildObjectClassFields(fields, obj.getChildren());
                            }
                        }
                    }
                    buildPrefabConstructorMethod() {
                        const ctrDecl = new code.MethodDeclCodeDOM("constructor");
                        const body = ctrDecl.getBody();
                        const prefabObj = this._scene.getPrefabObject();
                        if (!prefabObj) {
                            throw new Error("Invalid prefab scene state: missing object.");
                        }
                        const type = prefabObj.getEditorSupport().getObjectType();
                        const ext = scene_4.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                        const objBuilder = ext.getCodeDOMBuilder();
                        ctrDecl.arg("scene", "Phaser.Scene");
                        objBuilder.buildPrefabConstructorDeclarationCodeDOM({
                            ctrDeclCodeDOM: ctrDecl
                        });
                        {
                            const superCall = new code.MethodCallCodeDOM("super");
                            superCall.arg("scene");
                            objBuilder.buildPrefabConstructorDeclarationSupperCallCodeDOM({
                                superMethodCallCodeDOM: superCall,
                                prefabObj: prefabObj
                            });
                            body.push(superCall);
                            body.push(new code.RawCodeDOM(""));
                        }
                        const lazyStatements = [];
                        const result = this.buildSetObjectProperties({
                            obj: prefabObj,
                            varname: "this"
                        });
                        lazyStatements.push(...result.lazyStatements);
                        body.push(...result.statements);
                        if (prefabObj instanceof Container || prefabObj instanceof Layer) {
                            this.addChildrenObjects({
                                createMethodDecl: ctrDecl,
                                obj: prefabObj,
                                lazyStatements
                            });
                        }
                        this.addCreateAllPlainObjectCode(ctrDecl);
                        this.addCreateListsCode(body);
                        body.push(...lazyStatements);
                        this.addFieldInitCode(body);
                        {
                            // prefab awake handler
                            const settings = this._scene.getSettings();
                            if (settings.generateAwakeHandler) {
                                body.push(new code.RawCodeDOM("// awake handler"));
                                body.push(new code.RawCodeDOM("this.scene.events.once(\"scene-awake\", () => this.awake());"));
                                body.push(new code.RawCodeDOM(""));
                            }
                        }
                        body.push(new code.RawCodeDOM(""));
                        body.push(new code.UserSectionCodeDOM("/* START-USER-CTR-CODE */", "/* END-USER-CTR-CODE */", "\n\t\t// Write your code here.\n\t\t"));
                        this.buildCustomPropertiesInit(body);
                        return ctrDecl;
                    }
                    buildCustomPropertiesInit(body) {
                        const userProps = this._scene.getPrefabUserProperties();
                        const assignDomList = userProps.getProperties()
                            .filter(prop => prop.isCustomDefinition())
                            .map(prop => {
                            const fieldDecl = prop.buildFieldDeclarationCode();
                            const assignDom = new code.AssignPropertyCodeDOM(fieldDecl.getName(), "this");
                            assignDom.value(fieldDecl.getInitialValueExpr());
                            return assignDom;
                        });
                        if (assignDomList.length > 0) {
                            body.push(new code.RawCodeDOM("\n"));
                            body.push(new code.RawCodeDOM("// custom definition props"));
                        }
                        body.push(...assignDomList);
                    }
                    buildCreateMethod() {
                        const settings = this._scene.getSettings();
                        const createMethodDecl = new code.MethodDeclCodeDOM(settings.createMethodName);
                        createMethodDecl.setReturnType("void");
                        if (settings.onlyGenerateMethods && this._scene.isPrefabSceneType()) {
                            createMethodDecl.arg("scene", "Phaser.Scene");
                        }
                        const body = createMethodDecl.getBody();
                        this.addCreateAllPlainObjectCode(createMethodDecl);
                        const lazyStatements = [];
                        for (const obj of this._scene.getDisplayListChildren()) {
                            if (obj.getEditorSupport().isMutableNestedPrefabInstance()) {
                                this.addCreateObjectCodeOfNestedPrefab(obj, createMethodDecl, lazyStatements);
                            }
                            else {
                                body.push(new code.RawCodeDOM(""));
                                body.push(new code.RawCodeDOM("// " + obj.getEditorSupport().getLabel()));
                                this.addCreateObjectCode(obj, createMethodDecl, lazyStatements);
                            }
                        }
                        this.addCreateListsCode(body);
                        body.push(...lazyStatements);
                        this.addFieldInitCode(body);
                        body.push(new code.RawCodeDOM(""));
                        body.push(new code.RawCodeDOM(`this.events.emit("scene-awake");`));
                        return createMethodDecl;
                    }
                    addCreateAllPlainObjectCode(createMethodDecl) {
                        const body = createMethodDecl.getBody();
                        for (const obj of this._scene.getPlainObjects()) {
                            body.push(new code.RawCodeDOM(""));
                            body.push(new code.RawCodeDOM("// " + obj.getEditorSupport().getLabel()));
                            this.addCreatePlainObjectCode(obj, createMethodDecl);
                        }
                    }
                    addCreateListsCode(body) {
                        const lists = this._scene.getObjectLists().getLists();
                        if (lists.length > 0) {
                            body.push(new code.RawCodeDOM(""), new code.RawCodeDOM("// lists"));
                        }
                        for (const list of lists) {
                            const map = this._scene.buildObjectIdMap();
                            const objectVarnames = [];
                            for (const objId of list.getObjectIds()) {
                                const obj = map.get(objId);
                                if (obj) {
                                    objectVarnames.push(code.formatToValidVarName(obj.getEditorSupport().getLabel()));
                                }
                            }
                            const varname = code.formatToValidVarName(list.getLabel());
                            let dom;
                            const isTsOutput = this._scene.getSettings().compilerOutputLanguage === "TYPE_SCRIPT";
                            if (isTsOutput && objectVarnames.length === 0) {
                                dom = new code.RawCodeDOM(`const ${varname}: Array<any> = [${objectVarnames.join(", ")}];`);
                            }
                            else {
                                dom = new code.RawCodeDOM(`const ${varname} = [${objectVarnames.join(", ")}];`);
                            }
                            body.push(dom);
                        }
                    }
                    addFieldInitCode(body) {
                        const fields = [];
                        this._scene.visitAllAskChildren(obj => {
                            const support = obj.getEditorSupport();
                            const prefabObj = this._scene.isPrefabSceneType() ? this._scene.getPrefabObject() : null;
                            if (!support.isMethodScope() && prefabObj !== obj) {
                                const varname = code.formatToValidVarName(support.getLabel());
                                const dom = new code.AssignPropertyCodeDOM(varname, "this");
                                dom.value(varname);
                                fields.push(dom);
                            }
                            return !support.isPrefabInstance();
                        });
                        for (const obj of this._scene.getPlainObjects()) {
                            const editorSupport = obj.getEditorSupport();
                            if (editorSupport.getScope() !== scene_4.ui.sceneobjects.ObjectScope.METHOD) {
                                const varname = code.formatToValidVarName(editorSupport.getLabel());
                                const dom = new code.AssignPropertyCodeDOM(varname, "this");
                                dom.value(varname);
                                fields.push(dom);
                            }
                        }
                        for (const list of this._scene.getObjectLists().getLists()) {
                            if (list.getScope() !== scene_4.ui.sceneobjects.ObjectScope.METHOD) {
                                const varname = code.formatToValidVarName(list.getLabel());
                                const dom = new code.AssignPropertyCodeDOM(varname, "this");
                                dom.value(varname);
                                fields.push(dom);
                            }
                        }
                        if (fields.length > 0) {
                            body.push(new code.RawCodeDOM(""));
                            body.push(...fields);
                        }
                    }
                    addCreatePlainObjectCode(obj, createMethodDecl) {
                        const objSupport = obj.getEditorSupport();
                        const varname = code.formatToValidVarName(objSupport.getLabel());
                        const createObjectMethodCalls = objSupport.getExtension().buildCreateObjectWithFactoryCodeDOM({
                            gameObjectFactoryExpr: this._scene.isPrefabSceneType() ? "scene" : "this",
                            obj: obj,
                            varname
                        });
                        createMethodDecl.getBody().push(...createObjectMethodCalls);
                        const mainCreateMethodCall = createObjectMethodCalls[0];
                        mainCreateMethodCall.setDeclareReturnToVar(true);
                        if (!objSupport.isMethodScope()) {
                            mainCreateMethodCall.setDeclareReturnToVar(true);
                            mainCreateMethodCall.setDeclareReturnToField(true);
                        }
                        if (mainCreateMethodCall.isDeclareReturnToVar()) {
                            mainCreateMethodCall.setReturnToVar(varname);
                        }
                    }
                    addCreateObjectCodeOfNestedPrefab(obj, createMethodDecl, lazyStatements) {
                        const varname = this.getPrefabInstanceVarName(obj);
                        const result = this.buildSetObjectProperties({
                            obj,
                            varname
                        });
                        lazyStatements.push(...result.lazyStatements);
                        createMethodDecl.getBody().push(...result.statements);
                        if (obj instanceof Container || obj instanceof Layer) {
                            this.addChildrenObjects({
                                createMethodDecl,
                                obj,
                                lazyStatements
                            });
                        }
                    }
                    addCreateObjectCode(obj, createMethodDecl, lazyStatements) {
                        const objSupport = obj.getEditorSupport();
                        let createObjectMethodCall;
                        if (objSupport.isPrefabInstance()) {
                            const clsName = objSupport.getPrefabName();
                            const type = objSupport.getObjectType();
                            const ext = scene_4.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            createObjectMethodCall = new code.MethodCallCodeDOM(clsName);
                            createObjectMethodCall.setConstructor(true);
                            const prefabSerializer = objSupport.getPrefabSerializer();
                            if (prefabSerializer) {
                                const builder = ext.getCodeDOMBuilder();
                                builder.buildCreatePrefabInstanceCodeDOM({
                                    obj,
                                    methodCallDOM: createObjectMethodCall,
                                    sceneExpr: this._isPrefabScene ? "scene" : "this",
                                    prefabSerializer
                                });
                                const filePath = code.getImportPath(this._sceneFile, objSupport.getPrefabFile());
                                this._unit.addImport(clsName, filePath);
                            }
                            else {
                                throw new Error(`Cannot find prefab with id ${objSupport.getPrefabId()}.`);
                            }
                        }
                        else {
                            const builder = objSupport.getExtension().getCodeDOMBuilder();
                            createObjectMethodCall = builder.buildCreateObjectWithFactoryCodeDOM({
                                gameObjectFactoryExpr: this._scene.isPrefabSceneType() ? "scene.add" : "this.add",
                                obj: obj
                            });
                        }
                        const varname = code.formatToValidVarName(objSupport.getLabel());
                        const objParent = scene_4.ui.sceneobjects.getObjectParent(obj);
                        createMethodDecl.getBody().push(createObjectMethodCall);
                        if (objSupport.isPrefabInstance()) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            if (!objParent) {
                                const addToScene = new code.MethodCallCodeDOM("existing", "this.add");
                                addToScene.arg(varname);
                                createMethodDecl.getBody().push(addToScene);
                            }
                        }
                        const result = this.buildSetObjectProperties({
                            obj,
                            varname
                        });
                        if (result.statements.length + result.lazyStatements.length > 0) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                        }
                        lazyStatements.push(...result.lazyStatements);
                        createMethodDecl.getBody().push(...result.statements);
                        if (objParent) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            const parentIsPrefabObject = this._scene.isPrefabSceneType()
                                && objParent === this._scene.getPrefabObject();
                            const parentVarname = parentIsPrefabObject ? "this"
                                : code.formatToValidVarName(objParent.getEditorSupport().getLabel());
                            const addToParentCall = new code.MethodCallCodeDOM("add", parentVarname);
                            addToParentCall.arg(varname);
                            createMethodDecl.getBody().push(addToParentCall);
                        }
                        if (obj instanceof Container || obj instanceof Layer) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            this.addChildrenObjects({
                                createMethodDecl,
                                obj,
                                lazyStatements
                            });
                        }
                        {
                            const lists = objSupport.getScene().getObjectLists().getListsByObjectId(objSupport.getId());
                            if (lists.length > 0) {
                                createObjectMethodCall.setDeclareReturnToVar(true);
                            }
                        }
                        if (!objSupport.isMethodScope()) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            createObjectMethodCall.setDeclareReturnToField(true);
                        }
                        if (createObjectMethodCall.isDeclareReturnToVar()) {
                            createObjectMethodCall.setReturnToVar(varname);
                        }
                    }
                    getPrefabInstanceVarName(obj) {
                        const objSupport = obj.getEditorSupport();
                        if (objSupport.isScenePrefabObject()) {
                            return "this";
                        }
                        const varName = code.formatToValidVarName(objSupport.getLabel());
                        if (objSupport.isNestedPrefabInstance()) {
                            const parent = this.findPrefabInstanceThatIsDefinedAsRootPrefab(obj);
                            const parentVarName = this.getPrefabInstanceVarName(parent);
                            return parentVarName + "." + varName;
                        }
                        return varName;
                    }
                    findPrefabInstanceThatIsDefinedAsRootPrefab(obj) {
                        const parent = scene_4.ui.sceneobjects.getObjectParent(obj);
                        if (parent.getEditorSupport().isRootPrefabDefined()) {
                            return parent;
                        }
                        return this.findPrefabInstanceThatIsDefinedAsRootPrefab(parent);
                    }
                    buildSetObjectProperties(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const varname = args.varname;
                        let prefabSerializer = null;
                        if (support.isPrefabInstance()) {
                            prefabSerializer = support.getPrefabSerializer();
                        }
                        const statements = [];
                        const lazyStatements = [];
                        for (const comp of support.getComponents()) {
                            comp.buildSetObjectPropertiesCodeDOM({
                                statements,
                                lazyStatements,
                                objectVarName: varname,
                                prefabSerializer: prefabSerializer,
                                unit: this._unit,
                                sceneFile: this._sceneFile
                            });
                        }
                        return { statements, lazyStatements };
                    }
                    addChildrenObjects(args) {
                        const body = args.createMethodDecl.getBody();
                        const parentIsPrefab = args.obj.getEditorSupport().isPrefabInstance();
                        for (const child of args.obj.getChildren()) {
                            if (child.getEditorSupport().isMutableNestedPrefabInstance()) {
                                this.addCreateObjectCodeOfNestedPrefab(child, args.createMethodDecl, args.lazyStatements);
                            }
                            else if (!parentIsPrefab) {
                                body.push(new code.RawCodeDOM(""));
                                body.push(new code.RawCodeDOM("// " + child.getEditorSupport().getLabel()));
                                this.addCreateObjectCode(child, args.createMethodDecl, args.lazyStatements);
                            }
                        }
                    }
                    buildSceneConstructorMethod(sceneKey) {
                        const methodDecl = new code.MethodDeclCodeDOM("constructor");
                        const superCall = new code.MethodCallCodeDOM("super", null);
                        superCall.argLiteral(sceneKey);
                        const body = methodDecl.getBody();
                        body.push(superCall);
                        body.push(new code.RawCodeDOM(""));
                        body.push(new code.UserSectionCodeDOM("/* START-USER-CTR-CODE */", "/* END-USER-CTR-CODE */", "\n\t\t// Write your code here.\n\t\t"));
                        return methodDecl;
                    }
                    async buildPreloadMethod(methods) {
                        const settings = this._scene.getSettings();
                        if (settings.preloadPackFiles.length === 0) {
                            return;
                        }
                        const preloadDom = new code.MethodDeclCodeDOM(settings.preloadMethodName);
                        preloadDom.setReturnType("void");
                        preloadDom.getBody().push(new code.RawCodeDOM(""));
                        const ctx = (this._isPrefabScene ? "scene" : "this");
                        for (const fileName of settings.preloadPackFiles) {
                            const call = new code.MethodCallCodeDOM("pack", ctx + ".load");
                            const parts = fileName.split("/");
                            const namePart = parts[parts.length - 1];
                            const key = namePart.substring(0, namePart.length - 5);
                            const file = colibri.ui.ide.FileUtils.getFileFromPath(fileName);
                            let fileUrl = parts.slice(1).join("/");
                            if (file) {
                                fileUrl = phasereditor2d.pack.core.AssetPackUtils.getUrlFromAssetFile(file.getParent(), file);
                            }
                            call.argLiteral(key);
                            call.argLiteral(fileUrl);
                            preloadDom.getBody().push(call);
                        }
                        methods.push(preloadDom);
                    }
                }
                code.SceneCodeDOMBuilder = SceneCodeDOMBuilder;
            })(code = core.code || (core.code = {}));
        })(core = scene_4.core || (scene_4.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_5) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class SceneCompileAllExtension extends phasereditor2d.ide.core.CompileProjectExtension {
                    getFiles() {
                        const finder = scene_5.ScenePlugin.getInstance().getSceneFinder();
                        return finder.getSceneFiles();
                    }
                    getTotal() {
                        return this.getFiles().length;
                    }
                    async preload(monitor) {
                        const files = this.getFiles();
                        const finder = scene_5.ScenePlugin.getInstance().getSceneFinder();
                        monitor.addTotal(files.length);
                        for (const file of files) {
                            const data = finder.getSceneData(file);
                            const scene = await scene_5.ui.OfflineScene.createScene(data);
                            const compiler = new core.code.SceneCompiler(scene, file);
                            await compiler.compile();
                            scene.destroyGame();
                            monitor.step();
                        }
                    }
                }
                code.SceneCompileAllExtension = SceneCompileAllExtension;
            })(code = core.code || (core.code = {}));
        })(core = scene_5.core || (scene_5.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_6) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var ide = colibri.ui.ide;
                class SceneCompiler {
                    constructor(scene, sceneFile) {
                        this._scene = scene;
                        this._sceneFile = sceneFile;
                    }
                    getOutputFile() {
                        const settings = this._scene.getSettings();
                        const compileToJS = settings.compilerOutputLanguage === core.json.SourceLang.JAVA_SCRIPT;
                        const fileExt = compileToJS ? "js" : "ts";
                        const fileName = this._sceneFile.getNameWithoutExtension() + "." + fileExt;
                        const outputFile = this._sceneFile.getSibling(fileName);
                        return outputFile;
                    }
                    async compile() {
                        const settings = this._scene.getSettings();
                        if (!settings.compilerEnabled) {
                            return;
                        }
                        const compileToJS = settings.compilerOutputLanguage === core.json.SourceLang.JAVA_SCRIPT;
                        const builder = new core.code.SceneCodeDOMBuilder(this._scene, this._sceneFile);
                        const unit = await builder.build();
                        if (!unit) {
                            return;
                        }
                        const generator = compileToJS ?
                            new core.code.JavaScriptUnitCodeGenerator(unit)
                            : new core.code.TypeScriptUnitCodeGenerator(unit);
                        if (compileToJS) {
                            generator.setInitFieldInConstructor(settings.javaScriptInitFieldsInConstructor);
                        }
                        generator.setGenerateImports(settings.autoImport);
                        const fileExt = compileToJS ? "js" : "ts";
                        const fileName = this._sceneFile.getNameWithoutExtension() + "." + fileExt;
                        let replaceContent = "";
                        {
                            const outputFile = this._sceneFile.getSibling(fileName);
                            if (outputFile) {
                                replaceContent = await ide.FileUtils.getFileStorage().getFileString(outputFile);
                            }
                        }
                        let output = generator.generate(replaceContent);
                        if (settings.compilerInsertSpaces) {
                            const tabs = " ".repeat(Math.max(1, settings.compilerTabSize));
                            output = output.replace(/\t/g, tabs);
                        }
                        await ide.FileUtils.createFile_async(this._sceneFile.getParent(), fileName, output);
                    }
                }
                code.SceneCompiler = SceneCompiler;
            })(code = core.code || (core.code = {}));
        })(core = scene_6.core || (scene_6.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class TypeScriptUnitCodeGenerator extends code.JavaScriptUnitCodeGenerator {
                    constructor(unit) {
                        super(unit);
                    }
                    generateMethodReturnTypeJSDoc(methodDecl) {
                        // nothing, it is made in signature
                    }
                    generateFieldDecl(fieldDecl) {
                        const mod = fieldDecl.isPublic() ? "public" : "private";
                        if (fieldDecl.isInitialized()) {
                            this.line(`${mod} ${fieldDecl.getName()}: ${fieldDecl.getType()} = ${fieldDecl.getInitialValueExpr()};`);
                        }
                        else if (fieldDecl.isAllowUndefined()) {
                            this.line(`${mod} ${fieldDecl.getName()}!: ${fieldDecl.getType()};`);
                        }
                        else {
                            this.line(`${mod} ${fieldDecl.getName()}: ${fieldDecl.getType()};`);
                        }
                    }
                    getMethodReturnDeclText(methodDecl) {
                        if (methodDecl.getReturnType()) {
                            return ": " + methodDecl.getReturnType() + " ";
                        }
                        return " ";
                    }
                    // generateFieldInitInConstructor(classDecl: ClassDeclCodeDOM) {
                    //     // nothing, in TypeScript fields are initialized in the declaration
                    // }
                    generateTypeAnnotation(assign) {
                        // do nothing, in TypeScript uses the var declaration syntax
                    }
                    generateMethodDeclArgs(methodDecl) {
                        this.append(methodDecl.getArgs()
                            .map(arg => `${arg.name}${arg.optional ? "?" : ""}: ${arg.type}`)
                            .join(", "));
                    }
                }
                code.TypeScriptUnitCodeGenerator = TypeScriptUnitCodeGenerator;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class UnitCodeDOM {
                    constructor(elements) {
                        this._body = elements;
                        this._imports = [];
                        this._used = new Set();
                    }
                    getImports() {
                        return this._imports;
                    }
                    addImport(elementName, filePath) {
                        const key = elementName + " form " + filePath;
                        if (this._used.has(key)) {
                            return;
                        }
                        this._used.add(key);
                        this._imports.push(new code.ImportCodeDOM(elementName, filePath));
                    }
                    getBody() {
                        return this._body;
                    }
                    setBody(body) {
                        this._body = body;
                    }
                }
                code.UnitCodeDOM = UnitCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class UserSectionCodeDOM extends code.CodeDOM {
                    constructor(openTag, closeTag, userContent) {
                        super();
                        this._openTag = openTag;
                        this._closeTag = closeTag;
                        this._defaultContent = userContent;
                    }
                    getOpenTag() {
                        return this._openTag;
                    }
                    getCloseTag() {
                        return this._closeTag;
                    }
                    getDefaultContent() {
                        return this._defaultContent;
                    }
                }
                code.UserSectionCodeDOM = UserSectionCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                let SceneType;
                (function (SceneType) {
                    SceneType["SCENE"] = "SCENE";
                    SceneType["PREFAB"] = "PREFAB";
                })(SceneType = json.SceneType || (json.SceneType = {}));
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var read = colibri.core.json.read;
                    class UserComponent {
                        constructor(name) {
                            this._name = name;
                            this._baseClass = "";
                            this._gameObjectType = "Phaser.GameObjects.Image";
                            this._properties = new usercomponent.UserComponentProperties(this);
                        }
                        toJSON() {
                            const propsData = [];
                            this._properties.writeJSON(propsData);
                            const data = {
                                name: this._name,
                                baseClass: this._baseClass,
                                gameObjectType: this._gameObjectType,
                                properties: propsData
                            };
                            return data;
                        }
                        readJSON(data) {
                            this._name = data.name;
                            this._baseClass = read(data, "baseClass", "");
                            this._gameObjectType = read(data, "gameObjectType", "Phaser.GameObjects.Image");
                            this._properties.readJSON(data.properties);
                        }
                        getName() {
                            return this._name;
                        }
                        setName(name) {
                            this._name = name;
                        }
                        getBaseClass() {
                            return this._baseClass;
                        }
                        setBaseClass(baseClass) {
                            this._baseClass = baseClass;
                        }
                        getGameObjectType() {
                            return this._gameObjectType;
                        }
                        setGameObjectType(gameObjectType) {
                            this._gameObjectType = gameObjectType;
                        }
                        getUserProperties() {
                            return this._properties;
                        }
                    }
                    usercomponent.UserComponent = UserComponent;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../ui/editor/usercomponent/UserComponent.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                var FileUtils = colibri.ui.ide.FileUtils;
                var controls = colibri.ui.controls;
                var usercomponent = scene.ui.editor.usercomponent;
                class SceneFinderPreloader extends colibri.ui.ide.PreloadProjectResourcesExtension {
                    constructor(finder) {
                        super();
                        this._finder = finder;
                    }
                    async computeTotal() {
                        return 0;
                    }
                    async preload(monitor) {
                        await this._finder.preload(monitor);
                        await this._finder.runMigrations();
                    }
                }
                class SceneFinder {
                    constructor() {
                        this._prefabObjectId_ObjectData_Map = new Map();
                        this._nestedPrefabIds = new Set();
                        this._sceneFilename_Data_Map = new Map();
                        this._sceneFilename_Settings_Map = new Map();
                        this._prefabId_File_Map = new Map();
                        this._sceneFiles = [];
                        this._prefabFiles = [];
                        this._compFiles = [];
                        this._compFilename_Data_Map = new Map();
                        this._compModelsInfo = [];
                        this._enabled = true;
                        colibri.ui.ide.FileUtils.getFileStorage().addChangeListener(async (e) => {
                            await this.handleStorageChange(e);
                        });
                    }
                    async handleStorageChange(change) {
                        const test = (names) => {
                            for (const name of names) {
                                if (name.endsWith(".scene") || name.endsWith(".components")) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        if (test(change.getAddRecords())
                            || test(change.getModifiedRecords())
                            || test(change.getDeleteRecords())
                            || test(change.getRenameFromRecords())
                            || test(change.getRenameToRecords())) {
                            await this.preload(controls.EMPTY_PROGRESS_MONITOR);
                        }
                    }
                    getProjectPreloader() {
                        return new SceneFinderPreloader(this);
                    }
                    async preload(monitor) {
                        if (!this.isEnabled()) {
                            return;
                        }
                        const total = (await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_SCENE)).length
                            + (await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_USER_COMPONENTS)).length
                            + 1;
                        monitor.addTotal(total);
                        await this.preloadSceneFiles(monitor);
                        await this.preloadComponentsFiles(monitor);
                        monitor.step();
                    }
                    async runMigrations() {
                        for (const data of this._sceneFilename_Data_Map.values()) {
                            await scene.ScenePlugin.getInstance().runSceneDataMigrations(data);
                        }
                    }
                    async preloadComponentsFiles(monitor) {
                        const compFiles = [];
                        const compFilename_Data_Map = new Map();
                        const compModels = [];
                        const files = await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_USER_COMPONENTS);
                        for (const file of files) {
                            const content = await FileUtils.preloadAndGetFileString(file);
                            try {
                                const data = JSON.parse(content);
                                const model = new usercomponent.UserComponentsModel();
                                model.readJSON(data);
                                compModels.push({ file, model });
                                compFilename_Data_Map.set(file.getFullName(), model);
                                compFiles.push(file);
                            }
                            catch (e) {
                                console.error(`SceneDataTable: parsing file ${file.getFullName()}. Error: ${e.message}`);
                            }
                            monitor.step();
                        }
                        this._compFiles = compFiles;
                        this._compFilename_Data_Map = compFilename_Data_Map;
                        this._compModelsInfo = compModels;
                    }
                    setEnabled(enabled) {
                        this._enabled = enabled;
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    async preloadSceneFiles(monitor) {
                        const sceneIdSet = new Set();
                        const prefabObjectId_ObjectData_Map = new Map();
                        const nestedPrefabIds = new Set();
                        const sceneFilename_Data_Map = new Map();
                        const sceneFilename_Settings_Map = new Map();
                        const prefabId_File_Map = new Map();
                        const sceneFiles = [];
                        const prefabFiles = [];
                        const files = await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_SCENE);
                        files.sort((a, b) => b.getModTime() - a.getModTime());
                        for (const file of files) {
                            const content = await FileUtils.preloadAndGetFileString(file);
                            try {
                                const data = JSON.parse(content);
                                // await ScenePlugin.getInstance().runSceneDataMigrations(data);
                                sceneFilename_Data_Map.set(file.getFullName(), data);
                                {
                                    const settings = new json.SceneSettings();
                                    settings.readJSON(data.settings);
                                    sceneFilename_Settings_Map.set(file.getFullName(), settings);
                                }
                                if (data.id) {
                                    if (sceneIdSet.has(data.id)) {
                                        const mappedFile = prefabId_File_Map.get(data.id);
                                        alert(`ERROR! File ${mappedFile.getFullName()} has a duplicated ID ${data.id}. Run the command Fix Duplicated Scenes ID.`);
                                    }
                                    else {
                                        sceneIdSet.add(data.id);
                                    }
                                    if (data.displayList.length > 0) {
                                        const objData = data.displayList[data.displayList.length - 1];
                                        prefabObjectId_ObjectData_Map.set(data.id, objData);
                                        prefabId_File_Map.set(data.id, file);
                                        this.mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, objData);
                                    }
                                    if (data.sceneType === json.SceneType.PREFAB) {
                                        prefabFiles.push(file);
                                    }
                                }
                                sceneFiles.push(file);
                            }
                            catch (e) {
                                console.error(`SceneDataTable: parsing file ${file.getFullName()}. Error: ${e.message}`);
                            }
                            monitor.step();
                        }
                        this._prefabObjectId_ObjectData_Map = prefabObjectId_ObjectData_Map;
                        this._nestedPrefabIds = nestedPrefabIds;
                        this._sceneFilename_Data_Map = sceneFilename_Data_Map;
                        this._sceneFilename_Settings_Map = sceneFilename_Settings_Map;
                        this._prefabId_File_Map = prefabId_File_Map;
                        this._sceneFiles = sceneFiles;
                        this._prefabFiles = prefabFiles;
                    }
                    mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, objData) {
                        if (objData.list) {
                            for (const c of objData.list) {
                                if (c.scope === scene.ui.sceneobjects.ObjectScope.NESTED_PREFAB) {
                                    prefabObjectId_ObjectData_Map.set(c.id, c);
                                    prefabId_File_Map.set(c.id, file);
                                    nestedPrefabIds.add(c.id);
                                    this.mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, c);
                                }
                            }
                        }
                        if (objData.nestedPrefabs) {
                            for (const c of objData.nestedPrefabs) {
                                prefabObjectId_ObjectData_Map.set(c.id, c);
                                prefabId_File_Map.set(c.id, file);
                                nestedPrefabIds.add(c.id);
                                this.mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, c);
                            }
                        }
                    }
                    getUserComponentsFiles() {
                        return this._compFiles;
                    }
                    getUserComponentsByFile(file) {
                        return this._compFilename_Data_Map.get(file.getFullName());
                    }
                    getUserComponentsModels() {
                        return this._compModelsInfo;
                    }
                    getUserComponentByName(name) {
                        for (const info of this._compModelsInfo) {
                            for (const comp of info.model.getComponents()) {
                                if (comp.getName() === name) {
                                    return {
                                        file: info.file,
                                        model: info.model,
                                        component: comp
                                    };
                                }
                            }
                        }
                        return undefined;
                    }
                    getPrefabId(file) {
                        const data = this.getSceneData(file);
                        if (data) {
                            if (data.sceneType === json.SceneType.PREFAB) {
                                return data.id;
                            }
                        }
                        return null;
                    }
                    getSceneFiles() {
                        return this._sceneFiles;
                    }
                    getPrefabFiles() {
                        return this._prefabFiles;
                    }
                    getOriginalPrefabId(prefabId) {
                        const objData = this.getPrefabData(prefabId);
                        if (!objData) {
                            return undefined;
                        }
                        if (objData.prefabId) {
                            return this.getOriginalPrefabId(objData.prefabId);
                        }
                        return prefabId;
                    }
                    isNestedPrefab(prefabId) {
                        return this._nestedPrefabIds.has(prefabId);
                    }
                    existsPrefab(prefabId) {
                        return this._prefabObjectId_ObjectData_Map.has(prefabId);
                    }
                    getPrefabData(prefabId) {
                        return this._prefabObjectId_ObjectData_Map.get(prefabId);
                    }
                    getPrefabFile(prefabId) {
                        return this._prefabId_File_Map.get(prefabId);
                    }
                    getPrefabHierarchy(prefabId) {
                        return this.getPrefabHierarchy2(prefabId, []);
                    }
                    getPrefabHierarchy2(prefabId, result) {
                        const file = this.getPrefabFile(prefabId);
                        if (file) {
                            result.push(file);
                            const objData = this.getPrefabData(prefabId);
                            if (objData && objData.prefabId) {
                                this.getPrefabHierarchy2(objData.prefabId, result);
                            }
                        }
                        return result;
                    }
                    getSceneData(file) {
                        return this._sceneFilename_Data_Map.get(file.getFullName());
                    }
                    getSceneSettings(file) {
                        return this._sceneFilename_Settings_Map.get(file.getFullName());
                    }
                    getScenePhaserType(file) {
                        const data = this.getSceneData(file);
                        if (data.sceneType === core.json.SceneType.SCENE) {
                            return "Phaser.Scene";
                        }
                        const prefabId = this.getPrefabId(file);
                        if (prefabId) {
                            const prefabData = this.getPrefabData(prefabId);
                            if (prefabData) {
                                const serializer = new core.json.Serializer(prefabData);
                                const type = serializer.getPhaserType();
                                return type;
                            }
                        }
                        return undefined;
                    }
                    getAllSceneData() {
                        return this.getSceneFiles().map(file => this.getSceneData(file));
                    }
                    printDebugInfo() {
                        console.log("Scene Finder debug:");
                        for (const prefab of this._prefabFiles) {
                            console.log("Prefab file '" + prefab.getFullName() + "'");
                        }
                        for (const id of this._prefabObjectId_ObjectData_Map.keys()) {
                            console.log("Prefab data " + id + ":");
                            console.log(this._prefabObjectId_ObjectData_Map.get(id));
                        }
                    }
                }
                json.SceneFinder = SceneFinder;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                var read = colibri.core.json.read;
                var write = colibri.core.json.write;
                class SceneSettings {
                    constructor(compilerEnabled = true, compilerInsertSpaces = false, compilerTabSize = 4, snapEnabled = false, snapWidth = 16, snapHeight = 16, onlyGenerateMethods = false, superClassName = "", preloadMethodName = "preload", preloadPackFiles = [], createMethodName = "create", javaScriptInitFieldsInConstructor = false, sceneKey = "", exportClass = false, autoImport = false, generateAwakeHandler = false, compilerOutputLanguage = json.SourceLang.JAVA_SCRIPT, scopeBlocksToFolder = false, borderX = 0, borderY = 0, borderWidth = 800, borderHeight = 600) {
                        this.compilerEnabled = compilerEnabled;
                        this.compilerInsertSpaces = compilerInsertSpaces;
                        this.compilerTabSize = compilerTabSize;
                        this.snapEnabled = snapEnabled;
                        this.snapWidth = snapWidth;
                        this.snapHeight = snapHeight;
                        this.onlyGenerateMethods = onlyGenerateMethods;
                        this.superClassName = superClassName;
                        this.preloadMethodName = preloadMethodName;
                        this.preloadPackFiles = preloadPackFiles;
                        this.createMethodName = createMethodName;
                        this.javaScriptInitFieldsInConstructor = javaScriptInitFieldsInConstructor;
                        this.sceneKey = sceneKey;
                        this.exportClass = exportClass;
                        this.autoImport = autoImport;
                        this.generateAwakeHandler = generateAwakeHandler;
                        this.compilerOutputLanguage = compilerOutputLanguage;
                        this.scopeBlocksToFolder = scopeBlocksToFolder;
                        this.borderX = borderX;
                        this.borderY = borderY;
                        this.borderWidth = borderWidth;
                        this.borderHeight = borderHeight;
                    }
                    toJSON() {
                        const data = {};
                        write(data, "compilerEnabled", this.compilerEnabled, true);
                        write(data, "compilerInsertSpaces", this.compilerInsertSpaces, false);
                        write(data, "compilerTabSize", this.compilerTabSize, 4);
                        write(data, "snapEnabled", this.snapEnabled, false);
                        write(data, "snapWidth", this.snapWidth, 16);
                        write(data, "snapHeight", this.snapHeight, 16);
                        write(data, "onlyGenerateMethods", this.onlyGenerateMethods, false);
                        write(data, "javaScriptInitFieldsInConstructor", this.javaScriptInitFieldsInConstructor, false);
                        write(data, "exportClass", this.exportClass, false);
                        write(data, "autoImport", this.autoImport, false);
                        write(data, "generateAwakeHandler", this.generateAwakeHandler, false);
                        write(data, "superClassName", this.superClassName, "");
                        write(data, "preloadMethodName", this.preloadMethodName, "preload");
                        write(data, "preloadPackFiles", this.preloadPackFiles, []);
                        write(data, "createMethodName", this.createMethodName, "create");
                        write(data, "sceneKey", this.sceneKey, "");
                        write(data, "compilerOutputLanguage", this.compilerOutputLanguage, json.SourceLang.JAVA_SCRIPT);
                        write(data, "scopeBlocksToFolder", this.scopeBlocksToFolder, false);
                        write(data, "borderX", this.borderX, 0);
                        write(data, "borderY", this.borderY, 0);
                        write(data, "borderWidth", this.borderWidth, 800);
                        write(data, "borderHeight", this.borderHeight, 600);
                        return data;
                    }
                    readJSON(data) {
                        this.compilerEnabled = read(data, "compilerEnabled", true);
                        this.compilerInsertSpaces = read(data, "compilerInsertSpaces", false);
                        this.compilerTabSize = read(data, "compilerTabSize", 4);
                        this.snapEnabled = read(data, "snapEnabled", false);
                        this.snapWidth = read(data, "snapWidth", 16);
                        this.snapHeight = read(data, "snapHeight", 16);
                        this.onlyGenerateMethods = read(data, "onlyGenerateMethods", false);
                        this.javaScriptInitFieldsInConstructor = read(data, "javaScriptInitFieldsInConstructor", false);
                        this.exportClass = read(data, "exportClass", false);
                        this.autoImport = read(data, "autoImport", false);
                        this.generateAwakeHandler = read(data, "generateAwakeHandler", false);
                        this.superClassName = read(data, "superClassName", "");
                        this.preloadMethodName = read(data, "preloadMethodName", "preload");
                        this.preloadPackFiles = read(data, "preloadPackFiles", []);
                        this.createMethodName = read(data, "createMethodName", "create");
                        this.sceneKey = read(data, "sceneKey", "");
                        this.compilerOutputLanguage = read(data, "compilerOutputLanguage", json.SourceLang.JAVA_SCRIPT);
                        this.scopeBlocksToFolder = read(data, "scopeBlocksToFolder", false);
                        this.borderX = read(data, "borderX", 0);
                        this.borderY = read(data, "borderY", 0);
                        this.borderWidth = read(data, "borderWidth", 800);
                        this.borderHeight = read(data, "borderHeight", 600);
                    }
                }
                json.SceneSettings = SceneSettings;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_7) {
        var core;
        (function (core) {
            var json;
            (function (json_1) {
                class SceneWriter {
                    constructor(scene) {
                        this._scene = scene;
                    }
                    toJSON() {
                        const sceneData = {
                            id: this._scene.getId(),
                            sceneType: this._scene.getSceneType(),
                            settings: this._scene.getSettings().toJSON(),
                            displayList: [],
                            plainObjects: [],
                            meta: {
                                app: "Phaser Editor 2D - Scene Editor",
                                url: "https://phasereditor2d.com",
                                contentType: core.CONTENT_TYPE_SCENE,
                                version: scene_7.ui.Scene.CURRENT_VERSION
                            }
                        };
                        // object lists
                        this._scene.getObjectLists().writeJSON(sceneData);
                        // plain objects
                        for (const obj of this._scene.getPlainObjects()) {
                            const objData = {};
                            obj.getEditorSupport().writeJSON(objData);
                            sceneData.plainObjects.push(objData);
                        }
                        // display list
                        for (const obj of this._scene.getDisplayListChildren()) {
                            const objData = {};
                            obj.getEditorSupport().writeJSON(objData);
                            sceneData.displayList.push(objData);
                        }
                        // prefab properties
                        const prefabProperties = [];
                        this._scene.getPrefabUserProperties().writeJSON(prefabProperties);
                        if (prefabProperties.length > 0) {
                            sceneData.prefabProperties = prefabProperties;
                        }
                        return sceneData;
                    }
                    toString() {
                        const json = this.toJSON();
                        return JSON.stringify(json);
                    }
                }
                json_1.SceneWriter = SceneWriter;
            })(json = core.json || (core.json = {}));
        })(core = scene_7.core || (scene_7.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                class Serializer {
                    constructor(data) {
                        this._data = data;
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        if (this._data.prefabId) {
                            const prefabData = finder.getPrefabData(this._data.prefabId);
                            if (prefabData) {
                                this._prefabSer = new Serializer(prefabData);
                            }
                            else {
                                finder.printDebugInfo();
                                throw new Error(`[${this._data.label}] Cannot find scene prefab with id "${this._data.prefabId}".`);
                            }
                        }
                    }
                    getSerializer(data) {
                        return new Serializer(data);
                    }
                    getData() {
                        return this._data;
                    }
                    getType() {
                        if (this._prefabSer) {
                            return this._prefabSer.getType();
                        }
                        return this._data.type;
                    }
                    getPhaserType() {
                        if (this._prefabSer) {
                            return this._prefabSer.getPhaserType();
                        }
                        const ext = scene.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(this._data.type);
                        if (!ext) {
                            const msg = `Cannot find extension for ObjectType '${this._data.type}'`;
                            alert(msg);
                            throw new Error(msg);
                        }
                        return ext.getPhaserTypeName();
                    }
                    getDefaultValue(name, defaultValue) {
                        if (this.isPrefabInstance()) {
                            if (!this.isUnlocked(name)) {
                                const defaultPrefabValue = this._prefabSer.getDefaultValue(name, defaultValue);
                                if (defaultPrefabValue !== undefined) {
                                    return defaultPrefabValue;
                                }
                                return defaultValue;
                            }
                        }
                        const localValue = this._data[name];
                        if (localValue === undefined) {
                            return defaultValue;
                        }
                        return localValue;
                    }
                    isUnlocked(name) {
                        if (this.isPrefabInstance()) {
                            // check if it is a local component property
                            if (this._data.components) {
                                for (const compName of this._data.components) {
                                    if (name.startsWith(compName + ".")) {
                                        return true;
                                    }
                                }
                            }
                            if (this._data.unlock) {
                                const i = this._data.unlock.indexOf(name);
                                return i >= 0;
                            }
                            return false;
                        }
                        return true;
                    }
                    setUnlocked(name, unlocked) {
                        if (this.isPrefabInstance()) {
                            const set = new Set(...(this._data.unlock ? this._data.unlock : []));
                            if (unlocked) {
                                set.add(name);
                            }
                            else {
                                set.delete(name);
                            }
                            this._data.unlock = [...set];
                        }
                    }
                    isPrefabInstance() {
                        return typeof this._data.prefabId === "string";
                    }
                    write(name, value, defValue) {
                        if (this.isPrefabInstance()) {
                            if (this.isUnlocked(name)) {
                                // const defValue2 = this.getDefaultValue(name, defValue);
                                // colibri.core.json.write(this._data, name, value, defValue2);
                                this._data[name] = value;
                            }
                        }
                        else {
                            colibri.core.json.write(this._data, name, value, defValue);
                        }
                    }
                    read(name, defValue) {
                        // const defValue2 = this.getDefaultValue(name, defValue);
                        // const value = colibri.core.json.read(this._data, name, defValue2);
                        // return value;
                        if (this.isPrefabInstance()) {
                            const prefabValue = this.getDefaultValue(name, defValue);
                            if (this.isUnlocked(name)) {
                                return colibri.core.json.read(this._data, name, prefabValue);
                            }
                            return prefabValue;
                        }
                        return colibri.core.json.read(this._data, name, defValue);
                    }
                }
                json.Serializer = Serializer;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                let SourceLang;
                (function (SourceLang) {
                    SourceLang["JAVA_SCRIPT"] = "JAVA_SCRIPT";
                    SourceLang["TYPE_SCRIPT"] = "TYPE_SCRIPT";
                })(SourceLang = json.SourceLang || (json.SourceLang = {}));
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                class Version1ToVersion2Migration {
                    migrate(data) {
                        console.log("Migrating: unlock position by default");
                        this.migrateUnlockPosition(data.displayList);
                    }
                    migrateUnlockPosition(list) {
                        if (list) {
                            for (const obj of list) {
                                if (obj.prefabId) {
                                    console.log(`Migrating: unlock position of ${obj.label}(${obj.id})`);
                                    obj.unlock = obj.unlock ?? [];
                                    obj.unlock.push("x", "y");
                                }
                                this.migrateUnlockPosition(obj.list);
                            }
                        }
                    }
                }
                json.Version1ToVersion2Migration = Version1ToVersion2Migration;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            class SceneDataMigrationExtension extends colibri.Extension {
                constructor(priority) {
                    super(SceneDataMigrationExtension.POINT_ID, priority);
                }
            }
            SceneDataMigrationExtension.POINT_ID = "phasereditor2d.scene.ui.SceneDataMigrationExtension";
            ui.SceneDataMigrationExtension = SceneDataMigrationExtension;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
///<reference path="../../ui/SceneDataMigrationExtension.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var migrations;
            (function (migrations) {
                class OriginMigration_v2_to_v3 extends scene.ui.SceneDataMigrationExtension {
                    async migrate(data) {
                        const version = data.meta.version ?? 1;
                        if (version < 3) {
                            await this.migrateList(data.displayList);
                        }
                    }
                    async migrateList(list) {
                        for (const obj of list) {
                            const serializer = new core.json.Serializer(obj);
                            const type = serializer.getType();
                            if (type === "Text" || type === "BitmapText") {
                                const origin = {
                                    originX: serializer.read("originX", 0.5),
                                    originY: serializer.read("originY", 0.5),
                                };
                                Object.assign(obj, origin);
                            }
                            if (obj.list) {
                                await this.migrateList(obj.list);
                            }
                            if (obj.nestedPrefabs) {
                                await this.migrateList(obj.nestedPrefabs);
                            }
                        }
                    }
                }
                migrations.OriginMigration_v2_to_v3 = OriginMigration_v2_to_v3;
            })(migrations = core.migrations || (core.migrations = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            class BaseScene extends Phaser.Scene {
                constructor(key) {
                    super(key);
                    this._packCache = new phasereditor2d.pack.core.parsers.AssetPackCache();
                    this._maker = this.createSceneMaker();
                }
                getPackCache() {
                    return this._packCache;
                }
                getMaker() {
                    return this._maker;
                }
                getCamera() {
                    return this.cameras.main;
                }
                destroyGame() {
                    if (this.game) {
                        this.game.destroy(true);
                        this.game.loop.tick();
                    }
                }
            }
            ui.BaseScene = BaseScene;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_8) {
        var ui;
        (function (ui) {
            class BaseSceneMaker {
                constructor(scene) {
                    this._packFinder = new phasereditor2d.pack.core.PackFinder();
                    this._scene = scene;
                }
                getPackFinder() {
                    return this._packFinder;
                }
                getScene() {
                    return this._scene;
                }
                async preload() {
                    await this.getPackFinder().preload();
                    const updaters = scene_8.ScenePlugin.getInstance().getLoaderUpdaters();
                    for (const updater of updaters) {
                        updater.clearCache(this._scene.game);
                    }
                }
            }
            ui.BaseSceneMaker = BaseSceneMaker;
        })(ui = scene_8.ui || (scene_8.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            Phaser.Cameras.Scene2D.Camera.prototype.getScreenPoint = function (worldX, worldY) {
                // const x = worldX * this.zoom - this.scrollX * this.zoom;
                // const y = worldY * this.zoom - this.scrollY * this.zoom;
                const x = (worldX - this.scrollX) * this.zoom;
                const y = (worldY - this.scrollY) * this.zoom;
                return new Phaser.Math.Vector2(x, y);
            };
            Phaser.Cameras.Scene2D.Camera.prototype.getWorldPoint2 = function (screenX, screenY) {
                const x = screenX / this.zoom + this.scrollX;
                const y = screenY / this.zoom + this.scrollY;
                return new Phaser.Math.Vector2(x, y);
            };
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var io = colibri.core.io;
            class ManySceneFileSection extends controls.properties.PropertySection {
                constructor(page) {
                    super(page, "phasereditor2d.scene.ui.ManySceneFileSection", "Scene", true, false);
                }
                createForm(parent) {
                    const viewer = new phasereditor2d.files.ui.views.GridImageFileViewer();
                    const filteredViewer = new colibri.ui.ide.properties.FilteredViewerInPropertySection(this.getPage(), viewer, true);
                    parent.appendChild(filteredViewer.getElement());
                    this.addUpdater(() => {
                        viewer.setInput([]);
                        viewer.repaint();
                        viewer.setInput(this.getSelection());
                        filteredViewer.resizeTo();
                    });
                }
                canEdit(obj, n) {
                    return obj instanceof io.FilePath
                        && colibri.Platform.getWorkbench().getContentTypeRegistry()
                            .getCachedContentType(obj) === scene.core.CONTENT_TYPE_SCENE;
                }
                canEditNumber(n) {
                    return n > 1;
                }
            }
            ui.ManySceneFileSection = ManySceneFileSection;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseScene.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_9) {
        var ui;
        (function (ui) {
            class Scene extends ui.BaseScene {
                constructor(editor) {
                    super("ObjectScene");
                    this._id = Phaser.Utils.String.UUID();
                    this._editor = editor;
                    this._settings = new scene_9.core.json.SceneSettings();
                    this._objectLists = new ui.sceneobjects.ObjectLists();
                    this._plainObjects = [];
                    this._prefabProperties = new ui.sceneobjects.PrefabUserProperties();
                    this._version = Scene.CURRENT_VERSION;
                }
                getVersion() {
                    return this._version;
                }
                setVersion(version) {
                    this._version = version;
                }
                sortObjectsByIndex(objects) {
                    const map = new Map();
                    this.buildSortingMap(map, this.getDisplayListChildren(), 0);
                    objects.sort((a, b) => {
                        const aa = map.get(a);
                        const bb = map.get(b);
                        return aa - bb;
                    });
                }
                buildSortingMap(map, list, index) {
                    for (const obj of list) {
                        index++;
                        map.set(obj, index);
                        if (!obj.getEditorSupport().isPrefabInstance()) {
                            const children = ui.sceneobjects.GameObjectEditorSupport.getObjectChildren(obj);
                            index = this.buildSortingMap(map, children, index);
                        }
                    }
                    return index;
                }
                readPlainObjects(list) {
                    this._plainObjects = [];
                    for (const objData of list) {
                        const ext = scene_9.ScenePlugin.getInstance().getPlainObjectExtensionByObjectType(objData.type);
                        if (ext) {
                            const plainObject = ext.createPlainObjectWithData({
                                scene: this,
                                data: objData
                            });
                            plainObject.getEditorSupport().readJSON(objData);
                            this.addPlainObject(plainObject);
                        }
                    }
                }
                removePlainObjects(objects) {
                    const set = new Set(objects);
                    this._plainObjects = this._plainObjects.filter(obj => !set.has(obj));
                    for (const obj of set) {
                        obj.getEditorSupport().destroy();
                    }
                }
                addPlainObject(obj) {
                    this._plainObjects.push(obj);
                }
                getPlainObjectById(id) {
                    return this.getPlainObjects().find(o => o.getEditorSupport().getId() === id);
                }
                getPlainObjects() {
                    return this._plainObjects;
                }
                getPlainObjectsByCategory(category) {
                    return this._plainObjects.filter(obj => obj.getEditorSupport()
                        .getExtension().getCategory() === category);
                }
                createSceneMaker() {
                    return new ui.SceneMaker(this);
                }
                getEditor() {
                    return this._editor;
                }
                registerDestroyListener(name) {
                    // console.log(name + ": register destroy listener.");
                    // this.game.events.on(Phaser.Core.Events.DESTROY, e => {
                    //     console.log(name + ": destroyed.");
                    // });
                }
                removeAll() {
                    this.sys.updateList.removeAll();
                    this.sys.displayList.removeAll();
                    // a hack to clean the whole scene
                    this.input["_list"].length = 0;
                    this.input["_pendingInsertion"].length = 0;
                    this.input["_pendingRemoval"].length = 0;
                    for (const obj of this.getDisplayListChildren()) {
                        obj.getEditorSupport().destroy();
                    }
                }
                getPrefabObject() {
                    if (this.sys.displayList) {
                        const list = this.getDisplayListChildren();
                        return list[list.length - 1];
                    }
                    return undefined;
                }
                isNonTopPrefabObject(obj) {
                    const support = ui.sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                    if (support) {
                        const scene = support.getScene();
                        if (scene.isPrefabSceneType()) {
                            if (scene.getPrefabObject() !== obj) {
                                const parent = ui.sceneobjects.getObjectParent(obj);
                                if (parent) {
                                    return this.isNonTopPrefabObject(parent);
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                }
                getObjectLists() {
                    return this._objectLists;
                }
                getSettings() {
                    return this._settings;
                }
                getPrefabUserProperties() {
                    return this._prefabProperties;
                }
                getId() {
                    return this._id;
                }
                setId(id) {
                    this._id = id;
                }
                getSceneType() {
                    return this._sceneType;
                }
                isPrefabSceneType() {
                    return this.getSceneType() === scene_9.core.json.SceneType.PREFAB;
                }
                setSceneType(sceneType) {
                    this._sceneType = sceneType;
                }
                getMaker() {
                    return super.getMaker();
                }
                getDisplayListChildren() {
                    return this.sys.displayList.getChildren();
                }
                getInputSortedObjects() {
                    return this.getInputSortedObjects2([], this.getDisplayListChildren());
                }
                getInputSortedObjects2(result, list) {
                    for (const obj of list) {
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            if (obj.visible && obj.alpha > 0) {
                                this.getInputSortedObjects2(result, obj.getChildren());
                            }
                        }
                        else {
                            result.push(obj);
                        }
                    }
                    return result;
                }
                visitAll(visitor) {
                    this.visit(visitor, this.getDisplayListChildren());
                }
                visit(visitor, children) {
                    for (const obj of children) {
                        visitor(obj);
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            this.visit(visitor, obj.getChildren());
                        }
                    }
                }
                visitAllAskChildren(visitor) {
                    this.visitAskChildren(visitor, this.getDisplayListChildren());
                }
                visitAskChildren(visitor, children) {
                    for (const obj of children) {
                        const visitChildren = visitor(obj);
                        if (visitChildren) {
                            if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                                this.visitAskChildren(visitor, obj.getChildren());
                            }
                        }
                    }
                }
                makeNewName(baseName) {
                    const nameMaker = this.createNameMaker();
                    return nameMaker.makeName(baseName);
                }
                createNameMaker() {
                    const nameMaker = new colibri.ui.ide.utils.NameMaker((obj) => {
                        if (ui.sceneobjects.isGameObject(obj)) {
                            return obj.getEditorSupport().getLabel();
                        }
                        return obj.getLabel();
                    });
                    this.visitAllAskChildren(obj => {
                        nameMaker.update([obj]);
                        return !obj.getEditorSupport().isPrefabInstance();
                    });
                    for (const list of this._objectLists.getLists()) {
                        nameMaker.update([list]);
                    }
                    return nameMaker;
                }
                /**
                 * Map an object with its pre-order index. This can be used to sort objects.
                 */
                buildObjectSortingMap() {
                    const map = new Map();
                    this.buildObjectSortingMap2(map, this.getDisplayListChildren());
                    return map;
                }
                sortObjectsByRenderingOrder(list) {
                    const map = this.buildObjectSortingMap();
                    list.sort((a, b) => {
                        const aa = map.get(a);
                        const bb = map.get(b);
                        return aa - bb;
                    });
                }
                buildObjectSortingMap2(map, list) {
                    let i = 0;
                    for (const obj of list) {
                        map.set(obj, i);
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            i += this.buildObjectSortingMap2(map, obj.getChildren());
                        }
                        i++;
                    }
                    return i;
                }
                buildObjectIdMap() {
                    const map = new Map();
                    this.visitAll(obj => {
                        map.set(obj.getEditorSupport().getId(), obj);
                    });
                    return map;
                }
                snapPoint(x, y) {
                    if (this._settings.snapEnabled) {
                        return {
                            x: Math.round(x / this._settings.snapWidth) * this._settings.snapWidth,
                            y: Math.round(y / this._settings.snapHeight) * this._settings.snapHeight
                        };
                    }
                    return { x, y };
                }
                snapVector(vector) {
                    const result = this.snapPoint(vector.x, vector.y);
                    vector.set(result.x, result.y);
                }
                getByEditorId(id) {
                    const obj = Scene.findByEditorId(this.getDisplayListChildren(), id);
                    if (!obj) {
                        console.error(`Object with id=${id} not found.`);
                    }
                    return obj;
                }
                debugFindDuplicatedEditorId(list, set) {
                    set = set ?? new Set();
                    for (const obj of (list ?? this.getDisplayListChildren())) {
                        const id = obj.getEditorSupport().getId();
                        if (set.has(id)) {
                            console.error("Duplicated " + obj.getEditorSupport().getLabel() + " id " + id);
                        }
                        else {
                            console.log("New " + obj.getEditorSupport().getLabel() + " id " + id);
                            set.add(id);
                        }
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            this.debugFindDuplicatedEditorId(obj.list, set);
                        }
                    }
                }
                static findByEditorId(list, id) {
                    for (const obj of list) {
                        if (obj.getEditorSupport().getId() === id) {
                            return obj;
                        }
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            const result = this.findByEditorId(obj.getChildren(), id);
                            if (result) {
                                return result;
                            }
                        }
                    }
                    return null;
                }
                create() {
                    this.registerDestroyListener("Scene");
                    if (this._editor) {
                        const camera = this.getCamera();
                        camera.setOrigin(0, 0);
                    }
                }
            }
            Scene.CURRENT_VERSION = 3;
            ui.Scene = Scene;
        })(ui = scene_9.ui || (scene_9.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./Scene.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_10) {
        var ui;
        (function (ui) {
            class OfflineScene extends ui.Scene {
                constructor(data) {
                    super();
                    this._data = data;
                }
                static async createScene(data) {
                    const promise = new Promise((resolve, reject) => {
                        const scene = new OfflineScene(data);
                        scene.setCallback(() => {
                            resolve(scene);
                        });
                        const game = new Phaser.Game({
                            type: Phaser.CANVAS,
                            width: 1,
                            height: 1,
                            audio: {
                                noAudio: true,
                            },
                            scene: scene,
                        });
                    });
                    return promise;
                }
                setCallback(callback) {
                    this._callback = callback;
                }
                async create() {
                    this.registerDestroyListener("OfflineScene");
                    const maker = this.getMaker();
                    await maker.preload();
                    await maker.updateSceneLoader(this._data);
                    maker.createScene(this._data);
                    this._callback();
                }
            }
            ui.OfflineScene = OfflineScene;
        })(ui = scene_10.ui || (scene_10.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var io = colibri.core.io;
            class SceneFileSection extends controls.properties.PropertySection {
                constructor(page) {
                    super(page, "phasereditor2d.scene.ui.SceneFileSection", "Scene", true, false);
                }
                createForm(parent) {
                    const imgControl = new controls.ImageControl();
                    this.getPage().eventControlLayout.addListener(() => {
                        imgControl.resizeTo();
                    });
                    parent.appendChild(imgControl.getElement());
                    this.addUpdater(async () => {
                        const file = this.getSelectionFirstElement();
                        const cache = ui.SceneThumbnailCache.getInstance();
                        await cache.preload(file);
                        const image = ui.SceneThumbnailCache.getInstance().getContent(file);
                        imgControl.setImage(image);
                        setTimeout(() => imgControl.resizeTo(), 1);
                    });
                }
                canEdit(obj, n) {
                    return obj instanceof io.FilePath
                        && colibri.Platform.getWorkbench().getContentTypeRegistry()
                            .getCachedContentType(obj) === scene.core.CONTENT_TYPE_SCENE;
                }
                canEditNumber(n) {
                    return n === 1;
                }
            }
            ui.SceneFileSection = SceneFileSection;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseSceneMaker.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_11) {
        var ui;
        (function (ui) {
            var json = scene_11.core.json;
            var FileUtils = colibri.ui.ide.FileUtils;
            class SceneMaker extends ui.BaseSceneMaker {
                constructor(scene) {
                    super(scene);
                    this._editorScene = scene;
                }
                afterDropObjects(prefabObj, sprites) {
                    let container;
                    let layer;
                    for (const sprite of this._editorScene.getEditor().getSelectedGameObjects()) {
                        let sprite2 = sprite;
                        if (sprite2.getEditorSupport().isPrefabInstance()) {
                            sprite2 = ui.sceneobjects.getObjectParent(sprite2.getEditorSupport().getOwnerPrefabInstance());
                        }
                        if (sprite2) {
                            if (sprite2 instanceof ui.sceneobjects.Container) {
                                container = sprite2;
                            }
                            else if (sprite2.parentContainer) {
                                container = sprite2.parentContainer;
                            }
                            else if (sprite2 instanceof ui.sceneobjects.Layer) {
                                layer = sprite2;
                            }
                            else if (sprite2.displayList instanceof ui.sceneobjects.Layer) {
                                layer = sprite2.displayList;
                            }
                        }
                    }
                    if (container) {
                        for (const obj of sprites) {
                            if (obj instanceof ui.sceneobjects.Layer) {
                                continue;
                            }
                            const sprite = obj;
                            const p = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                            this._editorScene.sys.displayList.remove(sprite);
                            container.add(sprite);
                            container.getWorldTransformMatrix().applyInverse(p.x, p.y, p);
                            sprite.x = p.x;
                            sprite.y = p.y;
                        }
                    }
                    else if (layer) {
                        for (const obj of sprites) {
                            layer.add(obj);
                        }
                    }
                    else {
                        this.afterDropObjectsInPrefabScene(prefabObj, sprites);
                    }
                }
                afterDropObjectsInPrefabScene(prefabObj, sprites) {
                    if (!prefabObj) {
                        return;
                    }
                    const scene = prefabObj.getEditorSupport().getScene();
                    if (!scene.isPrefabSceneType()) {
                        return;
                    }
                    let parent;
                    if (scene.isPrefabSceneType()) {
                        if (sprites.length > 0) {
                            if (!prefabObj.getEditorSupport().isPrefabInstance()
                                && (prefabObj instanceof ui.sceneobjects.Container || prefabObj instanceof ui.sceneobjects.Layer)) {
                                parent = prefabObj;
                            }
                            else {
                                [parent] = ui.sceneobjects.ContainerExtension.getInstance().createDefaultSceneObject({
                                    scene: scene,
                                    x: 0,
                                    y: 0
                                });
                                parent.getEditorSupport().setLabel(scene.makeNewName("container"));
                                scene.sys.displayList.remove(prefabObj);
                                parent.add(prefabObj);
                            }
                            if (parent) {
                                for (const sprite of sprites) {
                                    if (parent instanceof ui.sceneobjects.Container) {
                                        if (sprite.getEditorSupport().hasComponent(ui.sceneobjects.TransformComponent)) {
                                            sprite.x -= parent.x;
                                            sprite.y -= parent.y;
                                        }
                                    }
                                    scene.sys.displayList.remove(sprite);
                                    parent.add(sprite);
                                }
                                if (parent !== prefabObj && parent instanceof ui.sceneobjects.Container) {
                                    parent.getEditorSupport().trim();
                                }
                            }
                        }
                    }
                }
                static acceptDropFile(dropFile, editorFile) {
                    if (dropFile.getFullName() === editorFile.getFullName()) {
                        return false;
                    }
                    const sceneFinder = scene_11.ScenePlugin.getInstance().getSceneFinder();
                    const sceneData = sceneFinder.getSceneData(dropFile);
                    if (sceneData) {
                        if (sceneData.sceneType !== scene_11.core.json.SceneType.PREFAB) {
                            return false;
                        }
                        if (sceneData.displayList.length === 0) {
                            return false;
                        }
                        const objData = sceneData.displayList[sceneData.displayList.length - 1];
                        if (objData.prefabId) {
                            const prefabFile = sceneFinder.getPrefabFile(objData.prefabId);
                            if (prefabFile) {
                                return this.acceptDropFile(prefabFile, editorFile);
                            }
                        }
                        return true;
                    }
                    return false;
                }
                static isValidSceneDataFormat(data) {
                    return "displayList" in data && Array.isArray(data.displayList);
                }
                async buildDependenciesHash() {
                    const builder = new phasereditor2d.ide.core.MultiHashBuilder();
                    for (const obj of this._editorScene.getDisplayListChildren()) {
                        await obj.getEditorSupport().buildDependencyHash({ builder });
                    }
                    this._editorScene.getPackCache().buildAssetsDependenciesHash(builder);
                    const hash = builder.build();
                    return hash;
                }
                isPrefabFile(file) {
                    const ct = colibri.Platform.getWorkbench().getContentTypeRegistry().getCachedContentType(file);
                    if (ct === scene_11.core.CONTENT_TYPE_SCENE) {
                        const finder = scene_11.ScenePlugin.getInstance().getSceneFinder();
                        const data = finder.getSceneData(file);
                        return data && data.sceneType === json.SceneType.PREFAB;
                    }
                    return false;
                }
                async createPrefabInstanceWithFile(file) {
                    const content = await FileUtils.preloadAndGetFileString(file);
                    if (!content) {
                        return null;
                    }
                    try {
                        const prefabData = JSON.parse(content);
                        const obj = this.createObject({
                            id: Phaser.Utils.String.UUID(),
                            prefabId: prefabData.id,
                            label: "temporal"
                        });
                        if (obj.getEditorSupport().isUnlockedProperty(ui.sceneobjects.TransformComponent.x)) {
                            const { x, y } = this.getCanvasCenterPoint();
                            const sprite = obj;
                            sprite.x = x;
                            sprite.y = y;
                        }
                        return obj;
                    }
                    catch (e) {
                        console.error(e);
                        return null;
                    }
                }
                getSerializer(data) {
                    return new json.Serializer(data);
                }
                createScene(sceneData, errors) {
                    const version = sceneData.meta.version ?? 1;
                    this._editorScene.setVersion(version);
                    if (version === 1) {
                        // old version, perform unlock x & y migration
                        new json.Version1ToVersion2Migration().migrate(sceneData);
                    }
                    if (sceneData.settings) {
                        this._editorScene.getSettings().readJSON(sceneData.settings);
                    }
                    if (sceneData.lists) {
                        this._editorScene.getObjectLists().readJSON(sceneData);
                    }
                    if (sceneData.plainObjects) {
                        this._editorScene.readPlainObjects(sceneData.plainObjects);
                    }
                    if (sceneData.prefabProperties) {
                        this._editorScene.getPrefabUserProperties().readJSON(sceneData.prefabProperties);
                    }
                    this._editorScene.setSceneType(sceneData.sceneType || scene_11.core.json.SceneType.SCENE);
                    // removes this condition, it is used temporal for compatibility
                    this._editorScene.setId(sceneData.id);
                    for (const objData of sceneData.displayList) {
                        this.createObject(objData, errors);
                    }
                }
                async updateSceneLoader(sceneData, monitor) {
                    const finder = new phasereditor2d.pack.core.PackFinder();
                    await finder.preload();
                    await this.updateSceneLoaderWithGameObjectDataList(finder, sceneData.displayList, monitor);
                    await this.updateSceneLoaderWithPlainObjDataList(finder, sceneData.plainObjects, monitor);
                }
                async updateSceneLoaderWithPlainObjDataList(finder, list, monitor) {
                    if (!list) {
                        return;
                    }
                    const assets = [];
                    for (const data of list) {
                        try {
                            const type = data.type;
                            const ext = scene_11.ScenePlugin.getInstance().getPlainObjectExtensionByObjectType(type);
                            if (ext) {
                                const result = await ext.getAssetsFromObjectData({
                                    scene: this._editorScene,
                                    finder,
                                    data
                                });
                                assets.push(...result);
                            }
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                    await this.updateSceneLoaderWithAssets(assets, monitor);
                }
                async updateSceneLoaderWithGameObjectDataList(finder, list, monitor) {
                    const assets = [];
                    for (const objData of list) {
                        try {
                            const ser = this.getSerializer(objData);
                            const type = ser.getType();
                            const ext = scene_11.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            if (ext) {
                                const objAssets = await ext.getAssetsFromObjectData({
                                    serializer: ser,
                                    finder: finder,
                                    scene: this._editorScene
                                });
                                assets.push(...objAssets);
                            }
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                    await this.updateSceneLoaderWithAssets(assets, monitor);
                }
                async updateSceneLoaderWithAssets(assets, monitor) {
                    if (monitor) {
                        monitor.addTotal(assets.length);
                    }
                    for (const asset of assets) {
                        const updater = scene_11.ScenePlugin.getInstance().getLoaderUpdaterForAsset(asset);
                        if (updater) {
                            await updater.updateLoader(this._editorScene, asset);
                            if (monitor) {
                                monitor.step();
                            }
                        }
                    }
                }
                getCanvasCenterPoint() {
                    const canvas = this._editorScene.game.canvas;
                    let x = canvas.width / 2;
                    let y = canvas.height / 2;
                    const worldPoint = this._editorScene.getCamera().getWorldPoint(x, y);
                    x = Math.floor(worldPoint.x);
                    y = Math.floor(worldPoint.y);
                    return { x, y };
                }
                createDefaultObject(ext, extraData, x, y) {
                    if (x === undefined) {
                        const point = this.getCanvasCenterPoint();
                        x = point.x;
                        y = point.y;
                    }
                    const newObjects = ext.createDefaultSceneObject({
                        scene: this._editorScene,
                        x,
                        y,
                        extraData
                    });
                    const nameMaker = this._editorScene.createNameMaker();
                    for (const newObject of newObjects) {
                        const oldLabel = newObject.getEditorSupport().getLabel();
                        const newLabel = nameMaker.makeName(oldLabel);
                        newObject.getEditorSupport().setLabel(newLabel);
                    }
                    return newObjects;
                }
                createObject(data, errors, parent) {
                    try {
                        const ser = this.getSerializer(data);
                        const type = ser.getType();
                        const ext = scene_11.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                        if (ext) {
                            const sprite = ext.createGameObjectWithData({
                                data: data,
                                scene: this._editorScene
                            });
                            return sprite;
                        }
                        else {
                            const msg = `SceneMaker: no extension is registered for type "${type}".`;
                            if (errors) {
                                errors.push(msg);
                            }
                            console.error(msg);
                        }
                        return null;
                    }
                    catch (e) {
                        const msg = e.message;
                        if (errors) {
                            errors.push(msg);
                        }
                        console.error(e);
                        return null;
                    }
                }
            }
            ui.SceneMaker = SceneMaker;
        })(ui = scene_11.ui || (scene_11.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_12) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var ide = colibri.ui.ide;
            class ThumbnailScene extends ui.Scene {
                constructor(data, callback) {
                    super();
                    if (data.sceneType === scene_12.core.json.SceneType.PREFAB) {
                        if (data.displayList.length > 1) {
                            data.displayList.splice(0, data.displayList.length - 1);
                        }
                    }
                    this._data = data;
                    this._callback = callback;
                }
                async create() {
                    this.registerDestroyListener("ThumbnailScene");
                    const maker = this.getMaker();
                    await maker.preload();
                    await maker.updateSceneLoader(this._data);
                    maker.createScene(this._data);
                    const children = this.getDisplayListChildren();
                    let singleObject;
                    const s = this.getSettings();
                    if (this.isPrefabSceneType()) {
                        singleObject = this.getPrefabObject();
                    }
                    else if (children.length === 1) {
                        singleObject = children[0];
                    }
                    if (singleObject) {
                        if (singleObject.getEditorSupport().hasComponent(ui.sceneobjects.OriginComponent)) {
                            const sprite = singleObject;
                            sprite.setOrigin(0.5, 0.5);
                            sprite.setPosition(s.borderX + s.borderWidth / 2, s.borderY + s.borderHeight / 2);
                        }
                        else if (singleObject instanceof ui.sceneobjects.Container) {
                            const container = singleObject;
                            this.breakContainers([container]);
                        }
                    }
                    else {
                        this.breakContainers(children);
                    }
                    let bounds = this.computeSceneBounds();
                    if (bounds.width > s.borderWidth || bounds.height > s.borderHeight) {
                        bounds = {
                            x: s.borderX,
                            y: s.borderY,
                            width: s.borderWidth,
                            height: s.borderHeight
                        };
                    }
                    else {
                        for (const child of children) {
                            const obj = child;
                            if ("x" in obj) {
                                if (bounds.x < 0) {
                                    obj.x += Math.abs(bounds.x);
                                }
                                if (bounds.y < 0) {
                                    obj.y += Math.abs(bounds.y);
                                }
                            }
                        }
                        if (bounds.x < 0) {
                            bounds.x = 0;
                        }
                        if (bounds.y < 0) {
                            bounds.y = 0;
                        }
                        if (bounds.width < 0) {
                            bounds.width = 800;
                        }
                        if (bounds.height < 0) {
                            bounds.height = 600;
                        }
                    }
                    this.sys.renderer.snapshotArea(bounds.x, bounds.y, bounds.width, bounds.height, (img) => {
                        this._callback(img);
                        this.destroyGame();
                    });
                }
                breakContainers(list) {
                    for (const obj of list) {
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            if (!obj.visible || obj.alpha === 0) {
                                obj.destroy();
                                continue;
                            }
                        }
                        if (obj instanceof ui.sceneobjects.Container) {
                            ui.sceneobjects.BreakParentOperation.breakParent(this, [obj]);
                            this.breakContainers(obj.list);
                        }
                    }
                }
                computeSceneBounds() {
                    const children = this.getDisplayListChildren();
                    if (children.length === 0) {
                        return { x: 0, y: 0, width: 10, height: 10 };
                    }
                    const camera = this.getCamera();
                    let minX = Number.MAX_SAFE_INTEGER;
                    let minY = Number.MAX_SAFE_INTEGER;
                    let maxX = Number.MIN_SAFE_INTEGER;
                    let maxY = Number.MIN_SAFE_INTEGER;
                    for (const obj of this.getDisplayListChildren()) {
                        const points = obj.getEditorSupport().getScreenBounds(camera);
                        for (const point of points) {
                            minX = Math.min(minX, point.x);
                            minY = Math.min(minY, point.y);
                            maxX = Math.max(maxX, point.x);
                            maxY = Math.max(maxY, point.y);
                        }
                    }
                    return {
                        x: Math.floor(minX),
                        y: Math.floor(minY),
                        width: Math.floor(maxX - minX),
                        height: Math.floor(maxY - minY)
                    };
                }
            }
            class SceneThumbnail {
                constructor(file) {
                    this._file = file;
                    this._image = null;
                }
                paint(context, x, y, w, h, center) {
                    if (this._image) {
                        this._image.paint(context, x, y, w, h, center);
                    }
                }
                paintFrame(context, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH) {
                    if (this._image) {
                        this._image.paintFrame(context, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
                    }
                }
                getWidth() {
                    return this._image ? this._image.getWidth() : 16;
                }
                getHeight() {
                    return this._image ? this._image.getHeight() : 16;
                }
                preloadSize() {
                    return this.preload();
                }
                async preload() {
                    if (this._image == null) {
                        if (this._promise) {
                            return this._promise;
                        }
                        this._promise = ide.FileUtils.preloadFileString(this._file)
                            .then(() => this.createImageElement())
                            .then(imageElement => {
                            this._image = new controls.ImageWrapper(imageElement);
                            this._promise = null;
                            return controls.PreloadResult.RESOURCES_LOADED;
                        });
                        return this._promise;
                    }
                    return controls.Controls.resolveNothingLoaded();
                }
                getImageElement() {
                    if (this._image) {
                        return this._image.getImageElement();
                    }
                    return null;
                }
                createImageElement() {
                    return new Promise((resolve, reject) => {
                        const content = ide.FileUtils.getFileString(this._file);
                        const data = JSON.parse(content);
                        // const width = data.settings.borderWidth || 800;
                        // const height = data.settings.borderHeight || 600;
                        const width = 1920;
                        const height = 1080;
                        let canvas;
                        if (SceneThumbnail._canvas) {
                            canvas = SceneThumbnail._canvas;
                        }
                        else {
                            canvas = document.createElement("canvas");
                            canvas.style.width = (canvas.width = width) + "px";
                            canvas.style.height = (canvas.height = height) + "px";
                            SceneThumbnail._canvas = canvas;
                            const parent = document.createElement("div");
                            parent.style.position = "fixed";
                            parent.style.left = -width - 10 + "px";
                            parent.appendChild(canvas);
                            document.body.appendChild(parent);
                        }
                        const game = new Phaser.Game({
                            type: scene_12.ScenePlugin.DEFAULT_CANVAS_CONTEXT,
                            canvas: canvas,
                            parent: null,
                            width: width,
                            height: height,
                            scale: {
                                mode: Phaser.Scale.NONE
                            },
                            render: {
                                pixelArt: true,
                                transparent: true
                            },
                            audio: {
                                noAudio: true
                            }
                        });
                        const scene = new ThumbnailScene(data, image => {
                            resolve(image);
                            scene.destroyGame();
                        });
                        game.scene.add("scene", scene, true);
                    });
                }
            }
            ui.SceneThumbnail = SceneThumbnail;
        })(ui = scene_12.ui || (scene_12.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var core = colibri.core;
            const localForage = window["localforage"];
            class SceneThumbnailCache extends core.io.FileContentCache {
                constructor() {
                    super(async (file, force) => {
                        const db = SceneThumbnailCache._database;
                        const imageKey = file.getFullName() + "@image";
                        const modTimeKey = file.getFullName() + "@modTime";
                        const currentFileTime = file.getModTime();
                        if (!force) {
                            try {
                                const blob = await db.getItem(imageKey);
                                const savedFileTime = await db.getItem(modTimeKey);
                                if (blob) {
                                    if (currentFileTime === savedFileTime) {
                                        const imgElement = createImageFromBlob(blob);
                                        await new Promise((resolver, reject) => {
                                            imgElement.addEventListener("load", () => resolver(undefined));
                                        });
                                        return new controls.ImageWrapper(imgElement);
                                    }
                                }
                            }
                            catch (error) {
                                console.log(error);
                            }
                        }
                        const image = new ui.SceneThumbnail(file);
                        await image.preload();
                        const element = image.getImageElement();
                        if (element) {
                            const newBlob = await createBlobFromImage(element);
                            db.setItem(imageKey, newBlob);
                            db.setItem(modTimeKey, currentFileTime);
                        }
                        return Promise.resolve(image);
                    });
                }
                static getInstance() {
                    if (!this._instance) {
                        this._database = localForage.createInstance({
                            name: "phasereditor2d.scene.ui.SceneThumbnailCache",
                            driver: localForage.INDEXEDDB
                        });
                        this._instance = new SceneThumbnailCache();
                    }
                    return this._instance;
                }
                static async clearCache() {
                    SceneThumbnailCache.getInstance();
                    await this._database.clear();
                }
            }
            ui.SceneThumbnailCache = SceneThumbnailCache;
            async function createBlobFromImage(img) {
                return new Promise((resolve, reject) => {
                    let canvas;
                    if (img instanceof HTMLCanvasElement) {
                        canvas = img;
                    }
                    else {
                        canvas = document.createElement("canvas");
                        canvas.width = img.width;
                        canvas.height = img.height;
                        canvas.style.width = img.width + "px";
                        canvas.style.height = img.height + "px";
                        const ctx = canvas.getContext("2d");
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                    }
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png');
                });
            }
            function createImageFromBlob(blob) {
                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                return img;
            }
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var controls = colibri.ui.controls;
                class SceneEditorBlocksCellRendererProvider extends phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider {
                    constructor() {
                        super("grid");
                    }
                    getCellRenderer(element) {
                        if (scene.SCENE_OBJECT_CATEGORY_SET.has(element)) {
                            return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                        if (element instanceof colibri.core.io.FilePath && scene.ScenePlugin.getInstance().isSceneContentType(element)) {
                            return new ui.viewers.SceneFileCellRenderer();
                        }
                        else if (element instanceof ui.sceneobjects.SceneObjectExtension) {
                            return new ui.viewers.ObjectExtensionCellRendererProvider().getCellRenderer(element);
                        }
                        else if (element === ui.sceneobjects.ObjectList) {
                            return new controls.viewers.IconImageCellRenderer(scene.ScenePlugin.getInstance().getIcon(scene.ICON_LIST));
                        }
                        else if (typeof (element) === "string" && blocks.BLOCKS_SECTIONS.indexOf(element) >= 0) {
                            return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                        return super.getCellRenderer(element);
                    }
                }
                blocks.SceneEditorBlocksCellRendererProvider = SceneEditorBlocksCellRendererProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var io = colibri.core.io;
                const SCENE_EDITOR_BLOCKS_PACK_ITEM_TYPES = new Set([
                    phasereditor2d.pack.core.IMAGE_TYPE,
                    phasereditor2d.pack.core.SVG_TYPE,
                    phasereditor2d.pack.core.ATLAS_TYPE,
                    phasereditor2d.pack.core.ATLAS_XML_TYPE,
                    phasereditor2d.pack.core.MULTI_ATLAS_TYPE,
                    phasereditor2d.pack.core.UNITY_ATLAS_TYPE,
                    phasereditor2d.pack.core.SPRITESHEET_TYPE,
                    phasereditor2d.pack.core.BITMAP_FONT_TYPE
                ]);
                const grouping = phasereditor2d.pack.ui.viewers.AssetPackGrouping;
                class SceneEditorBlocksContentProvider extends phasereditor2d.pack.ui.viewers.AssetPackContentProvider {
                    constructor(editor, getPacks) {
                        super();
                        this._blocksProvider = editor.getBlocksProvider();
                        this._getPacks = getPacks;
                        this._editor = this._blocksProvider.getEditor();
                    }
                    getPackItems() {
                        return this._getPacks()
                            .flatMap(pack => pack.getItems())
                            .filter(item => SCENE_EDITOR_BLOCKS_PACK_ITEM_TYPES.has(item.getType()));
                    }
                    getRoots(input) {
                        const groupingType = grouping.getGroupingPreference();
                        const section = this._blocksProvider.getSelectedTabSection();
                        switch (section) {
                            case blocks.TAB_SECTION_BUILT_IN:
                                return scene.SCENE_OBJECT_CATEGORIES;
                            case blocks.TAB_SECTION_PREFABS:
                                if (groupingType === grouping.GROUP_ASSETS_BY_LOCATION) {
                                    return colibri.ui.ide.FileUtils.distinct(this.getSceneFiles("prefabs").map(f => f.getParent()));
                                }
                                return ui.viewers.PhaserTypeSymbol.getSymbols();
                        }
                        switch (groupingType) {
                            case grouping.GROUP_ASSETS_BY_TYPE:
                                if (section === blocks.TAB_SECTION_ASSETS) {
                                    return blocks.BLOCKS_ASSET_SECTIONS;
                                }
                                return blocks.BLOCKS_SECTIONS;
                            case grouping.GROUP_ASSETS_BY_PACK:
                                if (section === blocks.TAB_SECTION_ASSETS) {
                                    return this._getPacks();
                                }
                                return [
                                    blocks.BUILTIN_SECTION,
                                    blocks.PREFAB_SECTION,
                                    ...this._getPacks()
                                ];
                            case grouping.GROUP_ASSETS_BY_LOCATION:
                                const packFolders = grouping.getAssetsFolders(this._getPacks());
                                if (section === blocks.TAB_SECTION_ASSETS) {
                                    return packFolders;
                                }
                                return [
                                    blocks.BUILTIN_SECTION,
                                    ...colibri.ui.ide.FileUtils.distinct([
                                        ...this.getSceneFiles().map(f => f.getParent()),
                                        ...packFolders
                                    ])
                                ];
                        }
                        return [];
                    }
                    getSceneFiles(sceneType = "all") {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const files = (sceneType === "prefabs" ? finder.getPrefabFiles() : finder.getSceneFiles());
                        return files.filter(file => ui.SceneMaker.acceptDropFile(file, this._editor.getInput()));
                    }
                    getChildren(parent) {
                        if (parent instanceof ui.viewers.PhaserTypeSymbol) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            return this.getSceneFiles().filter(file => finder.getScenePhaserType(file) === parent.getPhaserType());
                        }
                        if (parent instanceof phasereditor2d.pack.core.AssetPack) {
                            return parent.getItems().filter(i => SCENE_EDITOR_BLOCKS_PACK_ITEM_TYPES.has(i.getType()));
                        }
                        if (typeof (parent) === "string") {
                            if (scene.SCENE_OBJECT_CATEGORY_SET.has(parent)) {
                                const isPrefabScene = this._editor.getScene() && this._editor.getScene().isPrefabSceneType();
                                const exts = [
                                    ...scene.ScenePlugin.getInstance().getGameObjectExtensions(),
                                    ...scene.ScenePlugin.getInstance().getPlainObjectExtensions()
                                ]
                                    .filter(ext => !isPrefabScene || ext.isAvailableAsPrefabElement())
                                    .filter(ext => ext.getCategory() === parent);
                                return [
                                    ...exts,
                                    ...(parent === scene.SCENE_OBJECT_GROUPING_CATEGORY ? [ui.sceneobjects.ObjectList] : [])
                                ];
                            }
                            switch (parent) {
                                case phasereditor2d.pack.core.ATLAS_TYPE:
                                    return this.getPackItems()
                                        .filter(item => item instanceof phasereditor2d.pack.core.BaseAtlasAssetPackItem);
                                case phasereditor2d.pack.core.BITMAP_FONT_TYPE:
                                    return this.getPackItems()
                                        .filter(item => item instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem);
                                case blocks.BUILTIN_SECTION:
                                    return scene.SCENE_OBJECT_CATEGORIES;
                                case blocks.PREFAB_SECTION:
                                    const files = this.getSceneFiles();
                                    return files;
                            }
                            return this.getPackItems()
                                .filter(item => item.getType() === parent);
                        }
                        if (parent instanceof io.FilePath && parent.isFolder()) {
                            const tabSection = this._editor.getBlocksProvider().getSelectedTabSection();
                            if (tabSection === blocks.TAB_SECTION_PREFABS) {
                                return this.getSceneFiles("prefabs").filter(f => f.getParent() === parent);
                            }
                            const scenes = this.getSceneFiles().filter(f => f.getParent() === parent);
                            const items = this.getPackItems().filter(item => grouping.getItemFolder(item) === parent);
                            return [...scenes, ...items];
                        }
                        return super.getChildren(parent);
                    }
                }
                blocks.SceneEditorBlocksContentProvider = SceneEditorBlocksContentProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var core = colibri.core;
                class SceneEditorBlocksLabelProvider extends phasereditor2d.pack.ui.viewers.AssetPackLabelProvider {
                    getLabel(obj) {
                        if (obj instanceof core.io.FilePath && !obj.isFolder()) {
                            return obj.getNameWithoutExtension();
                        }
                        else if (obj instanceof ui.sceneobjects.SceneObjectExtension) {
                            return obj.getTypeName();
                        }
                        else if (obj === ui.sceneobjects.ObjectList) {
                            return "List";
                        }
                        else if (obj instanceof ui.viewers.PhaserTypeSymbol) {
                            return obj.getDisplayName();
                        }
                        return super.getLabel(obj);
                    }
                }
                blocks.SceneEditorBlocksLabelProvider = SceneEditorBlocksLabelProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                class SceneEditorBlocksPropertyProvider extends phasereditor2d.pack.ui.properties.AssetPackPreviewPropertyProvider {
                    addSections(page, sections) {
                        super.addSections(page, sections);
                        sections.push(new ui.sceneobjects.ObjectTypeDocSection(page));
                        sections.push(new ui.sceneobjects.ObjectListDocSection(page));
                    }
                }
                blocks.SceneEditorBlocksPropertyProvider = SceneEditorBlocksPropertyProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var ide = colibri.ui.ide;
                blocks.TAB_SECTION_BUILT_IN = "Built-In";
                blocks.TAB_SECTION_PREFABS = "Prefabs";
                blocks.TAB_SECTION_ASSETS = "Assets";
                blocks.TAB_SECTIONS = [
                    blocks.TAB_SECTION_BUILT_IN,
                    blocks.TAB_SECTION_PREFABS,
                    blocks.TAB_SECTION_ASSETS,
                ];
                class SceneEditorBlocksProvider extends ide.EditorViewerProvider {
                    constructor(editor) {
                        super();
                        this._editor = editor;
                        this._packs = [];
                    }
                    getEditor() {
                        return this._editor;
                    }
                    allowsTabSections() {
                        return true;
                    }
                    getTabSections() {
                        return blocks.TAB_SECTIONS;
                    }
                    fillContextMenu(menu) {
                        phasereditor2d.pack.ui.viewers.AssetPackGrouping.fillMenu(menu, () => this.repaint(true));
                    }
                    async preload(complete) {
                        let finder;
                        if (this._editor.getScene() && !complete) {
                            finder = this._editor.getSceneMaker().getPackFinder();
                        }
                        else {
                            finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                        }
                        this._packs = finder.getPacks();
                    }
                    prepareViewerState(state) {
                        if (state.expandedObjects) {
                            state.expandedObjects = this.getFreshItems(state.expandedObjects);
                        }
                        if (state.selectedObjects) {
                            state.selectedObjects = this.getFreshItems(state.selectedObjects);
                        }
                    }
                    getFreshItems(items) {
                        const set = new Set();
                        for (const obj of items) {
                            if (obj instanceof phasereditor2d.pack.core.AssetPack) {
                                const pack = this._packs.find(p => p.getFile() === obj.getFile());
                                if (pack) {
                                    set.add(pack);
                                }
                            }
                            else if (obj instanceof phasereditor2d.pack.core.AssetPackItem) {
                                const item = this.getFreshItem(obj);
                                if (item) {
                                    set.add(item);
                                }
                            }
                            else if (obj instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                                const item = this.getFreshItem(obj.getPackItem());
                                if (item instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                                    const frame = item.findFrame(obj.getName());
                                    if (frame) {
                                        set.add(frame);
                                    }
                                }
                            }
                            else {
                                set.add(obj);
                            }
                        }
                        return set;
                    }
                    getFreshItem(item) {
                        const freshPack = this._packs.find(pack => pack.getFile() === item.getPack().getFile());
                        const finder = new phasereditor2d.pack.core.PackFinder(freshPack);
                        return finder.findAssetPackItem(item.getKey());
                    }
                    getContentProvider() {
                        return new blocks.SceneEditorBlocksContentProvider(this._editor, () => this._packs);
                    }
                    getLabelProvider() {
                        return new blocks.SceneEditorBlocksLabelProvider();
                    }
                    getCellRendererProvider() {
                        return new blocks.SceneEditorBlocksCellRendererProvider();
                    }
                    getTreeViewerRenderer(viewer) {
                        // TODO: we should implements the Favorites section
                        return new blocks.SceneEditorBlocksTreeRendererProvider(this, viewer);
                    }
                    getUndoManager() {
                        return this._editor.getUndoManager();
                    }
                    getPropertySectionProvider() {
                        return new blocks.SceneEditorBlocksPropertyProvider();
                    }
                    getInput() {
                        return this;
                    }
                }
                blocks.SceneEditorBlocksProvider = SceneEditorBlocksProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var io = colibri.core.io;
                blocks.BUILTIN_SECTION = "Built-In";
                blocks.PREFAB_SECTION = "Prefab";
                blocks.BLOCKS_ASSET_SECTIONS = [
                    phasereditor2d.pack.core.IMAGE_TYPE,
                    phasereditor2d.pack.core.SVG_TYPE,
                    phasereditor2d.pack.core.ATLAS_TYPE,
                    phasereditor2d.pack.core.SPRITESHEET_TYPE,
                    phasereditor2d.pack.core.BITMAP_FONT_TYPE
                ];
                blocks.BLOCKS_SECTIONS = [
                    blocks.BUILTIN_SECTION,
                    blocks.PREFAB_SECTION,
                    ...blocks.BLOCKS_ASSET_SECTIONS
                ];
                class SceneEditorBlocksTreeRendererProvider extends phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer {
                    constructor(provider, viewer) {
                        super(viewer, false);
                        this._blocksProvider = provider;
                    }
                    isObjectSection(obj) {
                        if (typeof obj === "string") {
                            if (this._blocksProvider.getSelectedTabSection() === blocks.TAB_SECTION_BUILT_IN
                                && scene.SCENE_OBJECT_CATEGORIES.indexOf(obj) >= 0) {
                                return true;
                            }
                            if (blocks.BLOCKS_SECTIONS.indexOf(obj) >= 0) {
                                return true;
                            }
                        }
                        return obj instanceof phasereditor2d.pack.core.AssetPack
                            || obj instanceof io.FilePath && obj.isFolder() || obj instanceof ui.viewers.PhaserTypeSymbol;
                    }
                    isShadowAsChild(obj) {
                        if (this._blocksProvider.getSelectedTabSection() === blocks.TAB_SECTION_BUILT_IN) {
                            return false;
                        }
                        if (obj instanceof ui.sceneobjects.SceneObjectExtension || obj === ui.sceneobjects.ObjectList) {
                            return true;
                        }
                        return super.isShadowAsChild(obj);
                    }
                    isSectionSorted(section) {
                        if (section === blocks.BUILTIN_SECTION) {
                            return false;
                        }
                        return true;
                    }
                }
                blocks.SceneEditorBlocksTreeRendererProvider = SceneEditorBlocksTreeRendererProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                var controls = colibri.ui.controls;
                class AddObjectDialog extends controls.dialogs.ViewerDialog {
                    constructor(editor) {
                        super(AddObjectDialog.createViewer(editor), true);
                        this._editor = editor;
                    }
                    static createViewer(editor) {
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.dialogs.AddObjectDialog");
                        viewer.setContentProvider(new AddObjectContentProvider(editor));
                        viewer.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        viewer.setCellRendererProvider(new ui.blocks.SceneEditorBlocksCellRendererProvider());
                        viewer.setInput([]);
                        viewer.expandRoots(true);
                        return viewer;
                    }
                    create() {
                        super.create();
                        this.setTitle("Add Object");
                        const addButton = this.addButton("Add Object", () => {
                            const obj = this.getViewer().getSelectionFirstElement();
                            this._editor.getDropManager().dropDataAtCenter([obj]);
                            this.close();
                        });
                        const filter = obj => scene.SCENE_OBJECT_CATEGORIES.indexOf(obj) < 0;
                        this.enableButtonOnlyWhenOneElementIsSelected(addButton, filter);
                        this.getViewer().setExpandWhenOpenParentItem();
                        this.getViewer().eventOpenItem.addListener(obj => {
                            if (filter(obj)) {
                                addButton.click();
                            }
                        });
                        this.addCancelButton();
                    }
                }
                dialogs.AddObjectDialog = AddObjectDialog;
                class AddObjectContentProvider extends ui.blocks.SceneEditorBlocksContentProvider {
                    constructor(editor) {
                        super(editor, () => []);
                    }
                    getRoots(input) {
                        return scene.SCENE_OBJECT_CATEGORIES;
                    }
                }
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewPrefabFileDialogExtension extends phasereditor2d.files.ui.dialogs.NewFileContentExtension {
                    getCreatePrefabFileContentFunc(displayList) {
                        return (args) => {
                            const settings = scene.ScenePlugin.getInstance().getDefaultSceneSettings();
                            const sceneData = {
                                id: Phaser.Utils.String.UUID(),
                                settings: {
                                    createMethodName: "",
                                    preloadMethodName: "",
                                    compilerOutputLanguage: settings.compilerOutputLanguage,
                                    exportClass: settings.exportClass,
                                    autoImport: settings.autoImport,
                                    generateAwakeHandler: false,
                                    compilerInsertSpaces: settings.compilerInsertSpaces,
                                    compilerTabSize: settings.compilerTabSize,
                                    borderWidth: settings.borderWidth,
                                    borderHeight: settings.borderHeight,
                                    borderX: settings.borderX,
                                    borderY: settings.borderY,
                                },
                                sceneType: scene.core.json.SceneType.PREFAB,
                                displayList,
                                meta: {
                                    app: "Phaser Editor 2D - Scene Editor",
                                    url: "https://phasereditor2d.com",
                                    contentType: scene.core.CONTENT_TYPE_SCENE
                                }
                            };
                            return JSON.stringify(sceneData, null, 4);
                        };
                    }
                    getCreateFileContentFunc() {
                        return this.getCreatePrefabFileContentFunc([]);
                    }
                    constructor() {
                        super({
                            dialogName: "Prefab File",
                            dialogIconDescriptor: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_GROUP),
                            fileExtension: "scene",
                            initialFileName: "Prefab"
                        });
                    }
                    getInitialFileLocation() {
                        return super.findInitialFileLocationBasedOnContentType(scene.core.CONTENT_TYPE_SCENE);
                    }
                }
                dialogs.NewPrefabFileDialogExtension = NewPrefabFileDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewPrefabFileFromObjectDialogExtension extends dialogs.NewPrefabFileDialogExtension {
                    constructor(objectData) {
                        super();
                        this._objectData = objectData;
                    }
                    getCreateFileContentFunc() {
                        return this.getCreatePrefabFileContentFunc([this._objectData]);
                    }
                }
                dialogs.NewPrefabFileFromObjectDialogExtension = NewPrefabFileFromObjectDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewSceneFileDialogExtension extends phasereditor2d.files.ui.dialogs.NewFileContentExtension {
                    constructor() {
                        super({
                            dialogName: "Scene File",
                            dialogIconDescriptor: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_GROUP),
                            fileExtension: "scene",
                            initialFileName: "Scene"
                        });
                    }
                    getCreateFileContentFunc() {
                        return (args) => {
                            let name = args.fileName;
                            const i = name.lastIndexOf(".");
                            if (i > 0) {
                                name = name.substring(0, i);
                            }
                            const settings = scene.ScenePlugin.getInstance().getDefaultSceneSettings();
                            const sceneData = {
                                id: Phaser.Utils.String.UUID(),
                                settings: {
                                    compilerOutputLanguage: settings.compilerOutputLanguage,
                                    javaScriptInitFieldsInConstructor: settings.javaScriptInitFieldsInConstructor,
                                    exportClass: settings.exportClass,
                                    autoImport: settings.autoImport,
                                    createMethodName: "editorCreate",
                                    compilerInsertSpaces: settings.compilerInsertSpaces,
                                    compilerTabSize: settings.compilerTabSize,
                                    borderWidth: settings.borderWidth,
                                    borderHeight: settings.borderHeight,
                                    borderX: settings.borderX,
                                    borderY: settings.borderY,
                                    sceneKey: name,
                                },
                                sceneType: scene.core.json.SceneType.SCENE,
                                displayList: [],
                                meta: {
                                    app: "Phaser Editor 2D - Scene Editor",
                                    url: "https://phasereditor2d.com",
                                    contentType: scene.core.CONTENT_TYPE_SCENE
                                }
                            };
                            return JSON.stringify(sceneData, null, 2);
                        };
                    }
                    getInitialFileLocation() {
                        return super.findInitialFileLocationBasedOnContentType(scene.core.CONTENT_TYPE_SCENE);
                    }
                }
                dialogs.NewSceneFileDialogExtension = NewSceneFileDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewUserComponentsFileDialogExtension extends phasereditor2d.files.ui.dialogs.NewFileContentExtension {
                    constructor() {
                        super({
                            dialogName: "User Components File",
                            dialogIconDescriptor: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_USER_COMPONENT),
                            fileExtension: "components",
                            initialFileName: "Behaviors"
                        });
                    }
                    getCreateFileContentFunc() {
                        return (args) => {
                            let name = args.fileName;
                            const i = name.lastIndexOf(".");
                            if (i > 0) {
                                name = name.substring(0, i);
                            }
                            const model = new ui.editor.usercomponent.UserComponentsModel();
                            const sceneSettings = scene.ScenePlugin.getInstance().getDefaultSceneSettings();
                            model.insertSpaces = sceneSettings.compilerInsertSpaces;
                            model.javaScriptInitFieldsInConstructor = sceneSettings.javaScriptInitFieldsInConstructor;
                            model.tabSize = sceneSettings.compilerTabSize;
                            model.outputLang = sceneSettings.compilerOutputLanguage;
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const models = [...finder.getUserComponentsModels()];
                            if (models.length > 0) {
                                models.sort((a, b) => a.file.getModTime() - b.file.getModTime());
                                const lastModel = models[models.length - 1];
                                model.outputLang = lastModel.model.outputLang;
                                model.tabSize = lastModel.model.tabSize;
                                model.insertSpaces = lastModel.model.insertSpaces;
                            }
                            const data = model.toJSON();
                            return JSON.stringify(data, null, 2);
                        };
                    }
                    getInitialFileLocation() {
                        return super.findInitialFileLocationBasedOnContentType(scene.core.CONTENT_TYPE_USER_COMPONENTS);
                    }
                }
                dialogs.NewUserComponentsFileDialogExtension = NewUserComponentsFileDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                var controls = colibri.ui.controls;
                var io = colibri.core.io;
                const grouping = phasereditor2d.pack.ui.viewers.AssetPackGrouping;
                class OpenSceneFileDialog extends controls.dialogs.ViewerDialog {
                    constructor() {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.dialogs.OpenSceneFileDialog"), true);
                        this.setSize(900, 500, true);
                    }
                    create() {
                        super.create();
                        this.setTitle("Go To Scene");
                        const viewer = this.getViewer();
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        viewer.setContentProvider(new ContentProvider(finder));
                        viewer.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        viewer.setCellRendererProvider(new ui.blocks.SceneEditorBlocksCellRendererProvider());
                        viewer.setTreeRenderer(new TreeRenderer(viewer));
                        viewer.setInput([]);
                        viewer.expandRoots();
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Open", () => {
                            colibri.Platform.getWorkbench().openEditor(viewer.getSelectionFirstElement());
                        }));
                        this.getFilteredViewer().setMenuProvider(new controls.viewers.DefaultViewerMenuProvider((viewer1, menu) => {
                            const currentType = getSceneGroupingPreference();
                            for (const type of [grouping.GROUP_ASSETS_BY_TYPE, grouping.GROUP_ASSETS_BY_LOCATION]) {
                                menu.addAction({
                                    text: "Group By " + grouping.GROUP_ASSET_TYPE_LABEL_MAP[type],
                                    selected: type === currentType,
                                    callback: () => {
                                        setSceneGroupingPreference(type);
                                        viewer.setScrollY(0);
                                        viewer.expandRoots();
                                    }
                                });
                            }
                        }));
                    }
                }
                dialogs.OpenSceneFileDialog = OpenSceneFileDialog;
                function getSceneGroupingPreference() {
                    return window.localStorage["phasereditor2d.scene.ui.dialogs.OpenSceneFileDialog.groupingType"] || grouping.GROUP_ASSETS_BY_TYPE;
                }
                function setSceneGroupingPreference(type) {
                    window.localStorage["phasereditor2d.scene.ui.dialogs.OpenSceneFileDialog.groupingType"] = type;
                }
                class TreeRenderer extends controls.viewers.GridTreeViewerRenderer {
                    constructor(viewer) {
                        super(viewer);
                        this.setPaintItemShadow(true);
                        this.setSectionCriteria(obj => typeof obj === "string"
                            || obj instanceof io.FilePath && obj.isFolder() || obj instanceof ui.viewers.PhaserTypeSymbol);
                    }
                }
                class ContentProvider {
                    constructor(finder) {
                        this.finder = finder;
                    }
                    getRoots(input) {
                        const type = getSceneGroupingPreference();
                        if (type === grouping.GROUP_ASSETS_BY_TYPE) {
                            return ui.viewers.PhaserTypeSymbol.getSymbols().filter(s => this.getChildren(s).length > 0);
                        }
                        return colibri.ui.ide.FileUtils.distinct(this.finder.getSceneFiles().map(f => f.getParent()));
                    }
                    getChildren(parent) {
                        if (parent instanceof ui.viewers.PhaserTypeSymbol) {
                            return this.finder.getSceneFiles()
                                .filter(file => this.finder.getScenePhaserType(file) === parent.getPhaserType());
                        }
                        if (parent instanceof io.FilePath && parent.isFolder()) {
                            return this.finder.getSceneFiles().filter(f => f.getParent() === parent);
                        }
                        return [];
                    }
                }
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var controls = colibri.ui.controls;
                class BaseOverlayLayer {
                    constructor() {
                        this._canvas = document.createElement("canvas");
                        this._canvas.style.position = "absolute";
                    }
                    setLoading(loading) {
                        this._loading = loading;
                    }
                    isLoading() {
                        return this._loading;
                    }
                    createLoadingMonitor() {
                        return new controls.CanvasProgressMonitor(this.getCanvas());
                    }
                    getCanvas() {
                        return this._canvas;
                    }
                    resetContext() {
                        this._ctx = this._canvas.getContext("2d");
                        controls.Controls.adjustCanvasDPI(this._canvas);
                        this._ctx.imageSmoothingEnabled = false;
                        this._ctx.font = "12px Monospace";
                    }
                    resizeTo() {
                        const parent = this._canvas.parentElement;
                        this._canvas.width = Math.floor(parent.clientWidth);
                        this._canvas.height = Math.floor(parent.clientHeight);
                        this._canvas.style.width = this._canvas.width + "px";
                        this._canvas.style.height = this._canvas.height + "px";
                        this.resetContext();
                    }
                    render() {
                        if (!this._ctx) {
                            this.resetContext();
                        }
                        if (!this._loading) {
                            const canvasWidth = this.getCanvas().width;
                            const canvasHeight = this.getCanvas().height;
                            this._ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                            this.renderLayer();
                        }
                    }
                    getContext() {
                        return this._ctx;
                    }
                }
                editor.BaseOverlayLayer = BaseOverlayLayer;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_13) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_1) {
                var controls = colibri.ui.controls;
                class CameraManager {
                    constructor(editor) {
                        this._editor = editor;
                        this._dragStartPoint = null;
                        const canvas = this._editor.getOverlayLayer().getCanvas();
                        canvas.addEventListener("wheel", e => this.onWheel(e));
                        canvas.addEventListener("mousedown", e => this.onMouseDown(e));
                        canvas.addEventListener("mousemove", e => this.onMouseMove(e));
                        canvas.addEventListener("mouseup", e => this.onMouseUp(e));
                        this._state = {
                            scrollX: 0,
                            scrollY: 0,
                            zoom: 1
                        };
                        const zoomIcon = new controls.ZoomControl({ showReset: true });
                        zoomIcon.setCallback(z => this.controlZoom(z * 100));
                        this._editor.getCanvasContainer().appendChild(zoomIcon.getElement());
                    }
                    getCamera() {
                        return this._editor.getScene().getCamera();
                    }
                    onMouseDown(e) {
                        if (e.button === 1 || e.button === 0 && e.altKey) {
                            const camera = this.getCamera();
                            this._dragStartPoint = new Phaser.Math.Vector2(e.offsetX, e.offsetY);
                            this._dragStartCameraScroll = new Phaser.Math.Vector2(camera.scrollX, camera.scrollY);
                            e.preventDefault();
                        }
                    }
                    onMouseMove(e) {
                        if (this._dragStartPoint === null) {
                            return;
                        }
                        const dx = this._dragStartPoint.x - e.offsetX;
                        const dy = this._dragStartPoint.y - e.offsetY;
                        const camera = this.getCamera();
                        camera.scrollX = this._dragStartCameraScroll.x + dx / camera.zoom;
                        camera.scrollY = this._dragStartCameraScroll.y + dy / camera.zoom;
                        this.updateState();
                        this._editor.repaint();
                        e.preventDefault();
                    }
                    updateState() {
                        const camera = this.getCamera();
                        this._state.scrollX = camera.scrollX;
                        this._state.scrollY = camera.scrollY;
                        this._state.zoom = camera.zoom;
                    }
                    onMouseUp(e) {
                        this._dragStartPoint = null;
                        this._dragStartCameraScroll = null;
                    }
                    onWheel(e) {
                        e.preventDefault();
                        this.zoom(e.deltaY, e.offsetX, e.offsetY);
                    }
                    zoom(deltaY, offsetX, offsetY) {
                        const scene = this._editor.getScene();
                        const camera = scene.getCamera();
                        const point1 = camera.getWorldPoint(offsetX, offsetY);
                        const scrollWidth = Math.abs(deltaY) * 2;
                        const screenWidth = this._editor.getElement().getBoundingClientRect().width;
                        const zoomDelta = scrollWidth / (screenWidth + scrollWidth);
                        const zoomFactor = (deltaY > 0 ? 1 - zoomDelta : 1 + zoomDelta);
                        camera.zoom = camera.zoom * zoomFactor;
                        // update the camera matrix
                        camera.preRender();
                        const point2 = camera.getWorldPoint(offsetX, offsetY);
                        const dx = point2.x - point1.x;
                        const dy = point2.y - point1.y;
                        camera.scrollX += -dx;
                        camera.scrollY += -dy;
                        this.updateState();
                        this._editor.repaint();
                    }
                    controlZoom(z) {
                        if (z === 0) {
                            // reset zoom
                            const { borderX, borderY } = this._editor.getScene().getSettings();
                            const camera = this.getCamera();
                            camera.scrollX = borderX;
                            camera.scrollY = borderY;
                            camera.zoom = 1;
                            this.updateState();
                            this._editor.repaint();
                        }
                        else {
                            const b = this._editor.getCanvasContainer().getBoundingClientRect();
                            this.zoom(-z, b.width / 2, b.height / 2);
                        }
                    }
                    getState() {
                        return this._state;
                    }
                    setState(state) {
                        if (state) {
                            const camera = this.getCamera();
                            camera.scrollX = state.scrollX;
                            camera.scrollY = state.scrollY;
                            camera.zoom = state.zoom;
                            this._state = state;
                        }
                    }
                }
                editor_1.CameraManager = CameraManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_13.ui || (scene_13.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_14) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var controls = colibri.ui.controls;
                class CellRendererCache {
                    constructor() {
                        this._imageMap = new Map();
                        this._hashMap = new Map();
                        this._promiseMap = new Map();
                    }
                    getImage(obj) {
                        const objId = obj.getEditorSupport().getId();
                        const imageInCache = this._imageMap.get(objId);
                        return imageInCache;
                    }
                    async preloadImage(obj) {
                        const objId = obj.getEditorSupport().getId();
                        if (this._promiseMap.has(objId)) {
                            return this._promiseMap.get(objId);
                        }
                        const hash = obj.getEditorSupport().computeContentHash();
                        const hashInCache = this._hashMap.get(objId);
                        if (hashInCache === hash) {
                            return controls.PreloadResult.NOTHING_LOADED;
                        }
                        if (this._promiseMap.has(objId)) {
                            return this._promiseMap.get(objId);
                        }
                        const makeImagePromise = new Promise((resolve, reject) => {
                            const sprite = obj;
                            const angle = sprite.angle;
                            const originX = sprite.originX;
                            const originY = sprite.originY;
                            const scaleX = sprite.scaleX;
                            const scaleY = sprite.scaleY;
                            sprite.setAngle(0);
                            sprite.setOrigin(0, 0);
                            sprite.setScale(1, 1);
                            let renderX = 0;
                            let renderY = 0;
                            let renderWidth = sprite.width;
                            let renderHeight = sprite.height;
                            if (sprite instanceof ui.sceneobjects.TilemapLayer) {
                                const layer = sprite;
                                if (layer.getEditorSupport().getOrientation() === Phaser.Tilemaps.Orientation.ISOMETRIC) {
                                    renderX = layer.width / 2;
                                    renderY = 0;
                                    renderWidth = layer.width * 2;
                                    renderHeight = layer.height * 2;
                                }
                            }
                            renderWidth = Math.max(1, Math.min(1024, renderWidth));
                            renderHeight = Math.max(1, Math.min(1024, renderHeight));
                            const scene = sprite.getEditorSupport().getScene();
                            const render = new Phaser.GameObjects.RenderTexture(scene, 0, 0, renderWidth, renderHeight);
                            render.draw(sprite, renderX, renderY);
                            try {
                                render.snapshot(imgElement => {
                                    const img = new controls.ImageWrapper(imgElement);
                                    this._hashMap.set(objId, hash);
                                    this._imageMap.set(objId, img);
                                    this._promiseMap.delete(objId);
                                    resolve(controls.PreloadResult.RESOURCES_LOADED);
                                });
                            }
                            catch (e) {
                                console.error(obj.getEditorSupport().getLabel() + ": " + e.message);
                            }
                            sprite.setAngle(angle);
                            sprite.setOrigin(originX, originY);
                            sprite.setScale(scaleX, scaleY);
                            render.destroy();
                        });
                        this._promiseMap.set(objId, makeImagePromise);
                        return makeImagePromise;
                    }
                    clear() {
                        this._imageMap.clear();
                        this._hashMap.clear();
                        this._promiseMap.clear();
                    }
                }
                editor.CellRendererCache = CellRendererCache;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_14.ui || (scene_14.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_2) {
                class ClipboardManager {
                    constructor(editor) {
                        this._editor = editor;
                    }
                    static getClipboard() {
                        return this._clipboard;
                    }
                    static getClipboardCopy() {
                        return this._clipboard.map(obj => JSON.parse(JSON.stringify(obj)));
                    }
                    copy() {
                        ClipboardManager._clipboard = [];
                        let minX = Number.MAX_SAFE_INTEGER;
                        let minY = Number.MAX_SAFE_INTEGER;
                        const p = new Phaser.Math.Vector2();
                        for (const obj of this._editor.getSelectedGameObjects()) {
                            const sprite = obj;
                            if (sprite.getWorldTransformMatrix) {
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                            }
                            else {
                                // the case of Layer
                                p.set(0, 0);
                            }
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                        }
                        for (const obj of this._editor.getSelectedGameObjects()) {
                            const objData = {};
                            obj.getEditorSupport().writeJSON(objData);
                            const sprite = obj;
                            if (sprite.getWorldTransformMatrix) {
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                            }
                            else {
                                // the case of Layer
                                p.set(0, 0);
                            }
                            p.x -= minX;
                            p.y -= minY;
                            objData["__shiftLeft_x"] = p.x;
                            objData["__shiftLeft_y"] = p.y;
                            ClipboardManager._clipboard.push({
                                type: "ISceneObject",
                                data: objData
                            });
                        }
                        for (const list of this._editor.getSelectedLists()) {
                            const listData = {};
                            list.writeJSON(listData);
                            ClipboardManager._clipboard.push({
                                type: "ObjectList",
                                data: listData
                            });
                        }
                    }
                    paste(pasteInPlace) {
                        if (ClipboardManager._clipboard.length > 0) {
                            this._editor.getUndoManager().add(new editor_2.undo.PasteOperation(this._editor, pasteInPlace));
                        }
                    }
                    cut() {
                        if (this._editor.getSelection().length > 0) {
                            this._editor.getUndoManager().add(new editor_2.undo.CutOperation(this._editor));
                        }
                    }
                }
                ClipboardManager._clipboard = [];
                editor_2.ClipboardManager = ClipboardManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_3) {
                var controls = colibri.ui.controls;
                class ConvertTypeDialog extends controls.dialogs.ViewerFormDialog {
                    constructor(editor) {
                        super(new ui.viewers.ObjectExtensionAndPrefabViewer(), true);
                        this._editor = editor;
                        this.setSize(900, 500, true);
                    }
                    static canConvert(editor) {
                        return this.getObjectsToMorph(editor).length > 0;
                    }
                    static getObjectsToMorph(editor) {
                        return editor.getSelection().filter(obj => ui.sceneobjects.isGameObject(obj));
                    }
                    create() {
                        const viewer = this.getViewer();
                        super.create();
                        this.setTitle("Replace Type");
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Replace", async (sel) => {
                            const targetType = viewer.getSelectionFirstElement();
                            let extraData = {};
                            if (targetType instanceof ui.sceneobjects.SceneGameObjectExtension) {
                                const result = await targetType.collectExtraDataForCreateDefaultObject(this._editor);
                                if (result.abort) {
                                    return;
                                }
                                if (result.dataNotFoundMessage) {
                                    alert(result.dataNotFoundMessage);
                                    return;
                                }
                                extraData = result.data;
                            }
                            if (typeof extraData !== "object") {
                                extraData = {};
                            }
                            extraData.keepOriginalTexture = this._keepOriginalTexture;
                            this._editor.getUndoManager().add(new editor_3.undo.ConvertTypeOperation(this._editor, targetType, extraData));
                            this.close();
                        }));
                        viewer.expandRoots();
                        viewer.selectFirst();
                        this.addCancelButton();
                    }
                    createFormArea(formArea) {
                        this._keepOriginalTexture = window.localStorage["phasereditor2d.scene.ui.editor.ConvertTypeDialog.keepOriginalTexture"] === "true";
                        const checkbox = document.createElement("input");
                        checkbox.id = "checkbox1";
                        checkbox.type = "checkbox";
                        checkbox.checked = this._keepOriginalTexture;
                        checkbox.addEventListener("change", e => {
                            this._keepOriginalTexture = checkbox.checked;
                            window.localStorage["phasereditor2d.scene.ui.editor.ConvertTypeDialog.keepOriginalTexture"] = this._keepOriginalTexture;
                        });
                        const label = document.createElement("label");
                        label.innerHTML = "Keep the original texture.";
                        label.htmlFor = "checkbox1";
                        const fieldElement = document.createElement("div");
                        fieldElement.style.gridColumn = "1 / span 2";
                        fieldElement.style.display = "flex";
                        fieldElement.style.alignItems = "center";
                        fieldElement.appendChild(checkbox);
                        fieldElement.appendChild(label);
                        formArea.appendChild(fieldElement);
                    }
                }
                editor_3.ConvertTypeDialog = ConvertTypeDialog;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_15) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_4) {
                var controls = colibri.ui.controls;
                var ide = colibri.ui.ide;
                var io = colibri.core.io;
                class DropManager {
                    constructor(editor) {
                        this._editor = editor;
                        const canvas = this._editor.getOverlayLayer().getCanvas();
                        canvas.addEventListener("dragover", e => this.onDragOver(e));
                        canvas.addEventListener("drop", e => this.onDragDrop_async(e));
                    }
                    async onDragDrop_async(e) {
                        const dataArray = controls.Controls.getApplicationDragDataAndClean();
                        for (const data of dataArray) {
                            if (data instanceof io.FilePath) {
                                if (data.getExtension() !== "scene") {
                                    alert("<p>Only items shown in the Blocks view can be added to the scene.</p>" +
                                        "<p>The Blocks view shows Scene Prefabs and items defined in the Asset Pack files.</p>" +
                                        "<p>You can add files to a Pack File using the Inspector view or opening a pack file in the Asset Pack editor.</p>");
                                    return;
                                }
                            }
                        }
                        if (this.acceptDropDataArray(dataArray)) {
                            e.preventDefault();
                            await this.dropData(dataArray, e.offsetX, e.offsetY);
                        }
                    }
                    async dropDataAtCenter(dataArray) {
                        controls.Controls.setApplicationDragData(dataArray);
                        const rect = this._editor.getElement().getClientRects().item(0);
                        const offsetX = rect.width / 2;
                        const offsetY = rect.height / 2;
                        this.dropData(dataArray, offsetX, offsetY);
                    }
                    async dropData(dataArray, offsetX, offsetY) {
                        await this._editor.getUndoManager()
                            .add(new editor_4.undo.CreateObjectWithAssetOperation(this._editor, dataArray, offsetX, offsetY));
                        await this._editor.refreshDependenciesHash();
                        ide.Workbench.getWorkbench().setActivePart(this._editor);
                    }
                    async createWithDropEvent(dropAssetArray, offsetX, offsetY) {
                        const scene = this._editor.getScene();
                        const sceneMaker = scene.getMaker();
                        const exts = scene_15.ScenePlugin.getInstance().getGameObjectExtensions();
                        const nameMaker = new ide.utils.NameMaker(obj => {
                            if (obj instanceof ui.sceneobjects.ObjectList) {
                                return obj.getLabel();
                            }
                            return obj.getEditorSupport().getLabel();
                        });
                        scene.visitAll(obj => nameMaker.update([obj]));
                        nameMaker.update(scene.getPlainObjects());
                        nameMaker.update(scene.getObjectLists().getLists());
                        const worldPoint = scene.getCamera().getWorldPoint(offsetX, offsetY);
                        const x = Math.floor(worldPoint.x);
                        const y = Math.floor(worldPoint.y);
                        const sceneFinder = scene_15.ScenePlugin.getInstance().getSceneFinder();
                        for (const data of dropAssetArray) {
                            if (data instanceof io.FilePath) {
                                const file = data;
                                if (sceneMaker.isPrefabFile(file)) {
                                    const sceneData = sceneFinder.getSceneData(file);
                                    if (sceneData) {
                                        await sceneMaker.updateSceneLoader(sceneData);
                                    }
                                }
                            }
                        }
                        for (const data of dropAssetArray) {
                            const ext = scene_15.ScenePlugin.getInstance().getLoaderUpdaterForAsset(data);
                            if (ext) {
                                await ext.updateLoader(scene, data);
                            }
                        }
                        const prefabObj = scene.getPrefabObject();
                        const newSprites = [];
                        const newLists = [];
                        const newPlainObjects = [];
                        for (const data of dropAssetArray) {
                            if (data instanceof io.FilePath) {
                                if (sceneMaker.isPrefabFile(data)) {
                                    const sprite = await sceneMaker.createPrefabInstanceWithFile(data);
                                    if (sprite.getEditorSupport().hasComponent(ui.sceneobjects.TransformComponent)) {
                                        sprite.getEditorSupport().setUnlockedProperty(ui.sceneobjects.TransformComponent.x, true);
                                        sprite.getEditorSupport().setUnlockedProperty(ui.sceneobjects.TransformComponent.y, true);
                                        sprite.setPosition(x, y);
                                    }
                                    if (sprite) {
                                        newSprites.push(sprite);
                                    }
                                    continue;
                                }
                            }
                            for (const ext of exts) {
                                if (ext.acceptsDropData(data)) {
                                    const sprite = ext.createSceneObjectWithAsset({
                                        x: x,
                                        y: y,
                                        asset: data,
                                        scene: scene
                                    });
                                    newSprites.push(sprite);
                                    break;
                                }
                            }
                            if (data instanceof ui.sceneobjects.SceneObjectExtension) {
                                let extraData;
                                if (data instanceof ui.sceneobjects.SceneObjectExtension) {
                                    const result = await data.collectExtraDataForCreateDefaultObject(this._editor);
                                    if (result.abort) {
                                        continue;
                                    }
                                    if (result.dataNotFoundMessage) {
                                        alert(result.dataNotFoundMessage);
                                        continue;
                                    }
                                    extraData = result.data;
                                    const defaultObjects = this._editor.getSceneMaker()
                                        .createDefaultObject(data, extraData, x, y);
                                    for (const defaultObject of defaultObjects) {
                                        if (ui.sceneobjects.isGameObject(defaultObject)) {
                                            newSprites.push(defaultObject);
                                        }
                                        else {
                                            scene.addPlainObject(defaultObject);
                                            newPlainObjects.push(defaultObject);
                                        }
                                    }
                                }
                            }
                            else if (data === ui.sceneobjects.ObjectList) {
                                const list = new ui.sceneobjects.ObjectList();
                                list.setLabel(nameMaker.makeName("list"));
                                scene.getObjectLists().getLists().push(list);
                                newLists.push(list);
                            }
                        }
                        for (const sceneObject of [...newSprites, ...newPlainObjects]) {
                            const support = sceneObject.getEditorSupport();
                            let label = support.getLabel();
                            if (support instanceof ui.sceneobjects.GameObjectEditorSupport) {
                                label = support.isPrefabInstance() ? support.getPrefabName() : support.getLabel();
                            }
                            label = scene_15.core.code.formatToValidVarName(label);
                            label = nameMaker.makeName(label);
                            support.setLabel(label);
                        }
                        scene.getMaker().afterDropObjects(prefabObj, newSprites);
                        return [...newSprites, ...newPlainObjects, ...newLists];
                    }
                    onDragOver(e) {
                        const dataArray = controls.Controls.getApplicationDragData();
                        // accept any kind of file, so we can show a message when the drop is done.
                        for (const data of dataArray) {
                            if (data instanceof io.FilePath) {
                                e.preventDefault();
                                return;
                            }
                        }
                        if (this.acceptDropDataArray(dataArray)) {
                            e.preventDefault();
                        }
                    }
                    acceptDropData(data) {
                        if (data instanceof io.FilePath) {
                            return ui.SceneMaker.acceptDropFile(data, this._editor.getInput());
                        }
                        for (const ext of scene_15.ScenePlugin.getInstance().getGameObjectExtensions()) {
                            if (ext.acceptsDropData(data)) {
                                return true;
                            }
                        }
                        if (data instanceof ui.sceneobjects.SceneObjectExtension) {
                            return true;
                        }
                        if (data === ui.sceneobjects.ObjectList) {
                            return true;
                        }
                        return false;
                    }
                    acceptDropDataArray(dataArray) {
                        if (this._editor.isLoading()) {
                            return false;
                        }
                        if (!dataArray) {
                            return false;
                        }
                        for (const item of dataArray) {
                            if (!this.acceptDropData(item)) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                editor_4.DropManager = DropManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_15.ui || (scene_15.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_5) {
                var controls = colibri.ui.controls;
                class LayoutToolsManager {
                    constructor(editor) {
                        this._editor = editor;
                    }
                    togglePaneVisible() {
                        this.setPaneVisible(!this.isPaneVisible());
                    }
                    setPaneVisible(visible) {
                        this._paneVisible = visible;
                        if (visible) {
                            this._pane.style.display = "grid";
                        }
                        else {
                            this._pane.style.display = "none";
                        }
                        window.localStorage.setItem("phasereditor2d.scene.ui.editor.layoutPaneVisible", visible ? "true" : "false");
                    }
                    isPaneVisible() {
                        return this._paneVisible;
                    }
                    createElement() {
                        const pane = document.createElement("div");
                        pane.classList.add("LayoutPane");
                        const centerPane = document.createElement("div");
                        centerPane.classList.add("CenterPane", "Pane");
                        pane.appendChild(centerPane);
                        this._parametersElement = document.createElement("div");
                        this._parametersElement.classList.add("Parameters");
                        centerPane.appendChild(this._parametersElement);
                        const toolbarElement = document.createElement("div");
                        toolbarElement.classList.add("Toolbar");
                        centerPane.appendChild(toolbarElement);
                        const toolbar = new controls.ToolbarManager(toolbarElement);
                        const extsByGroup = scene.ScenePlugin.getInstance().getLayoutExtensionsByGroup();
                        for (const groupSet of extsByGroup) {
                            for (const ext of groupSet.extensions) {
                                const config = ext.getConfig();
                                toolbar.addAction({
                                    text: config.name,
                                    icon: config.icon,
                                    showText: false,
                                    callback: () => ext.performLayout(this._editor)
                                });
                            }
                        }
                        this._editor.getCanvasContainer().appendChild(pane);
                        this._pane = pane;
                        {
                            const item = window.localStorage.getItem("phasereditor2d.scene.ui.editor.layoutPaneVisible");
                            this.setPaneVisible(item !== "false");
                        }
                    }
                    clearParameters() {
                        while (this._parametersElement.firstChild) {
                            this._parametersElement.removeChild(this._parametersElement.firstChild);
                        }
                    }
                    async showParametersPane(ext) {
                        const paneWasVisible = this.isPaneVisible();
                        if (!paneWasVisible) {
                            this.togglePaneVisible();
                        }
                        return new Promise((resolve, reject) => {
                            const params = ext.getConfig().params || [];
                            this.clearParameters();
                            if (params.length === 0) {
                                resolve(null);
                                return;
                            }
                            const formParent = document.createElement("div");
                            formParent.classList.add("Form");
                            this._parametersElement.appendChild(formParent);
                            const form = new controls.properties.EasyFormBuilder(formParent);
                            const titlePane = document.createElement("div");
                            titlePane.classList.add("Title");
                            formParent.appendChild(titlePane);
                            const titleLabel = document.createElement("label");
                            titleLabel.textContent = ext.getConfig().name;
                            titlePane.appendChild(titleLabel);
                            const buttonPane = document.createElement("div");
                            buttonPane.classList.add("Buttons");
                            titlePane.appendChild(buttonPane);
                            const applyIcon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CHECKED));
                            applyIcon.getCanvas().classList.add("IconButton");
                            applyIcon.getCanvas().addEventListener("click", () => {
                                applyResult();
                            });
                            buttonPane.appendChild(applyIcon.getCanvas());
                            const closeIcon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_CLOSE));
                            closeIcon.getCanvas().classList.add("IconButton");
                            closeIcon.getCanvas().addEventListener("click", () => {
                                this.clearParameters();
                                resolve(null);
                            });
                            buttonPane.appendChild(closeIcon.getCanvas());
                            const elementMap = new Map();
                            const applyResult = () => {
                                const result = {};
                                for (const paramName of elementMap.keys()) {
                                    const text = elementMap.get(paramName);
                                    window.localStorage.setItem(this.getLocalStorageKey(ext, paramName), text.value);
                                    const val = Number.parseFloat(text.value);
                                    result[paramName] = val;
                                }
                                this.clearParameters();
                                if (!paneWasVisible) {
                                    this.setPaneVisible(false);
                                }
                                resolve(result);
                            };
                            for (const param of params) {
                                form.createLabel(param.label);
                                const text = form.createText();
                                const memo = window.localStorage.getItem(this.getLocalStorageKey(ext, param.name));
                                text.value = memo || param.defaultValue.toString();
                                text.addEventListener("keypress", e => {
                                    if (e.code === "Enter" || e.code === "NumpadEnter") {
                                        applyResult();
                                    }
                                });
                                elementMap.set(param.name, text);
                            }
                        });
                    }
                    getLocalStorageKey(ext, key) {
                        const config = ext.getConfig();
                        return "phasereditor2d.scene.ui.editor.LayoutToolsManager.parameters." + config.group + "." + config.name + "." + key;
                    }
                }
                editor_5.LayoutToolsManager = LayoutToolsManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_6) {
                class MouseManager {
                    constructor(editor) {
                        this._editor = editor;
                        this._toolInAction = false;
                        const canvas = editor.getOverlayLayer().getCanvas();
                        this._mousePosition = { x: 0, y: 0 };
                        canvas.addEventListener("click", e => this.onClick(e));
                        canvas.addEventListener("mousedown", e => this.onMouseDown(e));
                        canvas.addEventListener("mouseup", e => this.onMouseUp(e));
                        canvas.addEventListener("mousemove", e => this.onMouseMove(e));
                    }
                    createArgs(e) {
                        return {
                            camera: this._editor.getScene().getCamera(),
                            editor: this._editor,
                            localCoords: this._editor.isLocalCoords(),
                            objects: this._editor.getSelection(),
                            x: e.offsetX,
                            y: e.offsetY,
                            event: e
                        };
                    }
                    onMouseDown(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool) {
                            const args = this.createArgs(e);
                            if (tool.isObjectTool()) {
                                for (const obj of args.objects) {
                                    if (!tool.canEdit(obj)) {
                                        return;
                                    }
                                }
                                if (tool.containsPoint(args)) {
                                    this._toolInAction = true;
                                    tool.onStartDrag(args);
                                }
                            }
                            else {
                                this._toolInAction = true;
                                tool.onStartDrag(args);
                            }
                        }
                    }
                    getMousePosition() {
                        return this._mousePosition;
                    }
                    getDropPosition() {
                        const p = this._editor.getScene().getCamera()
                            .getWorldPoint(this._mousePosition.x, this._mousePosition.y);
                        return this._editor.getScene().snapPoint(p.x, p.y);
                    }
                    onMouseMove(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        this._mousePosition.x = e.offsetX;
                        this._mousePosition.y = e.offsetY;
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool && this._toolInAction) {
                            const args = this.createArgs(e);
                            tool.onDrag(args);
                        }
                    }
                    onMouseUp(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool) {
                            const args = this.createArgs(e);
                            if (tool.isObjectTool()) {
                                for (const obj of args.objects) {
                                    if (!tool.canEdit(obj)) {
                                        return;
                                    }
                                }
                            }
                            tool.onStopDrag(args);
                        }
                    }
                    onClick(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        if (this._toolInAction) {
                            this._toolInAction = false;
                            return;
                        }
                        const selManager = this._editor.getSelectionManager();
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool) {
                            const args = this.createArgs(e);
                            let canEdit = true;
                            for (const obj of args.objects) {
                                if (!tool.canEdit(obj)) {
                                    canEdit = false;
                                    break;
                                }
                            }
                            if (canEdit && tool.containsPoint(args)) {
                                return;
                            }
                        }
                        selManager.onMouseClick(e);
                    }
                }
                editor_6.MouseManager = MouseManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseOverlayLayer.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_7) {
                var controls = colibri.ui.controls;
                class OverlayLayer extends editor_7.BaseOverlayLayer {
                    constructor(editor) {
                        super();
                        this._editor = editor;
                    }
                    renderLayer() {
                        this.renderGrid();
                        this.renderSelection();
                        this.renderTools();
                    }
                    renderTools() {
                        const manager = this._editor.getToolsManager();
                        const tool = manager.getActiveTool();
                        if (!tool) {
                            return;
                        }
                        const renderSel = this._editor.getSelection().filter(obj => tool.canRender(obj));
                        if (renderSel.length === 0 && tool.isObjectTool()) {
                            return;
                        }
                        const editSel = this._editor.getSelection().filter(obj => tool.canEdit(obj));
                        const ctx = this.getContext();
                        ctx.save();
                        tool.render({
                            editor: this._editor,
                            localCoords: this._editor.isLocalCoords(),
                            canvasContext: ctx,
                            objects: renderSel,
                            canEdit: editSel.length === renderSel.length,
                            camera: this._editor.getScene().getCamera()
                        });
                        ctx.restore();
                    }
                    renderSelection() {
                        const ctx = this.getContext();
                        ctx.save();
                        const camera = this._editor.getScene().getCamera();
                        for (const obj of this._editor.getSelection()) {
                            if (ui.sceneobjects.isGameObject(obj)) {
                                const sprite = obj;
                                const points = sprite.getEditorSupport().getScreenBounds(camera);
                                if (points.length === 4) {
                                    ctx.strokeStyle = "black";
                                    ctx.lineWidth = 4;
                                    ctx.beginPath();
                                    ctx.moveTo(points[0].x, points[0].y);
                                    ctx.lineTo(points[1].x, points[1].y);
                                    ctx.lineTo(points[2].x, points[2].y);
                                    ctx.lineTo(points[3].x, points[3].y);
                                    ctx.closePath();
                                    ctx.stroke();
                                    ctx.strokeStyle = "#00ff00";
                                    // ctx.strokeStyle = controls.Controls.getTheme().viewerSelectionBackground;
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.moveTo(points[0].x, points[0].y);
                                    ctx.lineTo(points[1].x, points[1].y);
                                    ctx.lineTo(points[2].x, points[2].y);
                                    ctx.lineTo(points[3].x, points[3].y);
                                    ctx.closePath();
                                    ctx.stroke();
                                }
                            }
                        }
                        ctx.restore();
                    }
                    renderGrid() {
                        const settings = this._editor.getScene().getSettings();
                        const camera = this._editor.getScene().getCamera();
                        // parameters from settings
                        const snapEnabled = settings.snapEnabled;
                        const snapX = settings.snapWidth;
                        const snapY = settings.snapHeight;
                        const borderX = settings.borderX;
                        const borderY = settings.borderY;
                        const borderWidth = settings.borderWidth;
                        const borderHeight = settings.borderHeight;
                        const canvasWidth = this.getCanvas().width;
                        const canvasHeight = this.getCanvas().height;
                        const ctx = this.getContext();
                        // render grid
                        const theme = controls.Controls.getTheme();
                        ctx.strokeStyle = theme.dark ? "#6e6e6eaa" : "#bebebecc";
                        ctx.lineWidth = 1;
                        let gapX = 4;
                        let gapY = 4;
                        if (snapEnabled) {
                            gapX = snapX;
                            gapY = snapY;
                        }
                        {
                            for (let i = 1; true; i++) {
                                const delta = camera.getScreenPoint(gapX * i, gapY * i).subtract(camera.getScreenPoint(0, 0));
                                if (delta.x > 64 && delta.y > 64) {
                                    gapX = gapX * i;
                                    gapY = gapY * i;
                                    break;
                                }
                            }
                        }
                        const worldStartPoint = camera.getWorldPoint(0, 0);
                        worldStartPoint.x = Phaser.Math.Snap.Floor(worldStartPoint.x, gapX);
                        worldStartPoint.y = Phaser.Math.Snap.Floor(worldStartPoint.y, gapY);
                        const worldEndPoint = camera.getWorldPoint(canvasWidth, canvasHeight);
                        const grid = (render) => {
                            let worldY = worldStartPoint.y;
                            while (worldY < worldEndPoint.y) {
                                const point = camera.getScreenPoint(0, worldY);
                                render.horizontal(worldY, Math.floor(point.y));
                                worldY += gapY;
                            }
                            let worldX = worldStartPoint.x;
                            while (worldX < worldEndPoint.x) {
                                const point = camera.getScreenPoint(worldX, 0);
                                render.vertical(worldX, Math.floor(point.x));
                                worldX += gapX;
                            }
                        };
                        let labelWidth = 0;
                        ctx.save();
                        ctx.fillStyle = ctx.strokeStyle;
                        // labels
                        grid({
                            horizontal: (worldY, screenY) => {
                                const w = ctx.measureText(worldY.toString()).width;
                                labelWidth = Math.max(labelWidth, w + 2);
                                ctx.save();
                                ctx.fillStyle = "#000000";
                                ctx.fillText(worldY.toString(), 0 + 1, screenY + 4 + 1);
                                ctx.restore();
                                ctx.fillText(worldY.toString(), 0, screenY + 4);
                            },
                            vertical: (worldX, screenX) => {
                                if (screenX < labelWidth) {
                                    return;
                                }
                                const w = ctx.measureText(worldX.toString()).width;
                                ctx.save();
                                ctx.fillStyle = "#000000";
                                ctx.fillText(worldX.toString(), screenX - w / 2 + 1, 15 + 1);
                                ctx.restore();
                                ctx.fillText(worldX.toString(), screenX - w / 2, 15);
                            }
                        });
                        // lines
                        grid({
                            horizontal: (worldY, screenY) => {
                                if (screenY < 20) {
                                    return;
                                }
                                ctx.beginPath();
                                ctx.moveTo(labelWidth, screenY);
                                ctx.lineTo(canvasWidth, screenY);
                                ctx.stroke();
                            },
                            vertical: (worldX, screenX) => {
                                if (screenX < labelWidth) {
                                    return;
                                }
                                ctx.beginPath();
                                ctx.moveTo(screenX, 20);
                                ctx.lineTo(screenX, canvasHeight);
                                ctx.stroke();
                            }
                        });
                        ctx.restore();
                        {
                            ctx.save();
                            ctx.lineWidth = 2;
                            const a = camera.getScreenPoint(borderX, borderY);
                            const b = camera.getScreenPoint(borderX + borderWidth, borderY + borderHeight);
                            ctx.save();
                            ctx.strokeStyle = theme.dark ? "#0a0a0a" : "#404040";
                            ctx.strokeRect(a.x + 2, a.y + 2, b.x - a.x, b.y - a.y);
                            ctx.restore();
                            ctx.lineWidth = 1;
                            ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);
                            ctx.restore();
                        }
                    }
                }
                editor_7.OverlayLayer = OverlayLayer;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_8) {
                var controls = colibri.ui.controls;
                var json = scene.core.json;
                var FileUtils = colibri.ui.ide.FileUtils;
                class SceneEditor extends colibri.ui.ide.FileEditor {
                    constructor() {
                        super("phasereditor2d.SceneEditor", SceneEditor.getFactory());
                        this.addClass("SceneEditor");
                        this._blocksProvider = new ui.blocks.SceneEditorBlocksProvider(this);
                        this._outlineProvider = new editor_8.outline.SceneEditorOutlineProvider(this);
                        this._propertyProvider = new editor_8.properties.SceneEditorSectionProvider(this);
                        this._menuCreator = new editor_8.SceneEditorMenuCreator(this);
                        this._localCoords = true;
                        this._cellRendererCache = new editor_8.CellRendererCache();
                    }
                    static getFactory() {
                        return this._factory || (this._factory = new colibri.ui.ide.ContentTypeEditorFactory("Scene Editor", scene.core.CONTENT_TYPE_SCENE, () => new SceneEditor()));
                    }
                    getMenuCreator() {
                        return this._menuCreator;
                    }
                    isLocalCoords() {
                        return this._localCoords;
                    }
                    setLocalCoords(local, repaint = true) {
                        this._localCoords = local;
                        if (repaint) {
                            this.repaint();
                        }
                    }
                    async confirmUnlockProperty(props, propLabel, ...sectionId) {
                        const lockedObjects = this.getSelectedGameObjects().filter(obj => {
                            for (const prop of props) {
                                if (!obj.getEditorSupport().isUnlockedProperty(prop)) {
                                    return true;
                                }
                                return false;
                            }
                        });
                        if (lockedObjects.length > 0) {
                            return new Promise((resolve, _) => {
                                controls.dialogs.ConfirmDialog.show(`The ${propLabel} property is locked in ${lockedObjects.length} objects. Do you want to unlock it?`, "Unlock")
                                    .then(ok => {
                                    if (ok) {
                                        this.getUndoManager()
                                            .add(new ui.sceneobjects.PropertyUnlockOperation(this, lockedObjects, props, true));
                                        for (const id of sectionId) {
                                            this.updateInspectorViewSection(id);
                                        }
                                    }
                                    resolve(ok);
                                });
                            });
                        }
                        return true;
                    }
                    openSourceFileInEditor() {
                        const lang = this._scene.getSettings().compilerOutputLanguage;
                        const ext = lang === json.SourceLang.JAVA_SCRIPT ? ".js" : ".ts";
                        const file = this.getInput().getSibling(this.getInput().getNameWithoutExtension() + ext);
                        if (file) {
                            colibri.Platform.getWorkbench().openEditor(file);
                        }
                    }
                    async doSave() {
                        // compile first because the SceneFinder will be updated after the file is changed.
                        await this.compile();
                        // saves the file
                        const sceneFile = this.getInput();
                        const writer = new json.SceneWriter(this.getScene());
                        const data = writer.toJSON();
                        const content = JSON.stringify(data, null, 4);
                        try {
                            await FileUtils.setFileString_async(sceneFile, content);
                            this.setDirty(false);
                            await this.updateTitleIcon();
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                    openOutputFileQuickEditorDialog() {
                        const file = this.getOutputFile();
                        if (!file) {
                            alert("The scene is not compiled yet. There isn't any file to edit.");
                            return;
                        }
                        const dlg = new colibri.ui.ide.QuickEditorDialog(file, this._outputFileEditorState);
                        dlg.create();
                        dlg.addButton("Play", () => {
                            colibri.Platform.getWorkbench().getCommandManager()
                                .executeCommand(phasereditor2d.ide.ui.actions.CMD_PLAY_PROJECT);
                        });
                        dlg.eventDialogClose.addListener(() => {
                            this._outputFileEditorState = dlg.getEditorState();
                            colibri.Platform.getWorkbench().setActiveEditor(this);
                        });
                    }
                    getOutputFile() {
                        const compiler = new scene.core.code.SceneCompiler(this._scene, this.getInput());
                        const outputFile = compiler.getOutputFile();
                        return outputFile;
                    }
                    async compile() {
                        const compiler = new scene.core.code.SceneCompiler(this._scene, this.getInput());
                        const outputFile = compiler.getOutputFile();
                        const dirtyEditors = colibri.Platform.getWorkbench()
                            .getOpenEditorsWithInput(outputFile)
                            .filter(editor => editor.isDirty());
                        if (dirtyEditors.length > 0) {
                            alert("Cannot overwrite the '" + outputFile.getName() + "' file, it is open in a dirty editor.");
                            return;
                        }
                        await compiler.compile();
                    }
                    saveState(state) {
                        if (!this._scene) {
                            return;
                        }
                        state.cameraState = this._cameraManager.getState();
                        state.toolsState = this._toolsManager.getState();
                        state.selectionState = this._selectionManager.getState();
                    }
                    restoreState(state) {
                        this._editorState = state;
                        this._toolsManager.setState(state.toolsState);
                    }
                    async onEditorInputContentChangedByExternalEditor() {
                        const file = this.getInput();
                        const str = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                        const sceneData = JSON.parse(str);
                        this.refreshSceneWithData(sceneData);
                    }
                    setInput(file) {
                        super.setInput(file);
                        // we do this here because the icon should be shown even if the editor is not created yet.
                        this.updateTitleIcon(true);
                    }
                    createPart() {
                        this.setLayoutChildren(false);
                        const container = document.createElement("div");
                        container.classList.add("SceneEditorContainer");
                        this.getElement().appendChild(container);
                        const pool = Phaser.Display.Canvas.CanvasPool;
                        this._gameCanvas = scene.ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT === Phaser.CANVAS
                            ? pool.create2D(this.getElement(), 100, 100)
                            : pool.createWebGL(this.getElement(), 100, 100);
                        this._gameCanvas.classList.add("GameCanvas");
                        this._gameCanvas.style.position = "absolute";
                        container.appendChild(this._gameCanvas);
                        this._overlayLayer = new editor_8.OverlayLayer(this);
                        container.appendChild(this._overlayLayer.getCanvas());
                        this._canvasContainer = container;
                        this.createGame();
                        // init managers and factories
                        this._dropManager = new editor_8.DropManager(this);
                        this._selectionManager = new editor_8.SelectionManager(this);
                        this._toolsManager = new editor_8.tools.SceneToolsManager(this);
                        this._mouseManager = new editor_8.MouseManager(this);
                        this._cameraManager = new editor_8.CameraManager(this);
                        this._clipboardManager = new editor_8.ClipboardManager(this);
                        this._layoutToolsManager = new editor_8.LayoutToolsManager(this);
                        this._overlayLayer.getCanvas().addEventListener("contextmenu", e => this.onMenu(e));
                        this._layoutToolsManager.createElement();
                    }
                    getLayoutToolsManager() {
                        return this._layoutToolsManager;
                    }
                    getCanvasContainer() {
                        return this._canvasContainer;
                    }
                    createGame() {
                        this._scene = new ui.Scene(this);
                        this._game = new Phaser.Game({
                            type: scene.ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT,
                            canvas: this._gameCanvas,
                            // backgroundColor: "#8e8e8e",
                            scale: {
                                mode: Phaser.Scale.NONE
                            },
                            // resolution: window.devicePixelRatio,
                            render: {
                                pixelArt: true,
                                transparent: true
                            },
                            audio: {
                                noAudio: true
                            },
                            scene: this._scene,
                        });
                        this._sceneRead = false;
                        this._gameBooted = false;
                        this._game.config.postBoot = () => {
                            // the scene is created just at this moment!
                            this.onGameBoot();
                        };
                    }
                    async updateTitleIcon(force = false) {
                        const file = this.getInput();
                        await ui.SceneThumbnailCache.getInstance().preload(file, force);
                        const img = this.getIcon();
                        if (img) {
                            await img.preload();
                            this.dispatchTitleUpdatedEvent();
                        }
                        else {
                            this.dispatchTitleUpdatedEvent();
                        }
                    }
                    getIcon() {
                        const file = this.getInput();
                        if (file) {
                            const img = ui.SceneThumbnailCache.getInstance().getContent(file);
                            if (img) {
                                return img;
                            }
                        }
                        return super.getIcon();
                    }
                    createToolbarActions() {
                        if (this._toolbarActionMap) {
                            return;
                        }
                        this._toolbarActionMap = new Map();
                        this._toolsInToolbar = [
                            ui.sceneobjects.TranslateTool.ID,
                            ui.sceneobjects.ScaleTool.ID,
                            ui.sceneobjects.RotateTool.ID,
                            ui.sceneobjects.OriginTool.ID,
                            ui.sceneobjects.SelectionRegionTool.ID
                        ];
                        for (const toolId of this._toolsInToolbar) {
                            const tool = scene.ScenePlugin.getInstance().getTool(toolId);
                            this._toolbarActionMap.set(toolId, new controls.Action({
                                commandId: tool.getCommandId(),
                                showText: false
                            }));
                        }
                    }
                    getToolbarActionMap() {
                        return this._toolbarActionMap;
                    }
                    createEditorToolbar(parent) {
                        this.createToolbarActions();
                        const manager = new controls.ToolbarManager(parent);
                        for (const toolID of this._toolsInToolbar) {
                            const action = this._toolbarActionMap.get(toolID);
                            manager.add(action);
                        }
                        return manager;
                    }
                    onMenu(e) {
                        e.preventDefault();
                        const menu = new controls.Menu();
                        this.fillContextMenu(menu);
                        menu.createWithEvent(e);
                    }
                    fillContextMenu(menu) {
                        this._menuCreator.fillMenu(menu);
                    }
                    toggleSnapping() {
                        const enabled = !this.getScene().getSettings().snapEnabled;
                        this.getUndoManager().add(new editor_8.properties.ChangeSettingsPropertyOperation({
                            editor: this,
                            props: [
                                {
                                    name: "snapEnabled",
                                    value: enabled,
                                }
                            ],
                            repaint: true
                        }));
                    }
                    setSnappingToObjectSize() {
                        const obj = this.getSelectedGameObjects()[0];
                        if (obj) {
                            if (obj.width !== undefined && obj.height !== undefined) {
                                this.getUndoManager().add(new editor_8.properties.ChangeSettingsPropertyOperation({
                                    editor: this,
                                    props: [
                                        {
                                            name: "snapEnabled",
                                            value: true,
                                        },
                                        {
                                            name: "snapWidth",
                                            value: obj.width
                                        },
                                        {
                                            name: "snapHeight",
                                            value: obj.height
                                        }
                                    ],
                                    repaint: true
                                }));
                            }
                        }
                    }
                    async readScene() {
                        const maker = this._scene.getMaker();
                        this._sceneRead = true;
                        try {
                            const file = this.getInput();
                            await FileUtils.preloadFileString(file);
                            const content = FileUtils.getFileString(file);
                            const data = JSON.parse(content);
                            await scene.ScenePlugin.getInstance().runSceneDataMigrations(data);
                            if (ui.SceneMaker.isValidSceneDataFormat(data)) {
                                this._overlayLayer.setLoading(true);
                                this._overlayLayer.render();
                                await maker.preload();
                                await maker.updateSceneLoader(data, this._overlayLayer.createLoadingMonitor());
                                const errors = [];
                                maker.createScene(data, errors);
                                this._overlayLayer.setLoading(false);
                                this._overlayLayer.render();
                                if (errors.length > 0) {
                                    alert(errors.join("<br>"));
                                }
                            }
                            else {
                                alert("Invalid file format.");
                            }
                        }
                        catch (e) {
                            alert(e.message);
                            throw e;
                        }
                    }
                    isLoading() {
                        return this._overlayLayer && this._overlayLayer.isLoading();
                    }
                    getSelectedGameObjects() {
                        return this.getSelection()
                            .filter(obj => ui.sceneobjects.isGameObject(obj));
                    }
                    getSelectedLists() {
                        return this.getSelection()
                            .filter(obj => obj instanceof ui.sceneobjects.ObjectList);
                    }
                    getSelectedPlainObjects() {
                        return this.getSelection().filter(obj => ui.sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj));
                    }
                    getCameraManager() {
                        return this._cameraManager;
                    }
                    getDropManager() {
                        return this._dropManager;
                    }
                    getClipboardManager() {
                        return this._clipboardManager;
                    }
                    getToolsManager() {
                        return this._toolsManager;
                    }
                    getMouseManager() {
                        return this._mouseManager;
                    }
                    getSelectionManager() {
                        return this._selectionManager;
                    }
                    getOverlayLayer() {
                        return this._overlayLayer;
                    }
                    getGameCanvas() {
                        return this._gameCanvas;
                    }
                    getScene() {
                        return this._scene;
                    }
                    getGame() {
                        return this._game;
                    }
                    getSceneMaker() {
                        return this._scene.getMaker();
                    }
                    getPackFinder() {
                        return this.getSceneMaker().getPackFinder();
                    }
                    layout() {
                        super.layout();
                        if (!this._game) {
                            return;
                        }
                        this._overlayLayer.resizeTo();
                        const parent = this._gameCanvas.parentElement;
                        const w = parent.clientWidth;
                        const h = parent.clientHeight;
                        this._game.scale.resize(w, h);
                        if (this._gameBooted) {
                            this._scene.getCamera().setSize(w, h);
                            this.repaint();
                        }
                    }
                    updateInspectorViewSection(sectionId, repaint = true) {
                        if (repaint) {
                            this.repaint();
                        }
                        const window = colibri.Platform.getWorkbench().getActiveWindow();
                        const view = window.getView(colibri.inspector.ui.views.InspectorView.VIEW_ID);
                        const section = view.getPropertyPage().getSection(sectionId);
                        if (section) {
                            section.updateWithSelection();
                        }
                    }
                    getPropertyProvider() {
                        return this._propertyProvider;
                    }
                    getCellRendererCache() {
                        return this._cellRendererCache;
                    }
                    onPartClosed() {
                        if (super.onPartClosed()) {
                            if (this._scene) {
                                this._scene.destroyGame();
                            }
                            this._cellRendererCache.clear();
                            return true;
                        }
                        return false;
                    }
                    async refreshScene() {
                        console.log("Scene Editor: refreshing.");
                        const writer = new json.SceneWriter(this._scene);
                        const sceneData = writer.toJSON();
                        await this.refreshSceneWithData(sceneData);
                    }
                    async refreshSceneWithData(sceneData) {
                        for (const obj of this._scene.getDisplayListChildren()) {
                            obj.getEditorSupport().destroy();
                        }
                        this._scene.removeAll();
                        const maker = this.getSceneMaker();
                        await maker.preload();
                        await maker.updateSceneLoader(sceneData);
                        maker.createScene(sceneData);
                        const sel = this.getSelection()
                            .map(obj => ui.sceneobjects.isGameObject(obj) ?
                            this._scene.getByEditorId(obj.getEditorSupport().getId())
                            : obj)
                            .filter(v => v !== null && v !== undefined);
                        this.setSelection(sel);
                        this._currentRefreshHash = await this.buildDependenciesHash();
                        this.refreshOutline();
                        await this.updateTitleIcon(true);
                    }
                    async buildDependenciesHash() {
                        const maker = this._scene.getMaker();
                        await maker.getPackFinder().preload();
                        const hash = await maker.buildDependenciesHash();
                        return hash;
                    }
                    async refreshDependenciesHash() {
                        this._currentRefreshHash = await this.buildDependenciesHash();
                    }
                    async onPartActivated() {
                        super.onPartActivated();
                        {
                            if (this._scene) {
                                const hash = await this.buildDependenciesHash();
                                if (this._currentRefreshHash !== null
                                    && this._currentRefreshHash !== undefined
                                    && hash !== this._currentRefreshHash) {
                                    console.log("Scene Editor: " + this.getInput().getFullName() + " dependency changed.");
                                    await this.refreshScene();
                                }
                            }
                        }
                        await this.refreshBlocks();
                    }
                    async refreshBlocks() {
                        if (this._blocksProvider) {
                            await this._blocksProvider.preload();
                            this._blocksProvider.repaint();
                        }
                    }
                    getEditorViewerProvider(key) {
                        switch (key) {
                            case phasereditor2d.blocks.ui.views.BlocksView.EDITOR_VIEWER_PROVIDER_KEY:
                                return this._blocksProvider;
                            case phasereditor2d.outline.ui.views.OutlineView.EDITOR_VIEWER_PROVIDER_KEY:
                                return this._outlineProvider;
                            default:
                                break;
                        }
                        return null;
                    }
                    getBlocksProvider() {
                        return this._blocksProvider;
                    }
                    getOutlineProvider() {
                        return this._outlineProvider;
                    }
                    refreshOutline() {
                        this._outlineProvider.repaint();
                    }
                    async onGameBoot() {
                        this._gameBooted = true;
                        if (!this._sceneRead) {
                            await this.readScene();
                            if (this._editorState) {
                                this._cameraManager.setState(this._editorState.cameraState);
                                this._selectionManager.setState(this._editorState.selectionState);
                            }
                            else {
                                this.setSelection([]);
                            }
                            this._editorState = null;
                            this._currentRefreshHash = await this.buildDependenciesHash();
                        }
                        this.layout();
                        this.refreshOutline();
                        // for some reason, we should do this after a time, or the game is not stopped well.
                        setTimeout(() => {
                            this._game.loop.stop();
                        }, 500);
                        await this.updateTitleIcon(true);
                    }
                    repaint() {
                        if (!this._gameBooted) {
                            return;
                        }
                        try {
                            this._game.loop.tick();
                            this._overlayLayer.render();
                        }
                        catch (e) {
                            console.log(e);
                            alert(e.message);
                        }
                    }
                }
                editor_8.SceneEditor = SceneEditor;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_9) {
                var controls = colibri.ui.controls;
                class SceneEditorMenuCreator {
                    constructor(editor) {
                        this._editor = editor;
                    }
                    fillMenu(menu) {
                        menu.addMenu(this.createToolsMenu());
                        menu.addMenu(this.createCoordsMenu());
                        menu.addMenu(this.createLayoutMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createAddObjectMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createPrefabMenu());
                        menu.addMenu(this.createTypeMenu());
                        menu.addMenu(this.createOriginMenu());
                        menu.addMenu(this.createTextureMenu());
                        menu.addMenu(this.createParentMenu());
                        menu.addMenu(this.createDepthMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createSnappingMenu());
                        menu.addMenu(this.createEditMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createSceneMenu());
                        menu.addMenu(this.createCompilerMenu());
                    }
                    createAddObjectMenu() {
                        const blocksProvider = this._editor.getEditorViewerProvider(phasereditor2d.blocks.ui.views.BlocksView.EDITOR_VIEWER_PROVIDER_KEY);
                        const contentProvider = blocksProvider.getContentProvider();
                        const labelProvider = blocksProvider.getLabelProvider();
                        const cellRendererProvider = blocksProvider.getCellRendererProvider();
                        const menu = new controls.Menu("Add Object");
                        menu.addCommand(editor_9.commands.CMD_ADD_OBJECT, {
                            text: "Add..."
                        });
                        for (const cat of scene.SCENE_OBJECT_CATEGORIES) {
                            const menu2 = new controls.Menu(cat);
                            const list = contentProvider.getChildren(cat);
                            for (const obj of list) {
                                menu2.addAction({
                                    text: labelProvider.getLabel(obj),
                                    icon: new controls.viewers.ImageFromCellRenderer(obj, cellRendererProvider.getCellRenderer(obj), controls.RENDER_ICON_SIZE, controls.RENDER_ICON_SIZE),
                                    callback: () => {
                                        this._editor.getDropManager().dropDataAtCenter([obj]);
                                    }
                                });
                            }
                            menu.addMenu(menu2);
                        }
                        return menu;
                    }
                    createSceneMenu() {
                        const menu = new controls.Menu("Scene");
                        menu.addCommand(colibri.ui.ide.actions.CMD_UPDATE_CURRENT_EDITOR, {
                            text: "Refresh Scene"
                        });
                        menu.addCommand(editor_9.commands.CMD_DUPLICATE_SCENE_FILE, {
                            text: "Duplicate Scene"
                        });
                        menu.addAction({
                            text: "Settings",
                            callback: () => this._editor.setSelection([])
                        });
                        return menu;
                    }
                    createCompilerMenu(menu = new controls.Menu("Compiler")) {
                        menu.addCommand(editor_9.commands.CMD_COMPILE_SCENE_EDITOR);
                        menu.addSeparator();
                        menu.addCommand(editor_9.commands.CMD_OPEN_COMPILED_FILE);
                        if (phasereditor2d.ide.IDEPlugin.getInstance().isDesktopMode()) {
                            menu.addCommand(editor_9.commands.CMD_OPEN_OUTPUT_FILE_IN_VSCODE);
                        }
                        menu.addCommand(editor_9.commands.CMD_QUICK_EDIT_OUTPUT_FILE);
                        return menu;
                    }
                    createDepthMenu() {
                        const menu = new controls.Menu("Depth");
                        for (const move of ["Up", "Down", "Top", "Bottom"]) {
                            const id = "phasereditor2d.scene.ui.editor.commands.Depth" + move;
                            menu.addCommand(id);
                        }
                        return menu;
                    }
                    createEditMenu() {
                        const menu = new controls.Menu("Edit");
                        menu.addCommand(colibri.ui.ide.actions.CMD_UNDO);
                        menu.addCommand(colibri.ui.ide.actions.CMD_REDO);
                        menu.addSeparator();
                        menu.addCommand(colibri.ui.ide.actions.CMD_CUT);
                        menu.addCommand(colibri.ui.ide.actions.CMD_COPY);
                        menu.addCommand(colibri.ui.ide.actions.CMD_PASTE);
                        menu.addCommand(editor_9.commands.CMD_PASTE_IN_PLACE);
                        return menu;
                    }
                    createOriginMenu() {
                        const menu = new controls.Menu("Origin");
                        this.createOriginMenuItems(menu);
                        return menu;
                    }
                    createOriginMenuItems(menu) {
                        for (const data of editor_9.commands.SceneEditorCommands.computeOriginCommandData()) {
                            menu.addCommand(data.command);
                        }
                    }
                    createCoordsMenuItems(menu) {
                        menu.add(new controls.Action({
                            callback: () => this._editor.setLocalCoords(true),
                            text: "Local",
                            selected: this._editor.isLocalCoords()
                        }));
                        menu.add(new controls.Action({
                            callback: () => this._editor.setLocalCoords(false),
                            text: "Global",
                            selected: !this._editor.isLocalCoords()
                        }));
                    }
                    createCoordsMenu() {
                        const menu = new controls.Menu("Coords");
                        this.createCoordsMenuItems(menu);
                        return menu;
                    }
                    createLayoutMenu() {
                        const menu = new controls.Menu("Layout");
                        menu.addAction({
                            text: "Show Layout Bar",
                            callback: () => this._editor.getLayoutToolsManager().togglePaneVisible(),
                            selected: this._editor.getLayoutToolsManager().isPaneVisible()
                        });
                        const extsByGroup = scene.ScenePlugin.getInstance().getLayoutExtensionsByGroup();
                        for (const groupSet of extsByGroup) {
                            const groupMenu = new controls.Menu(groupSet.group);
                            menu.addMenu(groupMenu);
                            for (const ext of groupSet.extensions) {
                                const config = ext.getConfig();
                                groupMenu.addAction({
                                    text: config.name,
                                    icon: config.icon,
                                    callback: () => ext.performLayout(this._editor)
                                });
                            }
                        }
                        return menu;
                    }
                    createToolsMenu() {
                        const menu = new controls.Menu("Tools");
                        const activeTool = this._editor.getToolsManager().getActiveTool();
                        const exts = colibri.Platform.getExtensions(editor_9.tools.SceneToolExtension.POINT_ID);
                        for (const ext of exts) {
                            for (const tool of ext.getTools()) {
                                menu.addCommand(tool.getCommandId(), {
                                    selected: activeTool === tool
                                });
                            }
                        }
                        return menu;
                    }
                    createPrefabMenu() {
                        const menu = new controls.Menu("Prefab");
                        menu.addCommand(editor_9.commands.CMD_OPEN_PREFAB);
                        menu.addCommand(editor_9.commands.CMD_CREATE_PREFAB_WITH_OBJECT);
                        return menu;
                    }
                    createTypeMenuItems(menu) {
                        menu.addCommand(editor_9.commands.CMD_CONVERT_OBJECTS);
                        menu.addCommand(editor_9.commands.CMD_CONVERT_TO_TILE_SPRITE_OBJECTS);
                    }
                    createTypeMenu() {
                        const menu = new controls.Menu("Type");
                        this.createTypeMenuItems(menu);
                        return menu;
                    }
                    createParentMenu() {
                        const menu = new controls.Menu("Parent");
                        menu.addCommand(editor_9.commands.CMD_JOIN_IN_LAYER);
                        menu.addSeparator();
                        menu.addCommand(editor_9.commands.CMD_JOIN_IN_CONTAINER);
                        menu.addCommand(editor_9.commands.CMD_TRIM_CONTAINER);
                        menu.addSeparator();
                        menu.addCommand(editor_9.commands.CMD_BREAK_PARENT);
                        menu.addCommand(editor_9.commands.CMD_MOVE_TO_PARENT);
                        menu.addCommand(editor_9.commands.CMD_SELECT_PARENT);
                        menu.addCommand(editor_9.commands.CMD_SELECT_CHILDREN);
                        return menu;
                    }
                    createSnappingMenu() {
                        const menu = new controls.Menu("Snapping");
                        menu.addCommand(editor_9.commands.CMD_TOGGLE_SNAPPING);
                        menu.addCommand(editor_9.commands.CMD_SET_SNAPPING_TO_OBJECT_SIZE);
                        menu.addSeparator();
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_LEFT);
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_RIGHT);
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_UP);
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_DOWN);
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_LEFT + "Large");
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_RIGHT + "Large");
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_UP + "Large");
                        menu.addCommand(editor_9.commands.CMD_MOVE_OBJECT_DOWN + "Large");
                        return menu;
                    }
                    createTextureMenu() {
                        const menu = new controls.Menu("Texture");
                        this.createTextureMenuItems(menu);
                        return menu;
                    }
                    createTextureMenuItems(menu) {
                        menu.addCommand(editor_9.commands.CMD_SELECT_ALL_OBJECTS_SAME_TEXTURE);
                        menu.addCommand(editor_9.commands.CMD_REPLACE_TEXTURE);
                        menu.addCommand(editor_9.commands.CMD_REPLACE_TEXTURE_FRAME);
                        const obj = this._editor.getSelectedGameObjects()[0];
                        if (obj) {
                            if (obj.getEditorSupport().hasComponent(ui.sceneobjects.TextureComponent)) {
                                const comp = obj.getEditorSupport().getComponent(ui.sceneobjects.TextureComponent);
                                const keys = comp.getTextureKeys();
                                if (keys) {
                                    const item = this._editor.getScene().getMaker().getPackFinder().findAssetPackItem(keys.key);
                                    if (item) {
                                        menu.addAction({
                                            text: "Show Texture In Asset Pack Editor",
                                            callback: () => {
                                                const file = item.getPack().getFile();
                                                const editor = colibri.Platform.getWorkbench().openEditor(file);
                                                editor.revealKey(item.getKey());
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                editor_9.SceneEditorMenuCreator = SceneEditorMenuCreator;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_16) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_10) {
                class SelectionManager {
                    constructor(editor) {
                        this._editor = editor;
                        this._editor.eventSelectionChanged.addListener(() => this.updateOutlineSelection());
                    }
                    getSelectionIds() {
                        const list = [];
                        list.push(...this._editor.getSelectedGameObjects()
                            .map(obj => obj.getEditorSupport().getId()));
                        list.push(...this._editor.getSelectedPlainObjects()
                            .map(obj => obj.getEditorSupport().getId()));
                        list.push(...this._editor.getSelection()
                            .filter(obj => obj instanceof ui.sceneobjects.ObjectList)
                            .map(obj => obj.getId()));
                        return list;
                    }
                    setSelectionByIds(selectionIds) {
                        const scene = this._editor.getScene();
                        const map = new Map(scene.buildObjectIdMap());
                        for (const obj of scene.getPlainObjects()) {
                            map.set(obj.getEditorSupport().getId(), obj);
                        }
                        for (const list of this._editor.getScene().getObjectLists().getLists()) {
                            map.set(list.getId(), list);
                        }
                        const sel = selectionIds
                            .map(id => map.get(id))
                            .filter(obj => obj !== undefined);
                        this._editor.setSelection(sel);
                    }
                    getState() {
                        return this.getSelectionIds();
                    }
                    setState(state) {
                        if (state) {
                            this.setSelectionByIds(state);
                        }
                        else {
                            this._editor.setSelection([]);
                        }
                    }
                    clearSelection() {
                        this._editor.setSelection([]);
                        this._editor.repaint();
                    }
                    refreshSelection() {
                        this._editor.setSelection(this._editor.getSelection()
                            .map(obj => {
                            const objMap = this._editor.getScene().buildObjectIdMap();
                            if (ui.sceneobjects.isGameObject(obj)) {
                                return objMap.get(obj.getEditorSupport().getId());
                            }
                            if (ui.sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj)) {
                                return this._editor.getScene().getPlainObjectById(obj.getEditorSupport().getId());
                            }
                            if (obj instanceof ui.sceneobjects.ObjectList) {
                                return this._editor.getScene().getObjectLists().getListById(obj.getId());
                            }
                            return undefined;
                        })
                            .filter(obj => obj !== undefined && obj !== null));
                    }
                    selectAll() {
                        const sel = this._editor.getScene().getDisplayListChildren();
                        this._editor.setSelection(sel);
                        this._editor.repaint();
                    }
                    updateOutlineSelection() {
                        const provider = this._editor.getOutlineProvider();
                        const sel = this._editor.getSelection();
                        provider.setSelection(sel, true, true);
                        provider.repaint();
                    }
                    onMouseClick(e) {
                        const result = this.hitTestOfActivePointer();
                        let next = [];
                        if (result && result.length > 0) {
                            const current = this._editor.getSelection();
                            let selected = result[result.length - 1];
                            if (selected) {
                                const obj = selected;
                                const objSupport = obj.getEditorSupport();
                                const owner = objSupport.getOwnerPrefabInstance();
                                if ((owner instanceof ui.sceneobjects.Container || owner instanceof ui.sceneobjects.Layer)
                                    && objSupport.isMutableNestedPrefabInstance()
                                    && owner.getEditorSupport().isAllowPickChildren()) {
                                    // ok, it can be selected
                                }
                                else {
                                    selected = owner ?? selected;
                                }
                            }
                            if (selected) {
                                const objParent = ui.sceneobjects.getObjectParent(selected);
                                if (objParent) {
                                    if (!objParent.getEditorSupport().isAllowPickChildren()) {
                                        selected = objParent;
                                    }
                                }
                            }
                            if (e.ctrlKey || e.metaKey) {
                                if (new Set(current).has(selected)) {
                                    next = current.filter(obj => obj !== selected);
                                }
                                else {
                                    next = current;
                                    next.push(selected);
                                }
                            }
                            else if (selected) {
                                next = [selected];
                            }
                        }
                        this._editor.setSelection(next);
                        this._editor.repaint();
                    }
                    hitTestOfActivePointer() {
                        const scene = this._editor.getScene();
                        const manager = scene.input.manager;
                        const objects = scene.getInputSortedObjects();
                        const result = manager.hitTest(scene.input.activePointer, objects, scene.getCamera());
                        return result;
                    }
                }
                editor_10.SelectionManager = SelectionManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_16.ui || (scene_16.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_11) {
                var commands;
                (function (commands) {
                    var controls = colibri.ui.controls;
                    commands.CAT_SCENE_EDITOR = "phasereditor2d.scene.ui.editor.commands.SceneEditor";
                    commands.CMD_ADD_OBJECT = "phasereditor2d.scene.ui.editor.commands.AddObject";
                    commands.CMD_JOIN_IN_CONTAINER = "phasereditor2d.scene.ui.editor.commands.JoinInContainer";
                    commands.CMD_JOIN_IN_LAYER = "phasereditor2d.scene.ui.editor.commands.JoinInLayer";
                    commands.CMD_BREAK_PARENT = "phasereditor2d.scene.ui.editor.commands.BreakContainer";
                    commands.CMD_TRIM_CONTAINER = "phasereditor2d.scene.ui.editor.commands.TrimContainer";
                    commands.CMD_MOVE_TO_PARENT = "phasereditor2d.scene.ui.editor.commands.MoveToParent";
                    commands.CMD_SELECT_PARENT = "phasereditor2d.scene.ui.editor.commands.SelectParent";
                    commands.CMD_SELECT_CHILDREN = "phasereditor2d.scene.ui.editor.commands.SelectChildren";
                    commands.CMD_TOGGLE_VISIBLE = "phasereditor2d.scene.ui.editor.commands.ToggleVisibility";
                    commands.CMD_OPEN_COMPILED_FILE = "phasereditor2d.scene.ui.editor.commands.OpenCompiledFile";
                    commands.CMD_COMPILE_SCENE_EDITOR = "phasereditor2d.scene.ui.editor.commands.CompileSceneEditor";
                    commands.CMD_TRANSLATE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.MoveSceneObject";
                    commands.CMD_SET_ORIGIN_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.SetOriginSceneObject";
                    commands.CMD_ROTATE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.RotateSceneObject";
                    commands.CMD_SCALE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.ScaleSceneObject";
                    commands.CMD_RESIZE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.ResizeSceneObject";
                    commands.CMD_SELECT_REGION = "phasereditor2d.scene.ui.editor.commands.SelectRegion";
                    commands.CMD_PAN_SCENE = "phasereditor2d.scene.ui.editor.commands.PanScene";
                    commands.CMD_TOGGLE_SNAPPING = "phasereditor2d.scene.ui.editor.commands.ToggleSnapping";
                    commands.CMD_SET_SNAPPING_TO_OBJECT_SIZE = "phasereditor2d.scene.ui.editor.commands.SetSnappingToObjectSize";
                    commands.CMD_CONVERT_OBJECTS = "phasereditor2d.scene.ui.editor.commands.MorphObjects";
                    commands.CMD_CONVERT_TO_TILE_SPRITE_OBJECTS = "phasereditor2d.scene.ui.editor.commands.ConvertToTileSprite";
                    commands.CMD_SELECT_ALL_OBJECTS_SAME_TEXTURE = "phasereditor2d.scene.ui.editor.commands.SelectAllObjectsWithSameTexture";
                    commands.CMD_REPLACE_TEXTURE = "phasereditor2d.scene.ui.editor.commands.ReplaceTexture";
                    commands.CMD_REPLACE_TEXTURE_FRAME = "phasereditor2d.scene.ui.editor.commands.ReplaceTextureFrame";
                    commands.CMD_OPEN_PREFAB = "phasereditor2d.scene.ui.editor.commands.OpenPrefab";
                    commands.CMD_CREATE_PREFAB_WITH_OBJECT = "phasereditor2d.scene.ui.editor.commands.CreatePrefabWithObject";
                    commands.CMD_QUICK_EDIT_OUTPUT_FILE = "phasereditor2d.scene.ui.editor.commands.QuickEditOutputFile";
                    commands.CMD_OPEN_OUTPUT_FILE_IN_VSCODE = "phasereditor2d.scene.ui.editor.commands.OpenOutputFileInVSCode";
                    commands.CMD_MOVE_OBJECT_LEFT = "phasereditor2d.scene.ui.editor.commands.MoveObjectLeft";
                    commands.CMD_MOVE_OBJECT_RIGHT = "phasereditor2d.scene.ui.editor.commands.MoveObjectRight";
                    commands.CMD_MOVE_OBJECT_UP = "phasereditor2d.scene.ui.editor.commands.MoveObjectUp";
                    commands.CMD_MOVE_OBJECT_DOWN = "phasereditor2d.scene.ui.editor.commands.MoveObjectDown";
                    commands.CMD_FIX_SCENE_FILES_ID = "phasereditor2d.scene.ui.editor.commands.FixSceneFilesID";
                    commands.CMD_DUPLICATE_SCENE_FILE = "phasereditor2d.scene.ui.editor.commands.DuplicateSceneFile";
                    commands.CMD_CLEAR_SCENE_THUMBNAIL_CACHE = "phasereditor2d.scene.ui.editor.commands.ClearSceneThumbnailCache";
                    commands.CMD_OPEN_SCENE_FILE = "phasereditor2d.scene.ui.editor.commands.OpenSceneFile";
                    commands.CMD_DISABLE_AWAKE_EVENT_PREFABS = "phasereditor2d.scene.ui.editor.commands.DisableAwakeEventPrefabs";
                    commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_CANVAS = "phasereditor2d.scene.ui.editor.commands.SetDefaultRenderTypeToCanvas";
                    commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_WEBGL = "phasereditor2d.scene.ui.editor.commands.SetDefaultRenderTypeToWebGL";
                    commands.CMD_PASTE_IN_PLACE = "phasereditor2d.scene.ui.editor.commands.PasteInPlace";
                    function isSceneScope(args) {
                        if (colibri.Platform.getWorkbench().getActiveDialog()) {
                            return false;
                        }
                        return args.activePart instanceof editor_11.SceneEditor
                            || (args.activeEditor instanceof editor_11.SceneEditor &&
                                (args.activePart instanceof phasereditor2d.outline.ui.views.OutlineView
                                    || args.activePart instanceof colibri.inspector.ui.views.InspectorView));
                    }
                    function noNestedPrefabSelected(args) {
                        return args.activeEditor.getSelection()
                            .filter(obj => ui.sceneobjects.isGameObject(obj))
                            .filter((obj) => obj.getEditorSupport().isNestedPrefabInstance())
                            .length === 0;
                    }
                    function isOnlyContainerSelected(args) {
                        return isSceneScope(args) && editorHasSelection(args)
                            && args.activeEditor.getSelectedGameObjects()
                                .filter(obj => obj instanceof ui.sceneobjects.Container)
                                .length === args.activeEditor.getSelection().length;
                    }
                    function editorHasSelection(args) {
                        return args.activeEditor && args.activeEditor.getSelection().length > 0;
                    }
                    class SceneEditorCommands {
                        static registerCommands(manager) {
                            manager.addCategory({
                                id: commands.CAT_SCENE_EDITOR,
                                name: "Scene Editor"
                            });
                            this.registerGlobalCommands(manager);
                            this.registerEditCommands(manager);
                            this.registerAddObjectCommands(manager);
                            this.registerSceneCommands(manager);
                            this.registerVisibilityCommands(manager);
                            this.registerSelectionCommands(manager);
                            this.registerParentCommands(manager);
                            this.registerCompilerCommands(manager);
                            this.registerToolsCommands(manager);
                            this.registerOriginCommands(manager);
                            this.registerDepthCommands(manager);
                            this.registerTypeCommands(manager);
                            this.registerMoveObjectCommands(manager);
                            this.registerTextureCommands(manager);
                            this.registerSnappingCommands(manager);
                        }
                        static registerAddObjectCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_ADD_OBJECT,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Add Object",
                                    tooltip: "Add a built-in object to the scene."
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const dlg = new ui.dialogs.AddObjectDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    key: "KeyA"
                                }
                            });
                        }
                        static registerGlobalCommands(manager) {
                            // set default renderer type
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_CANVAS,
                                    name: "Set Default Render Type To CANVAS",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Set the default render type of the scenes to Phaser.CANVAS"
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: args => {
                                        scene.ScenePlugin.getInstance().setDefaultRenderType("canvas");
                                    }
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_WEBGL,
                                    name: "Set Default Render Type To WEBGL",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Set the default render type of the scenes to Phaser.WEBGL"
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: args => {
                                        scene.ScenePlugin.getInstance().setDefaultRenderType("webgl");
                                    }
                                }
                            });
                            // fix scene id
                            manager.add({
                                command: {
                                    id: commands.CMD_FIX_SCENE_FILES_ID,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Fix Duplicated Scenes ID",
                                    tooltip: "Fix the duplicated ID of the scene files."
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: async (args) => {
                                        const files = await colibri.ui.ide.FileUtils.getFilesWithContentType(scene.core.CONTENT_TYPE_SCENE);
                                        files.sort((a, b) => a.getModTime() - b.getModTime());
                                        const usedIds = new Set();
                                        const dlg = new controls.dialogs.ProgressDialog();
                                        const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                                        dlg.create();
                                        dlg.setTitle("Fix Duplicated Scenes ID");
                                        monitor.addTotal(files.length);
                                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                        finder.setEnabled(false);
                                        let someoneFixed = false;
                                        for (const file of files) {
                                            const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                                            const data = JSON.parse(content);
                                            const id = data.id;
                                            if (usedIds.has(id)) {
                                                data.id = Phaser.Utils.String.UUID();
                                                console.log(`Fix Scene ID of "${file.getFullName()}". New id: ` + data.id);
                                                const newContent = JSON.stringify(data, null, 4);
                                                await colibri.ui.ide.FileUtils.setFileString_async(file, newContent);
                                                someoneFixed = true;
                                            }
                                            else {
                                                usedIds.add(id);
                                            }
                                            monitor.step();
                                        }
                                        finder.setEnabled(true);
                                        dlg.close();
                                        if (someoneFixed) {
                                            await finder.preload(monitor);
                                        }
                                        else {
                                            alert("No scene files found with a duplicated ID.");
                                        }
                                    }
                                }
                            });
                            // clear scene thumbnail database
                            manager.add({
                                command: {
                                    id: commands.CMD_CLEAR_SCENE_THUMBNAIL_CACHE,
                                    name: "Clear Scene Thumbnail Cache",
                                    tooltip: "Clear the thumbnail images cache.",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    executeFunc: args => {
                                        ui.SceneThumbnailCache.clearCache();
                                    }
                                }
                            });
                            // open scene file
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_SCENE_FILE,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Go To Scene",
                                    tooltip: "Quick dialog to open a scene file."
                                },
                                handler: {
                                    testFunc: args => colibri.Platform.getWorkbench().getActiveWindow() instanceof phasereditor2d.ide.ui.DesignWindow,
                                    executeFunc: args => {
                                        const dlg = new ui.dialogs.OpenSceneFileDialog();
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    control: true,
                                    alt: true,
                                    key: "KeyO"
                                }
                            });
                        }
                        static registerSnappingCommands(manager) {
                            // snapping
                            manager.add({
                                command: {
                                    id: commands.CMD_TOGGLE_SNAPPING,
                                    name: "Toggle Snapping",
                                    tooltip: "Enable/disable the snapping.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.toggleSnapping();
                                    }
                                },
                                keys: {
                                    key: "KeyE"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_SNAPPING_TO_OBJECT_SIZE,
                                    name: "Snap To Object Size",
                                    tooltip: "Enable snapping and set size to the selected object.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelectedGameObjects().length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.setSnappingToObjectSize();
                                    }
                                },
                                keys: {
                                    key: "KeyW"
                                }
                            });
                        }
                        static registerTextureCommands(manager) {
                            // texture
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_ALL_OBJECTS_SAME_TEXTURE,
                                    name: "Select All With Same Texture",
                                    tooltip: "Select all the objects with the same texture.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection()
                                            .filter(obj => ui.sceneobjects.isGameObject(obj)
                                            && ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TextureComponent))
                                            .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const textures = new Set();
                                        for (const obj of args.activeEditor.getSelection()) {
                                            const textureComponent = ui.sceneobjects.GameObjectEditorSupport
                                                .getObjectComponent(obj, ui.sceneobjects.TextureComponent);
                                            const keys = textureComponent.getTextureKeys();
                                            textures.add(JSON.stringify(keys));
                                        }
                                        const sel = [];
                                        editor.getScene().visitAll(obj => {
                                            const textureComponent = ui.sceneobjects.GameObjectEditorSupport
                                                .getObjectComponent(obj, ui.sceneobjects.TextureComponent);
                                            if (textureComponent) {
                                                const keys = textureComponent.getTextureKeys();
                                                if (textures.has(JSON.stringify(keys))) {
                                                    sel.push(obj);
                                                }
                                            }
                                        });
                                        editor.setSelection(sel);
                                    }
                                }
                            });
                            // change texture
                            manager.add({
                                command: {
                                    id: commands.CMD_REPLACE_TEXTURE,
                                    name: "Replace Texture",
                                    tooltip: "Change the texture of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection().length > 0
                                        && args.activeEditor.getSelection()
                                            .filter(obj => ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TextureComponent))
                                            .length > 0,
                                    executeFunc: args => {
                                        ui.sceneobjects.ChangeTextureOperation.runDialog(args.activeEditor);
                                    }
                                },
                                keys: {
                                    key: "KeyX"
                                }
                            });
                            // change texture frame
                            manager.add({
                                command: {
                                    id: commands.CMD_REPLACE_TEXTURE_FRAME,
                                    name: "Replace Texture Frame",
                                    tooltip: "Change the texture's frame of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection().length > 0
                                        && args.activeEditor.getSelection()
                                            .filter(obj => ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TextureComponent))
                                            .length === 1,
                                    executeFunc: args => {
                                        const obj = args.activeEditor.getSelection()[0];
                                        const comp = obj.getEditorSupport().getComponent(ui.sceneobjects.TextureComponent);
                                        const keys = comp.getTextureKeys();
                                        ui.sceneobjects.ChangeTextureOperation.runDialog(args.activeEditor, keys.key);
                                    }
                                },
                                keys: {
                                    key: "KeyM"
                                }
                            });
                        }
                        static registerSceneCommands(manager) {
                            // update current editor
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_UPDATE_CURRENT_EDITOR, args => args.activeEditor instanceof editor_11.SceneEditor, args => args.activeEditor.refreshScene());
                            manager.add({
                                command: {
                                    id: commands.CMD_DUPLICATE_SCENE_FILE,
                                    name: "Duplicate Scene File",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Duplicate the scene file, with a new ID.",
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: async (args) => {
                                        const editor = args.activeEditor;
                                        const file = editor.getInput();
                                        const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                                        const data = JSON.parse(content);
                                        data.id = Phaser.Utils.String.UUID();
                                        const newContent = JSON.stringify(data, null, 4);
                                        const newName = colibri.ui.ide.FileUtils.getFileCopyName(file);
                                        const newFile = await colibri.ui.ide.FileUtils.createFile_async(file.getParent(), newName, newContent);
                                        colibri.Platform.getWorkbench().openEditor(newFile);
                                    }
                                }
                            });
                        }
                        static registerSelectionCommands(manager) {
                            // select all
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_SELECT_ALL, args => args.activePart instanceof editor_11.SceneEditor, args => {
                                const editor = args.activeEditor;
                                editor.getSelectionManager().selectAll();
                            });
                            // clear selection
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_ESCAPE, args => {
                                if (controls.dialogs.Dialog.getActiveDialog()
                                    || controls.ColorPickerManager.isActivePicker()) {
                                    return false;
                                }
                                return isSceneScope(args);
                            }, args => {
                                const editor = args.activeEditor;
                                editor.getSelectionManager().clearSelection();
                            });
                        }
                        static registerEditCommands(manager) {
                            // copy
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_COPY, args => isSceneScope(args) && args.activeEditor.getSelection().length > 0, args => {
                                args.activeEditor.getClipboardManager().copy();
                            });
                            // paste
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_PASTE, args => isSceneScope(args), args => {
                                args.activeEditor.getClipboardManager().paste(false);
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_PASTE_IN_PLACE,
                                    category: colibri.ui.ide.actions.CAT_EDIT,
                                    name: "Paste In Place",
                                    tooltip: "Paste the objects in destiny at the same original locations.",
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args),
                                    executeFunc: args => args.activeEditor
                                        .getClipboardManager().paste(true),
                                },
                                keys: {
                                    control: true,
                                    shift: true,
                                    key: "KeyV"
                                }
                            });
                            // cut
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_CUT, args => isSceneScope(args) && args.activeEditor.getSelection().length > 0, args => {
                                args.activeEditor.getClipboardManager().cut();
                            });
                            // delete
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_DELETE, args => isSceneScope(args) && args.activeEditor.getSelection().length > 0 && noNestedPrefabSelected(args), args => args.activeEditor.getUndoManager()
                                .add(new editor_11.undo.DeleteOperation(args.activeEditor)));
                        }
                        static registerMoveObjectCommands(manager) {
                            class Operation extends editor_11.undo.SceneSnapshotOperation {
                                constructor(editor, dx, dy) {
                                    super(editor);
                                    this._dx = dx;
                                    this._dy = dy;
                                }
                                async performModification() {
                                    for (const obj of this._editor.getSelection()) {
                                        const sprite = obj;
                                        sprite.x += this._dx;
                                        sprite.y += this._dy;
                                    }
                                    this.getEditor().dispatchSelectionChanged();
                                }
                            }
                            const dxMap = {};
                            const dyMap = {};
                            const nameMap = {};
                            dxMap[commands.CMD_MOVE_OBJECT_LEFT] = -1;
                            dxMap[commands.CMD_MOVE_OBJECT_RIGHT] = 1;
                            dxMap[commands.CMD_MOVE_OBJECT_UP] = 0;
                            dxMap[commands.CMD_MOVE_OBJECT_DOWN] = 0;
                            dyMap[commands.CMD_MOVE_OBJECT_LEFT] = 0;
                            dyMap[commands.CMD_MOVE_OBJECT_RIGHT] = 0;
                            dyMap[commands.CMD_MOVE_OBJECT_UP] = -1;
                            dyMap[commands.CMD_MOVE_OBJECT_DOWN] = 1;
                            nameMap[commands.CMD_MOVE_OBJECT_LEFT] = "Left";
                            nameMap[commands.CMD_MOVE_OBJECT_RIGHT] = "Right";
                            nameMap[commands.CMD_MOVE_OBJECT_UP] = "Up";
                            nameMap[commands.CMD_MOVE_OBJECT_DOWN] = "Down";
                            for (const cmd of [commands.CMD_MOVE_OBJECT_LEFT, commands.CMD_MOVE_OBJECT_RIGHT, commands.CMD_MOVE_OBJECT_UP, commands.CMD_MOVE_OBJECT_DOWN]) {
                                for (const large of [true, false]) {
                                    manager.add({
                                        command: {
                                            id: cmd + (large ? "Large" : ""),
                                            category: commands.CAT_SCENE_EDITOR,
                                            name: "Move Object Position " + (large ? "10x " : "") + nameMap[cmd],
                                            tooltip: (large ? "10x " : "") + "Move selected objects position in the '" + nameMap[cmd] + "' direction"
                                        },
                                        handler: {
                                            testFunc: args => {
                                                if (!isSceneScope(args)) {
                                                    return false;
                                                }
                                                if (args.activeEditor.getSelection().length === 0) {
                                                    return false;
                                                }
                                                for (const obj of args.activeEditor.getSelection()) {
                                                    if (!ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TransformComponent)) {
                                                        return false;
                                                    }
                                                }
                                                return true;
                                            },
                                            executeFunc: args => {
                                                const editor = args.activeEditor;
                                                const settings = editor.getScene().getSettings();
                                                const dx = dxMap[cmd] * (large ? 10 : 1) * (settings.snapEnabled ? settings.snapWidth : 1);
                                                const dy = dyMap[cmd] * (large ? 10 : 1) * (settings.snapEnabled ? settings.snapHeight : 1);
                                                editor.getUndoManager().add(new Operation(editor, dx, dy));
                                            }
                                        },
                                        keys: {
                                            key: "Arrow" + nameMap[cmd],
                                            shift: large ? true : undefined
                                        }
                                    });
                                }
                            }
                        }
                        static registerParentCommands(manager) {
                            // join in layer
                            manager.add({
                                command: {
                                    id: commands.CMD_JOIN_IN_LAYER,
                                    name: "Create Layer With Selection",
                                    tooltip: "Create a layer with the selected objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        if (isSceneScope(args)) {
                                            const editor = args.activeEditor;
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const editorSupport = obj.getEditorSupport();
                                                if (editorSupport.isNestedPrefabInstance()) {
                                                    return false;
                                                }
                                                if (obj instanceof ui.sceneobjects.Layer) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.CreateLayerWithObjectsOperation(args.activeEditor))
                                }
                            });
                            // join in container
                            manager.add({
                                command: {
                                    id: commands.CMD_JOIN_IN_CONTAINER,
                                    name: "Create Container With Selection",
                                    tooltip: "Create a container with the selected objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        if (isSceneScope(args)) {
                                            const editor = args.activeEditor;
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                if (obj.getEditorSupport().isNestedPrefabInstance()) {
                                                    return false;
                                                }
                                                if (obj instanceof ui.sceneobjects.Layer) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.CreateContainerWithObjectsOperation(args.activeEditor))
                                },
                                keys: {
                                    key: "KeyJ"
                                }
                            });
                            // trim container
                            manager.add({
                                command: {
                                    id: commands.CMD_TRIM_CONTAINER,
                                    name: "Trim Container",
                                    tooltip: "Remove left/top margin of children.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isOnlyContainerSelected,
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.TrimContainerOperation(args.activeEditor))
                                },
                                keys: {
                                    key: "KeyT",
                                    shift: true
                                }
                            });
                            // break container
                            manager.add({
                                command: {
                                    id: commands.CMD_BREAK_PARENT,
                                    name: "Break Parent",
                                    tooltip: "Destroy container and re-parent children.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        return isSceneScope(args) && editorHasSelection(args)
                                            && args.activeEditor.getSelectedGameObjects()
                                                .filter(obj => obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer)
                                                .filter(obj => !obj.getEditorSupport().isPrefabInstance())
                                                .length === args.activeEditor.getSelection().length;
                                    },
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.BreakParentOperation(args.activeEditor))
                                },
                                keys: {
                                    key: "KeyB",
                                    shift: true
                                }
                            });
                            // select parent
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_PARENT,
                                    name: "Select Parent",
                                    tooltip: "Select the parent container",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args) && args.activeEditor
                                        .getSelectedGameObjects()
                                        .map(obj => ui.sceneobjects.getObjectParent(obj))
                                        .filter(parent => parent !== undefined && parent !== null)
                                        .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelectedGameObjects()
                                            .map(obj => ui.sceneobjects.getObjectParent(obj))
                                            .filter(parent => parent !== undefined && parent !== null);
                                        editor.setSelection(sel);
                                    }
                                },
                                keys: {
                                    key: "KeyP"
                                }
                            });
                            // select children
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_CHILDREN,
                                    name: "Select Children",
                                    tooltip: "Select the children",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args) && args.activeEditor
                                        .getSelection()
                                        .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelection()
                                            .flatMap(obj => ui.sceneobjects.GameObjectEditorSupport.getObjectChildren(obj))
                                            .filter(obj => {
                                            const editorSupport = obj.getEditorSupport();
                                            if (editorSupport.isMutableNestedPrefabInstance()) {
                                                return true;
                                            }
                                            if (editorSupport.isPrefabInstanceElement()) {
                                                return false;
                                            }
                                            return true;
                                        });
                                        editor.setSelection(sel);
                                    }
                                },
                                keys: {
                                    key: "KeyN"
                                }
                            });
                            // move to parent
                            manager.add({
                                command: {
                                    id: commands.CMD_MOVE_TO_PARENT,
                                    name: "Move To Parent",
                                    tooltip: "Re-parent the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        const editor = args.activeEditor;
                                        if (isSceneScope(args) && editorHasSelection(args)) {
                                            for (const obj of editor.getSelection()) {
                                                if (ui.sceneobjects.isGameObject(obj)) {
                                                    if (obj
                                                        .getEditorSupport().isNestedPrefabInstance()) {
                                                        return false;
                                                    }
                                                    if (obj instanceof ui.sceneobjects.Layer) {
                                                        return false;
                                                    }
                                                }
                                                else {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const dlg = new ui.sceneobjects.ParentDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    shift: true,
                                    key: "KeyP"
                                }
                            });
                        }
                        static registerTypeCommands(manager) {
                            // change type dialog
                            manager.add({
                                command: {
                                    id: commands.CMD_CONVERT_OBJECTS,
                                    name: "Replace Type",
                                    tooltip: "Replace the type of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && editor_11.ConvertTypeDialog.canConvert(args.activeEditor),
                                    executeFunc: args => {
                                        const dlg = new editor.ConvertTypeDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                }
                            });
                            // change type to tile sprite
                            manager.add({
                                command: {
                                    id: commands.CMD_CONVERT_TO_TILE_SPRITE_OBJECTS,
                                    name: "Convert To TileSprite",
                                    tooltip: "Convert the selected objects into TileSprite instances. Or resize it if it is a TileSprite.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && editor_11.ConvertTypeDialog.canConvert(args.activeEditor),
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getUndoManager().add(new editor_11.undo.ConvertTypeOperation(editor, ui.sceneobjects.TileSpriteExtension.getInstance()));
                                    }
                                },
                                keys: {
                                    key: "KeyL"
                                }
                            });
                            // open prefab
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_PREFAB,
                                    name: "Open Prefab",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Open the Prefab file of the selected prefab instance."
                                },
                                handler: {
                                    testFunc: args => {
                                        if (!isSceneScope(args)) {
                                            return false;
                                        }
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelectedGameObjects();
                                        for (const obj of sel) {
                                            if (!obj.getEditorSupport().isPrefabInstance()) {
                                                return false;
                                            }
                                        }
                                        return true;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelectedGameObjects();
                                        for (const obj of sel) {
                                            const file = obj.getEditorSupport().getPrefabFile();
                                            if (file) {
                                                colibri.Platform.getWorkbench().openEditor(file);
                                            }
                                        }
                                    }
                                },
                                keys: {
                                    key: "KeyF"
                                }
                            });
                            // create prefab
                            manager.add({
                                command: {
                                    id: commands.CMD_CREATE_PREFAB_WITH_OBJECT,
                                    name: "Create Prefab With Object",
                                    tooltip: "Create a new prefab file with the selected object.",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    testFunc: args => {
                                        if (!isSceneScope(args)) {
                                            return false;
                                        }
                                        const sel = args.activeEditor.getSelection();
                                        if (sel.length !== 1) {
                                            return false;
                                        }
                                        const obj = sel[0];
                                        return ui.sceneobjects.isGameObject(obj);
                                    },
                                    executeFunc: args => {
                                        const obj = args.activeEditor.getSelection()[0];
                                        const objData = {
                                            unlock: ["x", "y"]
                                        };
                                        obj.getEditorSupport().writeJSON(objData);
                                        objData.id = Phaser.Utils.String.UUID();
                                        objData["x"] = 0;
                                        objData["y"] = 0;
                                        const ext = new ui.dialogs.NewPrefabFileFromObjectDialogExtension(objData);
                                        ext.setOpenInEditor(false);
                                        ext.setCreatedCallback(newFile => {
                                            const editor = args.activeEditor;
                                            editor.getUndoManager().add(new editor_11.undo.ConvertTypeOperation(editor, newFile));
                                            editor.refreshBlocks();
                                        });
                                        const dlg = ext.createDialog({
                                            initialFileLocation: args.activeEditor.getInput().getParent()
                                        });
                                        dlg.setTitle("New Prefab File");
                                    }
                                }
                            });
                            // quick source edit
                            manager.add({
                                command: {
                                    id: commands.CMD_QUICK_EDIT_OUTPUT_FILE,
                                    name: "Quick Edit Output File",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Shortcut to edit the compiled code in a popup editor."
                                },
                                handler: {
                                    testFunc: args => args.activeEditor instanceof editor_11.SceneEditor,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.openOutputFileQuickEditorDialog();
                                    }
                                },
                                keys: {
                                    key: "KeyQ"
                                }
                            });
                            if (phasereditor2d.ide.IDEPlugin.getInstance().isDesktopMode()) {
                                const editorName = phasereditor2d.ide.IDEPlugin.getInstance().getExternalEditorName();
                                manager.add({
                                    command: {
                                        id: commands.CMD_OPEN_OUTPUT_FILE_IN_VSCODE,
                                        name: "Open Output File in " + editorName,
                                        category: commands.CAT_SCENE_EDITOR,
                                        tooltip: "Open the compiler output file in the configured external editor (" + editorName + ")"
                                    },
                                    handler: {
                                        testFunc: args => args.activeEditor instanceof editor_11.SceneEditor,
                                        executeFunc: args => {
                                            const editor = args.activeEditor;
                                            const file = editor.getOutputFile();
                                            if (file) {
                                                phasereditor2d.ide.IDEPlugin.getInstance().openFileExternalEditor(file);
                                            }
                                            else {
                                                alert(`Output from "${editor.getInput().getProjectRelativeName()}" not found.`);
                                            }
                                        }
                                    }, keys: {
                                        control: true,
                                        alt: true,
                                        key: "KeyE"
                                    }
                                });
                            }
                        }
                        static registerCompilerCommands(manager) {
                            // open compiled file
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_COMPILED_FILE,
                                    icon: phasereditor2d.webContentTypes.WebContentTypesPlugin.getInstance().getIcon(phasereditor2d.webContentTypes.ICON_FILE_SCRIPT),
                                    name: "Open Output File",
                                    tooltip: "Open the output source file of the scene.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => args.activeEditor instanceof editor_11.SceneEditor,
                                    executeFunc: args => args.activeEditor.openSourceFileInEditor()
                                }
                            });
                            // compile scene editor
                            manager.add({
                                command: {
                                    id: commands.CMD_COMPILE_SCENE_EDITOR,
                                    icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BUILD),
                                    name: "Compile Scene",
                                    tooltip: "Compile the editor's Scene.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => args.activeEditor instanceof editor_11.SceneEditor,
                                    executeFunc: args => args.activeEditor.compile(),
                                }
                            });
                        }
                        static registerToolsCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_TRANSLATE_SCENE_OBJECT,
                                    name: "Translate Tool",
                                    icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_TRANSLATE),
                                    tooltip: "Translate the selected scene objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.TranslateTool.ID)
                                },
                                keys: {
                                    key: "KeyT"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_ROTATE_SCENE_OBJECT,
                                    name: "Rotate Tool",
                                    icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ANGLE),
                                    tooltip: "Rotate the selected scene objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.RotateTool.ID)
                                },
                                keys: {
                                    key: "KeyR"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SCALE_SCENE_OBJECT,
                                    name: "Scale Tool",
                                    icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_SCALE),
                                    tooltip: "Scale the selected scene objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.ScaleTool.ID)
                                },
                                keys: {
                                    key: "KeyS"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_ORIGIN_SCENE_OBJECT,
                                    name: "Origin Tool",
                                    icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ORIGIN),
                                    tooltip: "Change the origin of the selected scene object",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.OriginTool.ID)
                                },
                                keys: {
                                    key: "KeyO"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_REGION,
                                    name: "Select Region Tool",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Select all objects inside a region",
                                    icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_SELECT_REGION)
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.SelectionRegionTool.ID)
                                },
                                keys: {
                                    shift: true,
                                    key: "KeyS"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_PAN_SCENE,
                                    name: "Pan Tool",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Pan the scene viewport"
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getToolsManager().swapTool(ui.sceneobjects.PanTool.ID);
                                    }
                                },
                                keys: {
                                    key: "Space"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_RESIZE_SCENE_OBJECT,
                                    name: "Resize Tool",
                                    tooltip: "Resize selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.SizeTool.ID)
                                },
                                keys: {
                                    key: "KeyZ"
                                }
                            });
                        }
                        static registerVisibilityCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_TOGGLE_VISIBLE,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Toggle Visibility",
                                    tooltip: "Toggle the visible property of the object"
                                },
                                handler: {
                                    testFunc: e => {
                                        if (!isSceneScope(e)) {
                                            return false;
                                        }
                                        const sel = e.activeEditor.getSelection();
                                        for (const obj of sel) {
                                            if (!ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.VisibleComponent)) {
                                                return false;
                                            }
                                        }
                                        return sel.length > 0;
                                    },
                                    executeFunc: async (e) => {
                                        let visible = false;
                                        const sel = e.activeEditor.getSelection();
                                        for (const obj of sel) {
                                            const objVisible = ui.sceneobjects.VisibleComponent.visible.getValue(obj);
                                            if (objVisible) {
                                                visible = true;
                                                break;
                                            }
                                        }
                                        const editor = e.activeEditor;
                                        const unlocked = await editor.confirmUnlockProperty([ui.sceneobjects.VisibleComponent.visible], "Visible", ui.sceneobjects.VisibleSection.SECTION_ID);
                                        if (unlocked) {
                                            editor.getUndoManager().add(new ui.sceneobjects.SimpleOperation(editor, sel, ui.sceneobjects.VisibleComponent.visible, !visible));
                                        }
                                    }
                                },
                                keys: {
                                    key: "KeyV"
                                }
                            });
                        }
                        static registerDepthCommands(manager) {
                            for (const tuple of [["Up", "PageUp"], ["Down", "PageDown"], ["Top", "Home"], ["Bottom", "End"]]) {
                                const move = tuple[0];
                                const key = tuple[1];
                                manager.add({
                                    command: {
                                        id: "phasereditor2d.scene.ui.editor.commands.Depth" + move,
                                        name: "Move Object Depth " + move,
                                        category: commands.CAT_SCENE_EDITOR,
                                        tooltip: "Move the object in its container to " + move + "."
                                    },
                                    handler: {
                                        testFunc: args => isSceneScope(args) && args.activeEditor.getSelection().length > 0,
                                        executeFunc: args => args.activeEditor.getUndoManager().add(new editor_11.undo.DepthOperation(args.activeEditor, move))
                                    },
                                    keys: {
                                        key
                                    }
                                });
                            }
                        }
                        static computeOriginCommandData() {
                            const values = [
                                { x: 0, y: 0, k: 7, n: "Top/Left" },
                                { x: 0.5, y: 0, k: 8, n: "Top/Center" },
                                { x: 1, y: 0, k: 9, n: "Top/Right" },
                                { x: 0, y: 0.5, k: 4, n: "Middle/Left" },
                                { x: 0.5, y: 0.5, k: 5, n: "Middle/Center" },
                                { x: 1, y: 0.5, k: 6, n: "Middle/Right" },
                                { x: 0, y: 1, k: 1, n: "Bottom/Left" },
                                { x: 0.5, y: 1, k: 2, n: "Bottom/Center" },
                                { x: 1, y: 1, k: 3, n: "Bottom/Right" },
                            ];
                            return values.map(value => {
                                return {
                                    command: "phasereditor2d.scene.ui.editor.commands.SetOrigin_" + value.n + "_ToObject",
                                    name: "Set Origin To " + value.n,
                                    x: value.x,
                                    y: value.y,
                                    key: "Numpad" + value.k,
                                    keyLabel: "Numpad " + value.k
                                };
                            });
                        }
                        static registerOriginCommands(manager) {
                            const originProperty = {
                                name: "origin",
                                defValue: undefined,
                                getValue: obj => ({ x: obj.originX, y: obj.originY }),
                                setValue: (obj, value) => {
                                    // obj.setOrigin(value.x, value.y);
                                    ui.sceneobjects.OriginToolItem
                                        .simpleChangeOriginKeepPosition(obj, value.x, value.y);
                                }
                            };
                            for (const data of this.computeOriginCommandData()) {
                                manager.add({
                                    command: {
                                        id: data.command,
                                        name: data.name,
                                        tooltip: `Set the origin of the object to (${data.x},${data.y})`,
                                        category: commands.CAT_SCENE_EDITOR
                                    },
                                    keys: {
                                        key: data.key,
                                        keyLabel: data.keyLabel,
                                        control: true,
                                    },
                                    handler: {
                                        testFunc: args => {
                                            if (!isSceneScope(args)) {
                                                return false;
                                            }
                                            const sel = args.activeEditor.getSelection();
                                            const len = sel
                                                .filter(obj => ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.OriginComponent))
                                                .length;
                                            return len > 0 && len === sel.length;
                                        },
                                        executeFunc: async (args) => {
                                            const editor = args.activeEditor;
                                            const objects = editor.getSelectedGameObjects()
                                                .filter(obj => ui.sceneobjects.GameObjectEditorSupport
                                                .hasObjectComponent(obj, ui.sceneobjects.OriginComponent));
                                            const unlocked = await editor.confirmUnlockProperty([
                                                ui.sceneobjects.OriginComponent.originX,
                                                ui.sceneobjects.OriginComponent.originY
                                            ], "Origin", ui.sceneobjects.OriginSection.SECTION_ID);
                                            if (unlocked) {
                                                editor.getUndoManager().add(new ui.sceneobjects.SimpleOperation(args.activeEditor, objects, originProperty, {
                                                    x: data.x,
                                                    y: data.y
                                                }));
                                            }
                                        }
                                    },
                                });
                            }
                        }
                    }
                    commands.SceneEditorCommands = SceneEditorCommands;
                })(commands = editor_11.commands || (editor_11.commands = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_12) {
                var layout;
                (function (layout) {
                    class LayoutExtension extends colibri.Extension {
                        constructor(config) {
                            super(LayoutExtension.POINT_ID);
                            this._config = config;
                        }
                        getConfig() {
                            return this._config;
                        }
                        async performLayout(editor) {
                            const params = await editor.getLayoutToolsManager().showParametersPane(this);
                            const transform = ui.sceneobjects.TransformComponent;
                            const sprites = editor.getSelectedGameObjects()
                                .filter(obj => obj.getEditorSupport().hasComponent(transform));
                            const unlocked = await editor.confirmUnlockProperty([
                                transform.x,
                                transform.y,
                            ], "position", ui.sceneobjects.TransformSection.SECTION_ID);
                            if (!unlocked) {
                                return;
                            }
                            const positions = sprites.map(obj => {
                                if (obj instanceof ui.sceneobjects.Container) {
                                    const b = obj.getBounds();
                                    const originX = (obj.x - b.x) / b.width;
                                    const originY = (obj.y - b.y) / b.height;
                                    return {
                                        x: obj.x - originX * b.width,
                                        y: obj.y - originY * b.height,
                                        size: {
                                            x: b.width,
                                            y: b.height
                                        }
                                    };
                                }
                                const sprite = obj;
                                const { displayOriginX, displayOriginY } = obj.getEditorSupport().computeDisplayOrigin();
                                return {
                                    x: sprite.x - displayOriginX,
                                    y: sprite.y - displayOriginY,
                                    size: {
                                        x: sprite.displayWidth,
                                        y: sprite.displayHeight
                                    }
                                };
                            });
                            const spritePosMap = new Map();
                            for (let i = 0; i < sprites.length; i++) {
                                spritePosMap.set(sprites[i], positions[i]);
                            }
                            const settings = editor.getScene().getSettings();
                            const border = {
                                x: settings.borderX,
                                y: settings.borderY,
                                size: {
                                    x: settings.borderWidth,
                                    y: settings.borderHeight
                                }
                            };
                            const op = new editor_12.undo.SimpleSceneSnapshotOperation(editor, () => {
                                this._config.action({ border, positions, params });
                                for (const obj of sprites) {
                                    const pos = spritePosMap.get(obj);
                                    if (obj instanceof ui.sceneobjects.Container) {
                                        const b = obj.getBounds();
                                        const originX = (obj.x - b.x) / b.width;
                                        const originY = (obj.y - b.y) / b.height;
                                        obj.x = pos.x + originX * b.width;
                                        obj.y = pos.y + originY * b.height;
                                    }
                                    else {
                                        const sprite = obj;
                                        const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                                        sprite.x = pos.x + displayOriginX;
                                        sprite.y = pos.y + displayOriginY;
                                    }
                                }
                            });
                            editor.getUndoManager().add(op);
                        }
                    }
                    LayoutExtension.POINT_ID = "phasereditor2d.scene.ui.editor.layout.LayoutExtension";
                    layout.LayoutExtension = LayoutExtension;
                })(layout = editor_12.layout || (editor_12.layout = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./LayoutExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var layout;
                (function (layout) {
                    function minValue(values) {
                        let min = Number.MAX_SAFE_INTEGER;
                        for (const v of values) {
                            min = Math.min(v, min);
                        }
                        return min;
                    }
                    layout.minValue = minValue;
                    function maxValue(values) {
                        let max = Number.MIN_SAFE_INTEGER;
                        for (const v of values) {
                            max = Math.max(v, max);
                        }
                        return max;
                    }
                    layout.maxValue = maxValue;
                    function avgValue(values) {
                        let total = 0;
                        for (const v of values) {
                            total += v;
                        }
                        return total / values.length;
                    }
                    layout.avgValue = avgValue;
                    function makeSimpleAxisAction(reduceFunc, axis) {
                        return (args) => {
                            const value = reduceFunc(args.positions.map(p => p[axis]));
                            for (const pos of args.positions) {
                                pos[axis] = value;
                            }
                        };
                    }
                    layout.makeSimpleAxisAction = makeSimpleAxisAction;
                    function makeBorderAction(axis, factor) {
                        return (args) => {
                            for (const pos of args.positions) {
                                pos[axis] = args.border[axis] + args.border.size[axis] * factor;
                            }
                        };
                    }
                    layout.makeBorderAction = makeBorderAction;
                    function makeAlignAction(axis, reduceFunc, origin) {
                        return (args) => {
                            const value = reduceFunc(args.positions.map(p => p[axis] + p.size[axis] * origin));
                            args.positions.forEach(pos => (pos[axis] = value - pos.size[axis] * origin));
                        };
                    }
                    layout.makeAlignAction = makeAlignAction;
                    function makeShiftAction(axis, origin) {
                        return (args) => {
                            const value = args.border[axis] + args.border.size[axis] * origin;
                            args.positions.forEach(pos => (pos[axis] = value - pos.size[axis] * origin));
                        };
                    }
                    layout.makeShiftAction = makeShiftAction;
                    class DefaultLayoutExtensions {
                    }
                    // align
                    DefaultLayoutExtensions.ALIGN_LEFT = new layout.LayoutExtension({
                        name: "Left",
                        group: "Align",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ALIGN_LEFT),
                        action: makeAlignAction("x", minValue, 0)
                    });
                    DefaultLayoutExtensions.ALIGN_CENTER = new layout.LayoutExtension({
                        name: "Center",
                        group: "Align",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ALIGN_CENTER),
                        action: makeAlignAction("x", avgValue, 0.5)
                    });
                    DefaultLayoutExtensions.ALIGN_RIGHT = new layout.LayoutExtension({
                        name: "Right",
                        group: "Align",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ALIGN_RIGHT),
                        action: makeAlignAction("x", maxValue, 1)
                    });
                    DefaultLayoutExtensions.ALIGN_TOP = new layout.LayoutExtension({
                        name: "Top",
                        group: "Align",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ALIGN_TOP),
                        action: makeAlignAction("y", minValue, 0)
                    });
                    DefaultLayoutExtensions.ALIGN_MIDDLE = new layout.LayoutExtension({
                        name: "Middle",
                        group: "Align",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ALIGN_MIDDLE),
                        action: makeAlignAction("y", avgValue, 0.5)
                    });
                    DefaultLayoutExtensions.ALIGN_BOTTOM = new layout.LayoutExtension({
                        name: "Bottom",
                        group: "Align",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ALIGN_BOTTOM),
                        action: makeAlignAction("y", maxValue, 1)
                    });
                    // Shift To
                    DefaultLayoutExtensions.ALIGN_BORDER_LEFT = new layout.LayoutExtension({
                        name: "Border Left",
                        group: "Align To Border",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BORDER_LEFT),
                        action: makeShiftAction("x", 0)
                    });
                    DefaultLayoutExtensions.ALIGN_BORDER_CENTER = new layout.LayoutExtension({
                        name: "Border Center",
                        group: "Align To Border",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BORDER_CENTER),
                        action: makeShiftAction("x", 0.5)
                    });
                    DefaultLayoutExtensions.ALIGN_BORDER_RIGHT = new layout.LayoutExtension({
                        name: "Border Right",
                        group: "Align To Border",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BORDER_RIGHT),
                        action: makeShiftAction("x", 1)
                    });
                    DefaultLayoutExtensions.ALIGN_BORDER_TOP = new layout.LayoutExtension({
                        name: "Border Top",
                        group: "Align To Border",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BORDER_TOP),
                        action: makeShiftAction("y", 0)
                    });
                    DefaultLayoutExtensions.ALIGN_BORDER_MIDDLE = new layout.LayoutExtension({
                        name: "Border Middle",
                        group: "Align To Border",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BORDER_MIDDLE),
                        action: makeShiftAction("y", 0.5)
                    });
                    DefaultLayoutExtensions.ALIGN_BORDER_BOTTOM = new layout.LayoutExtension({
                        name: "Border Bottom",
                        group: "Align To Border",
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_BORDER_BOTTOM),
                        action: makeShiftAction("y", 1)
                    });
                    // grid
                    DefaultLayoutExtensions.STACK_HORIZONTAL = new layout.LayoutExtension({
                        name: "Row",
                        group: "Grid",
                        params: [{
                                name: "padding",
                                label: "Padding",
                                defaultValue: 0
                            }],
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_ROW),
                        action: args => {
                            args.positions.sort((a, b) => a.x - b.x);
                            const padding = args.params.padding;
                            const minX = minValue(args.positions.map(p => p.x));
                            const avgY = avgValue(args.positions.map(p => p.y));
                            let x = minX;
                            for (const pos of args.positions) {
                                pos.x = x;
                                pos.y = avgY;
                                x += pos.size.x + padding;
                            }
                        }
                    });
                    DefaultLayoutExtensions.STACK_VERTICAL = new layout.LayoutExtension({
                        name: "Column",
                        group: "Grid",
                        params: [{
                                name: "padding",
                                label: "Padding",
                                defaultValue: 0
                            }],
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_COLUMN),
                        action: args => {
                            args.positions.sort((a, b) => a.y - b.y);
                            const padding = args.params.padding;
                            const avgX = avgValue(args.positions.map(p => p.x));
                            const minY = minValue(args.positions.map(p => p.y));
                            let y = minY;
                            for (const pos of args.positions) {
                                pos.x = avgX;
                                pos.y = y;
                                y += pos.size.y + padding;
                            }
                        }
                    });
                    DefaultLayoutExtensions.ROWS_AND_COLUMNS = new layout.LayoutExtension({
                        name: "Grid",
                        group: "Grid",
                        params: [{
                                name: "cols",
                                label: "Columns",
                                defaultValue: 3
                            }, {
                                name: "padding",
                                label: "Padding",
                                defaultValue: 0
                            }, {
                                name: "cellWidth",
                                label: "Cell Width",
                                defaultValue: 0
                            }, {
                                name: "cellHeight",
                                label: "Cell Height",
                                defaultValue: 0
                            }],
                        icon: scene.ScenePlugin.getInstance().getIcon(scene.ICON_GRID),
                        action: args => {
                            const minX = minValue(args.positions.map(p => p.x));
                            const minY = minValue(args.positions.map(p => p.y));
                            let cols = args.params.cols;
                            let cellWidth = args.params.cellWidth;
                            let cellHeight = args.params.cellHeight;
                            const padding = args.params.padding;
                            if (cellWidth === 0) {
                                cellWidth = maxValue(args.positions.map(p => p.size.x));
                            }
                            if (cellHeight === 0) {
                                cellHeight = maxValue(args.positions.map(p => p.size.y));
                            }
                            cellWidth += padding;
                            cellHeight += padding;
                            let x = minX;
                            let y = minY;
                            let currentCol = 0;
                            const processed = new Set();
                            const findCloserPosition = (x, y) => {
                                let result;
                                let min = Number.MAX_SAFE_INTEGER;
                                for (const pos of args.positions) {
                                    if (processed.has(pos)) {
                                        continue;
                                    }
                                    const d = Phaser.Math.Distance.Between(x, y, pos.x + pos.size.x / 2, pos.y + pos.size.y / 2);
                                    if (d < min) {
                                        result = pos;
                                        min = d;
                                    }
                                }
                                return result;
                            };
                            while (processed.size < args.positions.length) {
                                const pos = findCloserPosition(x + cellWidth / 2, y + cellHeight / 2);
                                processed.add(pos);
                                pos.x = x + cellWidth / 2 - pos.size.x / 2;
                                pos.y = y + cellHeight / 2 - pos.size.y / 2;
                                x += cellWidth;
                                currentCol++;
                                if (currentCol === cols) {
                                    currentCol = 0;
                                    x = minX;
                                    y += cellHeight;
                                }
                            }
                        }
                    });
                    DefaultLayoutExtensions.ALL = [
                        DefaultLayoutExtensions.ALIGN_LEFT,
                        DefaultLayoutExtensions.ALIGN_CENTER,
                        DefaultLayoutExtensions.ALIGN_RIGHT,
                        DefaultLayoutExtensions.ALIGN_TOP,
                        DefaultLayoutExtensions.ALIGN_MIDDLE,
                        DefaultLayoutExtensions.ALIGN_BOTTOM,
                        DefaultLayoutExtensions.ALIGN_BORDER_LEFT,
                        DefaultLayoutExtensions.ALIGN_BORDER_CENTER,
                        DefaultLayoutExtensions.ALIGN_BORDER_RIGHT,
                        DefaultLayoutExtensions.ALIGN_BORDER_TOP,
                        DefaultLayoutExtensions.ALIGN_BORDER_MIDDLE,
                        DefaultLayoutExtensions.ALIGN_BORDER_BOTTOM,
                        DefaultLayoutExtensions.STACK_HORIZONTAL,
                        DefaultLayoutExtensions.STACK_VERTICAL,
                        DefaultLayoutExtensions.ROWS_AND_COLUMNS
                    ];
                    layout.DefaultLayoutExtensions = DefaultLayoutExtensions;
                })(layout = editor.layout || (editor.layout = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_17) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_13) {
                var outline;
                (function (outline) {
                    class SceneEditorOutlineContentProvider {
                        constructor(editor) {
                            this._editor = editor;
                        }
                        getRoots(input) {
                            const scene = this._editor.getScene();
                            if (!scene) {
                                return [];
                            }
                            const displayList = scene.sys.displayList;
                            const roots = [];
                            if (displayList) {
                                roots.push(displayList);
                            }
                            roots.push(scene.getObjectLists());
                            roots.push(...scene_17.ScenePlugin.getInstance().getPlainObjectCategories());
                            return roots;
                        }
                        getChildren(parent) {
                            if (parent instanceof Phaser.GameObjects.DisplayList) {
                                const list = [...parent.getChildren()];
                                list.reverse();
                                return list;
                            }
                            else if (parent instanceof ui.sceneobjects.Container || parent instanceof ui.sceneobjects.Layer) {
                                const editorSupport = parent.getEditorSupport();
                                if (!editorSupport.isShowChildrenInOutline()) {
                                    return [];
                                }
                                if (editorSupport.isPrefabInstance()) {
                                    return editorSupport.getNestedActivePrefabInstances();
                                }
                                const list = [...parent.getChildren()];
                                list.reverse();
                                return list;
                            }
                            else if (parent instanceof ui.sceneobjects.ObjectLists) {
                                return parent.getLists();
                            }
                            else if (typeof parent === "string") {
                                return this._editor.getScene().getPlainObjectsByCategory(parent);
                            }
                            const extensions = scene_17.ScenePlugin.getInstance().getSceneEditorOutlineExtensions();
                            for (const ext of extensions) {
                                if (ext.isContentProviderFor(parent)) {
                                    return ext.getContentProvider().getChildren(parent);
                                }
                            }
                            return [];
                        }
                    }
                    outline.SceneEditorOutlineContentProvider = SceneEditorOutlineContentProvider;
                })(outline = editor_13.outline || (editor_13.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_17.ui || (scene_17.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    class SceneEditorOutlineExtension extends colibri.Extension {
                        constructor() {
                            super(SceneEditorOutlineExtension.POINT_ID);
                        }
                    }
                    SceneEditorOutlineExtension.POINT_ID = "phasereditor2d.scene.ui.editor.outline.SceneEditorOutlineProviderExtension";
                    outline.SceneEditorOutlineExtension = SceneEditorOutlineExtension;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineLabelProvider extends controls.viewers.LabelProviderFromStyledLabelProvider {
                        constructor() {
                            super(new outline.SceneEditorOutlineStyledLabelProvider());
                        }
                    }
                    outline.SceneEditorOutlineLabelProvider = SceneEditorOutlineLabelProvider;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_14) {
                var outline;
                (function (outline) {
                    var ide = colibri.ui.ide;
                    class SceneEditorOutlineProvider extends ide.EditorViewerProvider {
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        fillContextMenu(menu) {
                            this._editor.fillContextMenu(menu);
                        }
                        getUndoManager() {
                            return this._editor.getUndoManager();
                        }
                        getContentProvider() {
                            return new outline.SceneEditorOutlineContentProvider(this._editor);
                        }
                        getLabelProvider() {
                            return new outline.SceneEditorOutlineLabelProvider();
                        }
                        getStyledLabelProvider() {
                            return new outline.SceneEditorOutlineStyledLabelProvider();
                        }
                        getCellRendererProvider() {
                            return new outline.SceneEditorOutlineRendererProvider();
                        }
                        getTreeViewerRenderer(viewer) {
                            return new outline.SceneEditorOutlineViewerRenderer(viewer);
                        }
                        getPropertySectionProvider() {
                            return this._editor.getPropertyProvider();
                        }
                        getInput() {
                            return this._editor;
                        }
                        preload() {
                            return;
                        }
                        onViewerSelectionChanged(selection) {
                            this._editor.setSelection(selection, false);
                            this._editor.repaint();
                        }
                    }
                    outline.SceneEditorOutlineProvider = SceneEditorOutlineProvider;
                })(outline = editor_14.outline || (editor_14.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineRendererProvider {
                        getCellRenderer(element) {
                            const support = ui.sceneobjects.EditorSupport.getEditorSupport(element);
                            if (support) {
                                return support.getCellRenderer();
                            }
                            else if (element instanceof Phaser.GameObjects.DisplayList
                                || element instanceof ui.sceneobjects.ObjectLists
                                || typeof element === "string") {
                                return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                            }
                            else if (element instanceof ui.sceneobjects.ObjectList) {
                                return new controls.viewers.IconImageCellRenderer(scene.ScenePlugin.getInstance().getIcon(scene.ICON_LIST));
                            }
                            const extensions = scene.ScenePlugin.getInstance().getSceneEditorOutlineExtensions();
                            for (const ext of extensions) {
                                if (ext.isCellRendererProviderFor(element)) {
                                    return ext.getCellRendererProvider().getCellRenderer(element);
                                }
                            }
                            return new controls.viewers.EmptyCellRenderer(false);
                        }
                        async preload(args) {
                            return controls.Controls.resolveNothingLoaded();
                        }
                    }
                    outline.SceneEditorOutlineRendererProvider = SceneEditorOutlineRendererProvider;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineStyledLabelProvider {
                        getLabel(obj) {
                            if (ui.sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj)) {
                                const plainObject = obj;
                                return plainObject.getEditorSupport().getLabel();
                            }
                            if (ui.sceneobjects.isGameObject(obj)) {
                                const support = obj.getEditorSupport();
                                if (support.getScene().isPrefabSceneType() && obj === support.getScene().getPrefabObject()) {
                                    const file = support.getScene().getEditor().getInput();
                                    return `${file.getNameWithoutExtension()} (Prefab Object: ${support.isPrefabInstance() ? support.getPrefabName() : support.getObjectType()})`;
                                }
                                return support.getLabel();
                            }
                            else if (obj instanceof Phaser.GameObjects.DisplayList) {
                                return "Display List";
                            }
                            else if (obj instanceof ui.sceneobjects.ObjectLists) {
                                return "Lists";
                            }
                            else if (obj instanceof ui.sceneobjects.ObjectList) {
                                return obj.getLabel();
                            }
                            const extensions = scene.ScenePlugin.getInstance().getSceneEditorOutlineExtensions();
                            for (const ext of extensions) {
                                if (ext.isLabelProviderFor(obj)) {
                                    return ext.getLabelProvider().getLabel(obj);
                                }
                            }
                            return "" + obj;
                        }
                        getStyledTexts(obj, dark) {
                            const theme = controls.Controls.getTheme();
                            const baseLabel = this.getLabel(obj);
                            if (ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.VisibleComponent)) {
                                const visible = ui.sceneobjects.VisibleComponent.visible.getValue(obj);
                                if (!visible) {
                                    return [
                                        {
                                            text: baseLabel,
                                            color: theme.viewerForeground
                                        },
                                        {
                                            text: " (hidden)",
                                            color: theme.viewerForeground + "90"
                                        }
                                    ];
                                }
                            }
                            if (ui.sceneobjects.isGameObject(obj)) {
                                const support = obj.getEditorSupport();
                                if (support.isNestedPrefabInstance()) {
                                    return [
                                        {
                                            text: baseLabel,
                                            color: theme.viewerForeground
                                        },
                                        {
                                            text: ":nested",
                                            color: theme.viewerForeground + "90"
                                        }
                                    ];
                                }
                                else if (support.isPrefabInstance()) {
                                    return [
                                        {
                                            text: baseLabel,
                                            color: theme.viewerForeground
                                        },
                                        {
                                            text: ":prefab",
                                            color: theme.viewerForeground + "90"
                                        }
                                    ];
                                }
                            }
                            return [{
                                    text: baseLabel,
                                    color: theme.viewerForeground
                                }];
                        }
                    }
                    outline.SceneEditorOutlineStyledLabelProvider = SceneEditorOutlineStyledLabelProvider;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineViewerRenderer extends controls.viewers.TreeViewerRenderer {
                        constructor(viewer) {
                            super(viewer, 48);
                        }
                        prepareContextForRenderCell(args) {
                            if (this.isNonTopPrefabObject(args.obj)) {
                                args.canvasContext.globalAlpha = 0.3;
                            }
                        }
                        isNonTopPrefabObject(obj) {
                            const support = ui.sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                            if (support) {
                                return support.getScene().isNonTopPrefabObject(obj);
                            }
                            return false;
                        }
                        prepareContextForText(args) {
                            if (ui.sceneobjects.isGameObject(args.obj)) {
                                const obj = args.obj;
                                if (obj.getEditorSupport().isPrefabInstance()) {
                                    args.canvasContext.font = `italic ${controls.getCanvasFontHeight()}px ${controls.FONT_FAMILY}`;
                                }
                            }
                            if (this.isNonTopPrefabObject(args.obj)) {
                                args.canvasContext.globalAlpha = 0.3;
                            }
                            super.prepareContextForText(args);
                        }
                    }
                    outline.SceneEditorOutlineViewerRenderer = SceneEditorOutlineViewerRenderer;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class BaseSceneSection extends colibri.ui.controls.properties.PropertySection {
                        getHelp(key) {
                            return "";
                        }
                        getSectionHelpPath() {
                            return undefined;
                        }
                        createMenu(menu) {
                            const path = this.getSectionHelpPath();
                            if (path) {
                                phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, path);
                            }
                        }
                        hasMenu() {
                            return true;
                        }
                        createToolMenuItem(menu, toolId) {
                            const manager = this.getEditor().getToolsManager();
                            const tool = manager.findTool(toolId);
                            menu.addCommand(tool.getCommandId(), {
                                selected: tool === manager.getActiveTool()
                            });
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                        getUndoManager() {
                            return this.getEditor().getUndoManager();
                        }
                    }
                    properties.BaseSceneSection = BaseSceneSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_15) {
                var properties;
                (function (properties) {
                    class SceneSection extends properties.BaseSceneSection {
                        getScene() {
                            return this.getSelection()[0];
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                        getSettings() {
                            return this.getScene().getSettings();
                        }
                        getHelp(key) {
                            return "TODO";
                        }
                        createStringField(comp, name, label, tooltip) {
                            const labelElement = this.createLabel(comp, label, tooltip);
                            const textElement = this.createText(comp);
                            this.addUpdater(() => {
                                textElement.value = this.getSettings()[name].toString();
                            });
                            textElement.addEventListener("change", e => {
                                const editor = this.getEditor();
                                editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                    editor: editor,
                                    props: [{
                                            name,
                                            value: textElement.value,
                                        }],
                                    repaint: true
                                }));
                            });
                            return {
                                label: labelElement,
                                text: textElement
                            };
                        }
                        createIntegerField(comp, name, label, tooltip) {
                            const labelElement = this.createLabel(comp, label, tooltip);
                            const textElement = this.createText(comp);
                            this.addUpdater(() => {
                                textElement.value = this.getSettings()[name].toString();
                            });
                            textElement.addEventListener("change", e => {
                                const editor = this.getEditor();
                                const value = this.parseNumberExpression(textElement, true);
                                if (isNaN(value)) {
                                    this.updateWithSelection();
                                }
                                else {
                                    editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                        editor: editor,
                                        props: [{
                                                name: name,
                                                value: value,
                                            }],
                                        repaint: true
                                    }));
                                }
                            });
                            return {
                                label: labelElement,
                                text: textElement
                            };
                        }
                        createMenuField(comp, getItems, name, label, tooltip) {
                            this.createLabel(comp, label, tooltip);
                            const btn = this.createMenuButton(comp, "-", getItems, value => {
                                const editor = this.getEditor();
                                editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                    editor: editor,
                                    props: [{
                                            name: name,
                                            value: value,
                                        }],
                                    repaint: true
                                }));
                            });
                            this.addUpdater(() => {
                                const item = getItems().find(i => i.value === this.getSettings()[name]);
                                btn.textContent = item ? item.name : "-";
                            });
                        }
                        createBooleanField(comp, name, label) {
                            const checkElement = this.createCheckbox(comp, label);
                            this.addUpdater(() => {
                                checkElement.checked = this.getSettings()[name];
                            });
                            checkElement.addEventListener("change", e => {
                                const editor = this.getEditor();
                                editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                    editor: editor,
                                    props: [{
                                            name: name,
                                            value: checkElement.checked,
                                        }],
                                    repaint: true
                                }));
                            });
                            return checkElement;
                        }
                    }
                    properties.SceneSection = SceneSection;
                })(properties = editor_15.properties || (editor_15.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class BorderSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.DisplaySection", "Border", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/border-properties.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto auto 1fr auto 1fr";
                            this.createLabel(comp, "Border");
                            this.createIntegerField(comp, "borderX", "X", "Scene border position (X)");
                            this.createIntegerField(comp, "borderY", "Y", "Scene border position (Y)");
                            this.createLabel(comp, "");
                            this.createIntegerField(comp, "borderWidth", "Width", "Scene border width");
                            this.createIntegerField(comp, "borderHeight", "Height", "Scene border height");
                        }
                    }
                    properties.BorderSection = BorderSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_16) {
                var undo;
                (function (undo) {
                    var ide = colibri.ui.ide;
                    class SceneEditorOperation extends ide.undo.Operation {
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        getEditor() {
                            return this._editor;
                        }
                        getScene() {
                            return this._editor.getScene();
                        }
                    }
                    undo.SceneEditorOperation = SceneEditorOperation;
                })(undo = editor_16.undo || (editor_16.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../undo/SceneEditorOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_17) {
                var properties;
                (function (properties) {
                    class ChangePrefabPropertiesOperation extends editor_17.undo.SceneEditorOperation {
                        constructor(editor, before, after) {
                            super(editor);
                            this._before = before;
                            this._after = after;
                        }
                        static snapshot(editor) {
                            const data = [];
                            editor.getScene().getPrefabUserProperties().writeJSON(data);
                            return data;
                        }
                        load(data) {
                            this.getEditor().getScene().getPrefabUserProperties().readJSON(data);
                            this.getEditor().setDirty(true);
                            this.getEditor().dispatchSelectionChanged();
                        }
                        undo() {
                            this.load(this._before);
                        }
                        redo() {
                            this.load(this._after);
                        }
                    }
                    properties.ChangePrefabPropertiesOperation = ChangePrefabPropertiesOperation;
                })(properties = editor_17.properties || (editor_17.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../undo/SceneEditorOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class ChangeSettingsPropertyOperation extends editor.undo.SceneEditorOperation {
                        constructor(args) {
                            super(args.editor);
                            this._props = args.props;
                            this._repaint = args.repaint;
                        }
                        async execute() {
                            const settings = this._editor.getScene().getSettings();
                            this._before = new Map();
                            this._after = new Map();
                            for (const prop of this._props) {
                                this._before.set(prop.name, settings[prop.name]);
                                this._after.set(prop.name, prop.value);
                            }
                            this.setValue(this._after);
                        }
                        setValue(value) {
                            const settings = this._editor.getScene().getSettings();
                            for (const prop of this._props) {
                                settings[prop.name] = value.get(prop.name);
                            }
                            this._editor.setSelection(this._editor.getSelection());
                            this._editor.setDirty(true);
                            if (this._repaint) {
                                this._editor.repaint();
                            }
                        }
                        undo() {
                            this.setValue(this._before);
                        }
                        redo() {
                            this.setValue(this._after);
                        }
                    }
                    properties.ChangeSettingsPropertyOperation = ChangeSettingsPropertyOperation;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class CompilerSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.CompilerSection", "Compiler General Settings", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/scene-compiler-general-settings.html";
                        }
                        createMenu(menu) {
                            this.getEditor().getMenuCreator().createCompilerMenu(menu);
                            menu.addSeparator();
                            super.createMenu(menu);
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            // this.createMenuField(
                            //     comp, [
                            //     {
                            //         name: "Scene",
                            //         value: core.json.SceneType.SCENE,
                            //     },
                            //     {
                            //         name: "Prefab",
                            //         value: core.json.SceneType.PREFAB,
                            //     }],
                            //     "sceneType", "Scene Type",
                            //     "If this is a regular scene or a prefab.");
                            this.createBooleanField(comp, "compilerEnabled", this.createLabel(comp, "Generate Code", "Compiles the scene into code."));
                            this.createMenuField(comp, () => [
                                {
                                    name: "JavaScript",
                                    value: scene.core.json.SourceLang.JAVA_SCRIPT,
                                },
                                {
                                    name: "TypeScript",
                                    value: scene.core.json.SourceLang.TYPE_SCRIPT
                                }
                            ], "compilerOutputLanguage", "Output Language", "The scene compiler output language.");
                            this.createBooleanField(comp, "javaScriptInitFieldsInConstructor", this.createLabel(comp, "Fields In Constructor (JS)", "Generate the initialization of the fields in the constructor. This is valid only when the output is JavaScript."));
                            this.createBooleanField(comp, "exportClass", this.createLabel(comp, "Export Class (ES Module)", "Export the generated class."));
                            this.createBooleanField(comp, "autoImport", this.createLabel(comp, "Auto Import (ES Module)", "Automatic import used classes like prefabs and user components."));
                            this.createStringField(comp, "superClassName", "Super Class", "The super class used for the scene. If it is blank (no-value) then use default value.");
                            this.createBooleanField(comp, "compilerInsertSpaces", this.createLabel(comp, "Insert Spaces", "Insert convert tabs to spaces"));
                            this.createIntegerField(comp, "compilerTabSize", "Tab Size", "The size of tabs, in spaces.");
                        }
                    }
                    properties.CompilerSection = CompilerSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class DocsSection extends editor.properties.BaseSceneSection {
                        constructor(page, id) {
                            super(page, id, "Documentation", true, false);
                            this._converter = new window["showdown"].Converter();
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 1);
                            comp.style.alignItems = "self-start";
                            const docElement = document.createElement("div");
                            docElement.style.height = "100%";
                            docElement.classList.add("UserSelectText");
                            comp.appendChild(docElement);
                            this.addUpdater(() => {
                                const help = this.getHelp();
                                const html = this._converter.makeHtml(help);
                                docElement.innerHTML = html;
                            });
                        }
                        hasMenu() {
                            return false;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                    }
                    properties.DocsSection = DocsSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class PrefabCompilerSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.PrefabCompilerSection", "Compiler Prefab Settings", false, true);
                        }
                        getSectionHelpPath() {
                            // TODO
                            return "scene-editor/scene-compiler-scene-settings.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            this.createBooleanField(comp, "generateAwakeHandler", this.createLabel(comp, "Generate Awake Handler", "Generate a handler for the 'scene-awake' event."));
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.getSceneType() === scene.core.json.SceneType.PREFAB;
                        }
                    }
                    properties.PrefabCompilerSection = PrefabCompilerSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class PrefabPropertiesSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.PrefabPropertiesSection", "Prefab Properties", false, true);
                            const self = this;
                            class SectionHelper extends properties.UserPropertiesSection {
                                getSectionHelpPath() {
                                    return self.getSectionHelpPath();
                                }
                                getUserProperties() {
                                    return self.getEditor().getScene().getPrefabUserProperties();
                                }
                                runOperation(action, updateSelection) {
                                    self.runOperation(action, updateSelection);
                                }
                                getSelection() {
                                    return self.getSelection();
                                }
                                canEdit(obj, n) {
                                    throw new Error("Method not implemented.");
                                }
                                canEditNumber(n) {
                                    throw new Error("Method not implemented.");
                                }
                            }
                            this._sectionHelper = new SectionHelper(page, "", "");
                        }
                        getSectionHelpPath() {
                            return "scene-editor/prefab-user-properties.html";
                        }
                        createForm(parent) {
                            this._sectionHelper.createForm(parent);
                            this.addUpdater(() => {
                                if (this.getEditor().getScene()) {
                                    this._sectionHelper.updateWithSelection();
                                }
                            });
                        }
                        runOperation(action, updateSelection = true) {
                            const theEditor = this.getEditor();
                            const before = editor.properties.ChangePrefabPropertiesOperation.snapshot(theEditor);
                            action(this.getScene().getPrefabUserProperties());
                            const after = editor.properties.ChangePrefabPropertiesOperation.snapshot(this.getEditor());
                            this.getEditor().getUndoManager()
                                .add(new properties.ChangePrefabPropertiesOperation(this.getEditor(), before, after));
                            theEditor.setDirty(true);
                            if (updateSelection) {
                                this.updateWithSelection();
                            }
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.isPrefabSceneType();
                        }
                    }
                    properties.PrefabPropertiesSection = PrefabPropertiesSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class SceneCompilerSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.SceneCompilerSection", "Compiler Scene Settings", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/scene-compiler-scene-settings.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            this.createStringField(comp, "sceneKey", "Scene Key", "The key of the scene. Used when the scene is loaded with the Phaser loader.");
                            this.createBooleanField(comp, "onlyGenerateMethods", this.createLabel(comp, "Only Generate Methods", "No class code is generated, only the \"create\" or \"preload\" methods."));
                            this.createStringField(comp, "createMethodName", "Create Method", "The name of the create method.");
                            this.createPreloadPackFilesField(comp);
                            this.createStringField(comp, "preloadMethodName", "Preload Method", "The name of the preload method. It may be empty.");
                        }
                        createPreloadPackFilesField(parent) {
                            this.createLabel(parent, "Preload Pack Files", "The Pack files to be loaded in this scene.");
                            const btn = this.createButton(parent, "0 selected", async (e) => {
                                const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.editor.properties.SceneCompilerSection.SelectPackDialog");
                                viewer.setLabelProvider(new phasereditor2d.files.ui.viewers.FileLabelProvider());
                                viewer.setCellRendererProvider(new phasereditor2d.files.ui.viewers.FileCellRendererProvider("tree"));
                                viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                                const finder = this.getEditor().getPackFinder();
                                viewer.setInput(finder.getPacks().map(pack => pack.getFile()));
                                viewer.setSelection(this.getSettings().preloadPackFiles
                                    .map(name => finder.getPacks().find(pack => pack.getFile().getFullName() === name))
                                    .filter(pack => pack !== null && pack !== undefined)
                                    .map(pack => pack.getFile()));
                                const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                                const selectionCallback = (files) => {
                                    const names = files.map(file => file.getFullName());
                                    this.getEditor().getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                        editor: this.getEditor(),
                                        props: [{
                                                name: "preloadPackFiles",
                                                value: names
                                            }],
                                        repaint: false
                                    }));
                                    this.updateWithSelection();
                                    dlg.close();
                                };
                                dlg.create();
                                dlg.setTitle("Select Pack Files");
                                const selectBtn = dlg.addButton("Select", () => {
                                    selectionCallback(viewer.getSelection());
                                });
                                selectBtn.textContent = "Select " + viewer.getSelection().length + " Files";
                                viewer.eventSelectionChanged.addListener(() => {
                                    selectBtn.textContent = "Select " + viewer.getSelection().length + " Files";
                                });
                                dlg.addButton("Clear", () => {
                                    viewer.setSelection([]);
                                });
                                dlg.addButton("Cancel", () => {
                                    dlg.close();
                                });
                                viewer.eventOpenItem.addListener(() => {
                                    selectionCallback([viewer.getSelection()[0]]);
                                });
                            });
                            this.addUpdater(() => {
                                const settings = this.getSettings();
                                btn.textContent = settings.preloadPackFiles.length + " selected";
                                const files = settings.preloadPackFiles;
                                const tooltip = files.length === 0 ? "Click to select the Asset Pack files."
                                    : files.map(f => `<code>${f}</code>`)
                                        .join("<br>");
                                controls.Tooltip.tooltip(btn, tooltip);
                            });
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.getSceneType() === scene.core.json.SceneType.SCENE;
                        }
                    }
                    properties.SceneCompilerSection = SceneCompilerSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_18) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class SceneEditorSectionProvider extends controls.properties.PropertySectionProvider {
                        constructor(editor) {
                            super("phasereditor2d.scene.ui.editor.properties.SceneEditorSectionProvider");
                            this._editor = editor;
                        }
                        getEmptySelectionObject() {
                            return this._editor.getScene();
                        }
                        addSections(page, sections) {
                            sections.push(new properties.SnappingSection(page), new properties.BorderSection(page), new properties.CompilerSection(page), new properties.SceneCompilerSection(page), new properties.PrefabCompilerSection(page), new properties.PrefabPropertiesSection(page));
                            const exts = colibri.Platform
                                .getExtensions(properties.SceneEditorPropertySectionExtension.POINT_ID);
                            for (const ext of exts) {
                                for (const provider of ext.getSectionProviders()) {
                                    sections.push(provider(page));
                                }
                            }
                        }
                    }
                    properties.SceneEditorSectionProvider = SceneEditorSectionProvider;
                })(properties = editor_18.properties || (editor_18.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class SceneEditorPropertySectionExtension extends colibri.Extension {
                        constructor(...sectionProviders) {
                            super(SceneEditorPropertySectionExtension.POINT_ID);
                            this._sectionProviders = sectionProviders;
                        }
                        getSectionProviders() {
                            return this._sectionProviders;
                        }
                    }
                    SceneEditorPropertySectionExtension.POINT_ID = "phasereditor2d.scene.ui.editor.properties.SceneEditorPropertySectionExtension";
                    properties.SceneEditorPropertySectionExtension = SceneEditorPropertySectionExtension;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class SnappingSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.SnappingSection", "Snapping");
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto auto 1fr auto 1fr";
                            {
                                const label = this.createLabel(comp, "Enabled", "Enable snapping");
                                label.style.gridColumn = "1 / span 2";
                                this.createBooleanField(comp, "snapEnabled", label)
                                    .style.gridColumn = "3 / span 3";
                            }
                            this.createLabel(comp, "Size");
                            this.createIntegerField(comp, "snapWidth", "Width", "Scene snapping width.");
                            this.createIntegerField(comp, "snapHeight", "Height", "Scene snapping height.");
                        }
                        getSectionHelpPath() {
                            return "scene-editor/snapping-properties.html";
                        }
                    }
                    properties.SnappingSection = SnappingSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties_1) {
                    var controls = colibri.ui.controls;
                    class UserPropertiesSection extends controls.properties.PropertySection {
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, this.getSectionHelpPath());
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent);
                            comp.style.gridTemplateColumns = "1fr";
                            this._propArea = this.createGridElement(comp, 2);
                            comp.appendChild(this._propArea);
                            const propTypes = scene.ScenePlugin.getInstance().createUserPropertyTypes();
                            const btn = this.createMenuButton(comp, "Add Property", () => propTypes.map(t => ({
                                name: t.getName() + " Property",
                                value: t.getId()
                            })), (typeId) => {
                                const newType = scene.ScenePlugin.getInstance().createUserPropertyType(typeId);
                                this.runOperation(userProps => {
                                    const prop = userProps.createProperty(newType);
                                    userProps.add(prop);
                                    this.setExpandedStateInStorage(prop, true);
                                }, true);
                            });
                            btn.style.gridColumn = "1 / span 2";
                            btn.style.justifySelf = "center";
                            this.addUpdater(() => {
                                this._propArea.innerHTML = "";
                                const properties = this.getUserProperties().getProperties();
                                for (const prop of properties) {
                                    const propPane = this.createGridElement(this._propArea, 2);
                                    propPane.style.gridColumn = "1 / span 2";
                                    const titleLabel = this.createTitlePanel(propPane, prop);
                                    this._propArea.appendChild(propPane);
                                    const info = prop.getInfo();
                                    this.simpleField(propPane, info, "name", "Name", "The property name. Like in 'speedMin'.");
                                    this.simpleField(propPane, info, "label", "Label", "The property display label. Like in 'Speed Min'.", () => {
                                        titleLabel.innerHTML = prop.getInfo().label;
                                    });
                                    this.simpleField(propPane, info, "tooltip", "Tooltip", "The property tooltip.");
                                    {
                                        this.createLabel(propPane, "Type", "The property type.");
                                        const text = this.createText(propPane, true);
                                        text.value = prop.getType().getName();
                                    }
                                    if (prop.getType() instanceof ui.sceneobjects.OptionPropertyType) {
                                        this.createOptionsField(propPane, prop);
                                    }
                                    else if (prop.getType().hasCustomPropertyType()) {
                                        this.createExpressionTypeField(propPane, prop);
                                    }
                                    {
                                        this.createLabel(propPane, "Default", "The property default value.");
                                        const propEditor = info.type.createEditorElement(() => {
                                            return prop.getInfo().defValue;
                                        }, value => {
                                            this.runOperation(() => {
                                                prop.getInfo().defValue = value;
                                                this.setExpandedStateInStorage(prop, true);
                                            }, true);
                                        });
                                        propPane.appendChild(propEditor.element);
                                        propEditor.update();
                                    }
                                    {
                                        const check = this.createCheckbox(propPane, this.createLabel(propPane, "Custom Definition", "The compiler delegates the property's definition to the user."));
                                        check.checked = prop.isCustomDefinition();
                                        check.addEventListener("change", e => {
                                            this.runOperation(() => {
                                                prop.getInfo().customDefinition = check.checked;
                                            }, false);
                                        });
                                    }
                                }
                            });
                        }
                        setExpandedStateInStorage(prop, value) {
                            window.localStorage[`PrefabPropertiesSection[${prop.getName()}].expanded`] = value;
                        }
                        getExpandedStateInStorage(prop) {
                            return window.localStorage[`PrefabPropertiesSection[${prop.getName()}].expanded`];
                        }
                        createTitlePanel(propPane, prop) {
                            const titlePanel = document.createElement("div");
                            titlePanel.classList.add("PropertySubTitlePanel");
                            this._propArea.insertBefore(titlePanel, propPane);
                            const collapsedIcon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_TREE_COLLAPSE);
                            const expandedIcon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_TREE_EXPAND);
                            const expanderControl = new controls.IconControl();
                            titlePanel.appendChild(expanderControl.getCanvas());
                            const titleLabel = this.createLabel(titlePanel, prop.getLabel());
                            titleLabel.classList.add("PropertySubTitleLabel");
                            const expanded = this.getExpandedStateInStorage(prop) === "true";
                            propPane.style.display = expanded ? "grid" : "none";
                            expanderControl.setIcon(expanded ? collapsedIcon : expandedIcon);
                            const expandListener = () => {
                                const expandIt = propPane.style.display === "none";
                                propPane.style.display = expandIt ? "grid" : "none";
                                this.setExpandedStateInStorage(prop, expandIt);
                                expanderControl.setIcon(expandIt ? collapsedIcon : expandedIcon);
                            };
                            expanderControl.getCanvas().addEventListener("click", expandListener);
                            titleLabel.addEventListener("click", expandListener);
                            this.createPropertiesMenu(titlePanel, prop);
                            return titleLabel;
                        }
                        createPropertiesMenu(titlePanel, prop) {
                            const icon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_SMALL_MENU));
                            icon.getCanvas().classList.add("IconButton");
                            titlePanel.appendChild(icon.getCanvas());
                            icon.getCanvas().addEventListener("click", e => {
                                const menu = new controls.Menu();
                                menu.addAction({
                                    text: "Move Up",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            if (i > 0) {
                                                const temp = list[i - 1];
                                                list[i - 1] = prop;
                                                list[i] = temp;
                                            }
                                        }, true);
                                    }
                                });
                                menu.addAction({
                                    text: "Move Down",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            if (i < list.length - 1) {
                                                const temp = list[i + 1];
                                                list[i + 1] = prop;
                                                list[i] = temp;
                                            }
                                        }, true);
                                    }
                                });
                                menu.addSeparator();
                                menu.addMenu(this.createMorphMenu(prop));
                                menu.addSeparator();
                                menu.addAction({
                                    text: "Delete",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            list.splice(i, 1);
                                        }, true);
                                    }
                                });
                                menu.createWithEvent(e);
                            });
                        }
                        createMorphMenu(prop) {
                            const menu = new controls.Menu("Change Type");
                            const propTypes = scene.ScenePlugin.getInstance().createUserPropertyTypes();
                            for (const propType of propTypes) {
                                menu.addAction({
                                    text: propType.getName(),
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            prop.getInfo().type = propType;
                                        }, true);
                                    }
                                });
                            }
                            // const btn = this.createMenuButton(comp, "Add Property", propTypes.map(t => ({
                            //     name: t.getName() + " Property",
                            //     value: t.getId()
                            // })), (typeId: string) => {
                            //     const newType = ScenePlugin.getInstance().createUserPropertyType(typeId);
                            //     this.runOperation(userProps => {
                            //         const prop = userProps.createProperty(newType);
                            //         userProps.add(prop);
                            //         this.setExpandedStateInStorage(prop, true);
                            //     }, true);
                            // });
                            return menu;
                        }
                        createExpressionTypeField(parent, prop) {
                            const type = prop.getType();
                            this.createLabel(parent, "Expression Type", "The type of the expression. Like <code>'ICustomType'</code> or <code>'() => void'</code>.");
                            const text = this.createText(parent);
                            text.value = type.getExpressionType();
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    type.setExpressionType(text.value);
                                    this.setExpandedStateInStorage(prop, true);
                                }, true);
                            });
                        }
                        createOptionsField(parent, prop) {
                            const type = prop.getType();
                            this.createLabel(parent, "Options", "An array of possible string values, like in <code>['good', 'bad', 'ugly']</code>.");
                            const text = this.createTextArea(parent);
                            text.value = JSON.stringify(type.getOptions());
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    const array = JSON.parse(text.value);
                                    if (Array.isArray(array)) {
                                        const array2 = array.filter(v => typeof v === "string" || typeof v === "number")
                                            .map(v => v.toString());
                                        type.setOptions(array2);
                                    }
                                    this.setExpandedStateInStorage(prop, true);
                                }, true);
                            });
                        }
                        simpleField(parent, propInfo, infoProp, fieldLabel, fieldTooltip, updateCallback) {
                            this.createLabel(parent, fieldLabel, fieldTooltip);
                            const text = this.createText(parent);
                            text.value = propInfo[infoProp];
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    propInfo[infoProp] = text.value;
                                    if (updateCallback) {
                                        updateCallback();
                                    }
                                }, false);
                            });
                        }
                    }
                    properties_1.UserPropertiesSection = UserPropertiesSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class SceneToolItem {
                        isValidFor(objects) {
                            return true;
                        }
                        getTranslationInAxisWorldDelta(axis, initCursorX, initCursorY, args) {
                            const dx = args.x - initCursorX;
                            const dy = args.y - initCursorY;
                            let worldDx = dx / args.camera.zoom;
                            let worldDy = dy / args.camera.zoom;
                            const rot = Phaser.Math.DegToRad(this.getAvgGlobalAngle(args));
                            const worldDelta = new Phaser.Math.Vector2();
                            const xAxis = axis === "x" || axis === "xy" ? 1 : 0;
                            const yAxis = axis === "y" || axis === "xy" ? 1 : 0;
                            if (args.localCoords && axis !== "xy") {
                                const axisVector = new Phaser.Math.Vector2(xAxis, yAxis);
                                axisVector.rotate(rot);
                                let worldDeltaVector = new Phaser.Math.Vector2(worldDx, worldDy);
                                const projectionLength = worldDeltaVector.dot(axisVector);
                                worldDeltaVector = axisVector.clone().scale(projectionLength);
                                worldDx = worldDeltaVector.x;
                                worldDy = worldDeltaVector.y;
                                worldDelta.add(worldDeltaVector);
                                return worldDeltaVector;
                            }
                            return new Phaser.Math.Vector2(worldDx * xAxis, worldDy * yAxis);
                        }
                        getSimpleTranslationPoint(axis, args) {
                            const { x, y } = this.getAvgScreenPointOfObjects(args);
                            const xAxis = axis === "x" || axis === "xy" ? 1 : 0;
                            const yAxis = axis === "y" || axis === "xy" ? 1 : 0;
                            const axisVector = new Phaser.Math.Vector2(xAxis, yAxis);
                            if (args.localCoords) {
                                const angle = this.getAvgGlobalAngle(args);
                                axisVector.rotate(Phaser.Math.DegToRad(angle));
                            }
                            axisVector.scale(100);
                            if (axis === "xy") {
                                return { x, y };
                            }
                            return {
                                x: x + axisVector.x,
                                y: y + axisVector.y
                            };
                        }
                        renderSimpleAxis(axis, centerX, centerY, dotColor, args) {
                            const ctx = args.canvasContext;
                            ctx.strokeStyle = "#000";
                            if (axis === "xy") {
                                ctx.save();
                                ctx.translate(centerX, centerY);
                                this.drawCircle(ctx, args.canEdit ? dotColor : editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                                ctx.restore();
                            }
                            else {
                                ctx.save();
                                ctx.translate(centerX, centerY);
                                if (args.localCoords) {
                                    const angle = this.getAvgGlobalAngle(args);
                                    ctx.rotate(Phaser.Math.DegToRad(angle));
                                }
                                if (axis === "y") {
                                    ctx.rotate(Math.PI / 2);
                                }
                                this.drawArrowPath(ctx, args.canEdit ? (axis === "x" ? "#f00" : "#0f0") : editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                                ctx.restore();
                            }
                        }
                        getScreenPointOfObject(args, obj, fx, fy) {
                            const worldPoint = new Phaser.Geom.Point(0, 0);
                            const sprite = obj;
                            const { width, height } = sprite.getEditorSupport().computeSize();
                            const x = width * fx;
                            const y = height * fy;
                            sprite.getWorldTransformMatrix().transformPoint(x, y, worldPoint);
                            return args.camera.getScreenPoint(worldPoint.x, worldPoint.y);
                        }
                        getScreenToObjectScale(args, obj) {
                            let x = args.camera.zoom;
                            let y = args.camera.zoom;
                            const sprite = obj;
                            let next = sprite.parentContainer;
                            while (next) {
                                x *= next.scaleX;
                                y *= next.scaleY;
                                next = next.parentContainer;
                            }
                            return { x, y };
                        }
                        globalAngle(sprite) {
                            let a = sprite.angle;
                            const parent = sprite.parentContainer;
                            if (parent) {
                                a += this.globalAngle(parent);
                            }
                            return a;
                        }
                        drawArrowPath(ctx, color) {
                            ctx.save();
                            ctx.fillStyle = color;
                            ctx.strokeStyle = "#000";
                            ctx.beginPath();
                            ctx.moveTo(0, -6);
                            ctx.lineTo(12, 0);
                            ctx.lineTo(0, 6);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            ctx.restore();
                        }
                        drawCircle(ctx, color) {
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(0, 0, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = "#000";
                            ctx.stroke();
                        }
                        drawRect(ctx, color) {
                            ctx.save();
                            ctx.translate(-5, -5);
                            ctx.beginPath();
                            ctx.rect(0, 0, 10, 10);
                            ctx.fillStyle = color;
                            ctx.strokeStyle = "#000";
                            ctx.fill();
                            ctx.stroke();
                            ctx.restore();
                        }
                        getAvgGlobalAngle(args) {
                            let total = 0;
                            let count = 0;
                            for (const obj of args.objects) {
                                total += this.globalAngle(obj);
                                count++;
                            }
                            return total / count;
                        }
                        getAvgScreenPointOfObjects(args, fx = obj => 0, fy = obj => 0) {
                            let avgY = 0;
                            let avgX = 0;
                            for (const obj of args.objects) {
                                const point = this.getScreenPointOfObject(args, obj, fx(obj), fy(obj));
                                avgX += point.x;
                                avgY += point.y;
                            }
                            avgX /= args.objects.length;
                            avgY /= args.objects.length;
                            return new Phaser.Math.Vector2(avgX, avgY);
                        }
                    }
                    tools.SceneToolItem = SceneToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneToolItem.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class PointToolItem extends tools.SceneToolItem {
                        constructor(color) {
                            super();
                            this._color = color;
                        }
                        render(args) {
                            const point = this.getPoint(args);
                            const ctx = args.canvasContext;
                            ctx.fillStyle = args.canEdit ? this._color : editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = "#000";
                            ctx.stroke();
                        }
                        containsPoint(args) {
                            return false;
                        }
                        onStartDrag(args) {
                            // nothing
                        }
                        onDrag(args) {
                            // nothing
                        }
                        onStopDrag(args) {
                            // nothing
                        }
                    }
                    tools.PointToolItem = PointToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./PointToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class CenterPointToolItem extends tools.PointToolItem {
                        constructor(color) {
                            super(color);
                        }
                        getPoint(args) {
                            return this.getAvgScreenPointOfObjects(args);
                        }
                    }
                    tools.CenterPointToolItem = CenterPointToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneToolItem.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools_1) {
                    class LineToolItem extends tools_1.SceneToolItem {
                        constructor(color, ...tools) {
                            super();
                            this._color = color;
                            this._tools = tools;
                        }
                        isValidFor(objects) {
                            for (const tool of this._tools) {
                                if (!tool.isValidFor(objects)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        render(args) {
                            const ctx = args.canvasContext;
                            ctx.save();
                            ctx.beginPath();
                            let start = true;
                            for (const tool of this._tools) {
                                const { x, y } = tool.getPoint(args);
                                if (start) {
                                    ctx.moveTo(x, y);
                                }
                                else {
                                    ctx.lineTo(x, y);
                                }
                                start = false;
                            }
                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 4;
                            ctx.stroke();
                            ctx.strokeStyle = args.canEdit ? this._color : tools_1.SceneTool.COLOR_CANNOT_EDIT;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.restore();
                        }
                        containsPoint(args) {
                            return false;
                        }
                        onStartDrag(args) {
                            // nothing
                        }
                        onDrag(args) {
                            // nothing
                        }
                        onStopDrag(args) {
                            // nothing
                        }
                    }
                    tools_1.LineToolItem = LineToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class SceneTool {
                        constructor(config) {
                            this._config = config;
                            this._items = [];
                        }
                        getId() {
                            return this._config.id;
                        }
                        getCommandId() {
                            return this._config.command;
                        }
                        getItems() {
                            return this._items;
                        }
                        addItems(...items) {
                            this._items.push(...items);
                        }
                        isObjectTool() {
                            return true;
                        }
                        render(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.render(args);
                                }
                            }
                        }
                        containsPoint(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    if (item.containsPoint(args)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }
                        onStartDrag(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.onStartDrag(args);
                                }
                            }
                        }
                        onDrag(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.onDrag(args);
                                }
                            }
                        }
                        onStopDrag(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.onStopDrag(args);
                                }
                            }
                        }
                        onActivated(args) {
                            // nothing
                        }
                        onDeactivated(args) {
                            // nothing
                        }
                    }
                    SceneTool.COLOR_CANNOT_EDIT = "#808080";
                    tools.SceneTool = SceneTool;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools_2) {
                    class SceneToolExtension extends colibri.Extension {
                        constructor(...tools) {
                            super(SceneToolExtension.POINT_ID);
                            this._tools = tools;
                        }
                        getTools() {
                            return this._tools;
                        }
                    }
                    SceneToolExtension.POINT_ID = "phasereditor2d.scene.ui.editor.tools.SceneToolExtension";
                    tools_2.SceneToolExtension = SceneToolExtension;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class SceneToolOperation extends editor.undo.SceneEditorOperation {
                        constructor(toolArgs) {
                            super(toolArgs.editor);
                            this._objects = toolArgs.objects;
                            this._values0 = new Map();
                            this._values1 = new Map();
                        }
                        async execute() {
                            for (const obj of this._objects) {
                                const sprite = obj;
                                const value0 = this.getInitialValue(sprite);
                                const value1 = this.getFinalValue(sprite);
                                const id = sprite.getEditorSupport().getId();
                                this._values0.set(id, value0);
                                this._values1.set(id, value1);
                            }
                            this.getEditor().setDirty(true);
                        }
                        setValues(values) {
                            for (const obj of this._objects) {
                                const sprite = obj;
                                const id = sprite.getEditorSupport().getId();
                                const value = values.get(id);
                                this.setValue(obj, value);
                            }
                            this._editor.setDirty(true);
                            this._editor.dispatchSelectionChanged();
                        }
                        undo() {
                            this.setValues(this._values0);
                        }
                        redo() {
                            this.setValues(this._values1);
                        }
                    }
                    tools.SceneToolOperation = SceneToolOperation;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_19) {
                var tools;
                (function (tools) {
                    class SceneToolsManager {
                        constructor(editor) {
                            this._editor = editor;
                            this._tools = scene.ScenePlugin.getInstance().getTools();
                            this.setActiveTool(this.findTool(ui.sceneobjects.TranslateTool.ID));
                        }
                        setState(state) {
                            if (state) {
                                const id = state.selectedId;
                                const tool = this.findTool(id);
                                if (tool) {
                                    this.setActiveTool(tool);
                                }
                                this._editor.setLocalCoords(state.localCoords || state.localCoords === undefined, false);
                            }
                        }
                        getState() {
                            return {
                                selectedId: this._activeTool ? this._activeTool.getId() : undefined,
                                localCoords: this._editor.isLocalCoords()
                            };
                        }
                        findTool(toolId) {
                            return this._tools.find(tool => tool.getId() === toolId);
                        }
                        getActiveTool() {
                            return this._activeTool;
                        }
                        setActiveTool(tool) {
                            const args = this.createToolArgs();
                            if (this._activeTool) {
                                this._activeTool.onDeactivated(args);
                            }
                            this.updateAction(this._activeTool, false);
                            this.updateAction(tool, true);
                            this._activeTool = tool;
                            if (this._activeTool) {
                                this._activeTool.onActivated(args);
                            }
                            this._editor.repaint();
                        }
                        createToolArgs() {
                            return {
                                camera: null,
                                editor: this._editor,
                                localCoords: this._editor.isLocalCoords(),
                                objects: this._editor.getSelection()
                            };
                        }
                        updateAction(tool, selected) {
                            if (tool) {
                                const action = this._editor.getToolbarActionMap().get(tool.getId());
                                if (action) {
                                    action.setSelected(selected);
                                }
                            }
                        }
                        swapTool(toolId) {
                            const tool = this.findTool(toolId);
                            this.setActiveTool(tool === this._activeTool ? null : tool);
                        }
                    }
                    tools.SceneToolsManager = SceneToolsManager;
                })(tools = editor_19.tools || (editor_19.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_18) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_20) {
                var undo;
                (function (undo) {
                    class ObjectSnapshotOperation extends undo.SceneEditorOperation {
                        constructor(editor, objects) {
                            super(editor);
                            this._objects = objects;
                        }
                        async execute() {
                            this._before = this.takeSnapshot(this._objects);
                            this._after = this.makeChangeSnapshot(this._objects);
                            this.loadSnapshot(this._after);
                        }
                        takeSnapshot(objects) {
                            const snapshot = {
                                objects: []
                            };
                            for (const obj of objects) {
                                const data = {};
                                obj.getEditorSupport().writeJSON(data);
                                let parentId;
                                const parent = ui.sceneobjects.getObjectParent(obj);
                                if (parent) {
                                    parentId = parent.getEditorSupport().getId();
                                }
                                snapshot.objects.push({
                                    parentId,
                                    objData: data
                                });
                            }
                            return snapshot;
                        }
                        async loadSnapshot(snapshot) {
                            const scene = this.getScene();
                            const maker = scene.getMaker();
                            const selectionIds = this.getEditor().getSelectionManager().getSelectionIds();
                            const finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                            await maker.updateSceneLoaderWithGameObjectDataList(finder, snapshot.objects.map(objSnapshot => objSnapshot.objData));
                            for (const objSnapshot of snapshot.objects) {
                                const oldObj = scene.getByEditorId(objSnapshot.objData.id);
                                if (oldObj) {
                                    const objData = objSnapshot.objData;
                                    const newObj = maker.createObject(objData);
                                    if (newObj) {
                                        scene.sys.displayList.remove(newObj);
                                        if (objSnapshot.parentId) {
                                            const parent = scene.getByEditorId(objSnapshot.parentId);
                                            if (parent) {
                                                parent.replace(oldObj, newObj);
                                            }
                                        }
                                        else {
                                            scene.sys.displayList.replace(oldObj, newObj);
                                        }
                                    }
                                    oldObj.getEditorSupport().destroy();
                                }
                            }
                            await this.getEditor().refreshDependenciesHash();
                            this._editor.setDirty(true);
                            this._editor.getSelectionManager().setSelectionByIds(selectionIds);
                        }
                        undo() {
                            this.loadSnapshot(this._before);
                        }
                        redo() {
                            this.loadSnapshot(this._after);
                        }
                    }
                    undo.ObjectSnapshotOperation = ObjectSnapshotOperation;
                })(undo = editor_20.undo || (editor_20.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_18.ui || (scene_18.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ObjectSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_21) {
                var undo;
                (function (undo) {
                    var io = colibri.core.io;
                    class ConvertTypeOperation extends undo.ObjectSnapshotOperation {
                        constructor(editor, targetType, extraData) {
                            super(editor, ConvertTypeOperation.filterObjects(editor.getSelectedGameObjects(), targetType));
                            this._targetType = targetType;
                            this._extraData = extraData || {};
                        }
                        async execute() {
                            if (this._targetType instanceof io.FilePath) {
                                const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                const sceneData = finder.getSceneData(this._targetType);
                                await this.getEditor().getSceneMaker().updateSceneLoader(sceneData);
                            }
                            await super.execute();
                        }
                        makeChangeSnapshot(input) {
                            const result = {
                                objects: []
                            };
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            for (const obj of input) {
                                const parentId = obj.getEditorSupport().getParentId();
                                const support = obj.getEditorSupport();
                                const objData = {};
                                support.writeJSON(objData);
                                if (support.isPrefabInstance()) {
                                    delete objData.prefabId;
                                }
                                else {
                                    delete objData.type;
                                }
                                if (this._targetType instanceof io.FilePath) {
                                    objData.prefabId = finder.getPrefabId(this._targetType);
                                }
                                else {
                                    objData.type = this._targetType.getTypeName();
                                }
                                const ser = this._editor.getScene().getMaker().getSerializer(objData);
                                const type = ser.getType();
                                const ext = scene.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                                if (obj.getEditorSupport().isUnlockedProperty(ui.sceneobjects.TransformComponent.x)) {
                                    ser.setUnlocked(ui.sceneobjects.TransformComponent.x.name, true);
                                    ser.setUnlocked(ui.sceneobjects.TransformComponent.y.name, true);
                                }
                                ext.adaptDataAfterTypeConversion(ser, obj, this._extraData);
                                result.objects.push({
                                    objData,
                                    parentId
                                });
                            }
                            return result;
                        }
                        static filterObjects(input, targetType) {
                            return input.filter(obj => {
                                if (obj.getEditorSupport().isPrefabInstance()) {
                                    if (obj.getEditorSupport().getPrefabFile() === targetType) {
                                        return false;
                                    }
                                }
                                else if (obj.getEditorSupport().getExtension() === targetType) {
                                    return false;
                                }
                                return true;
                            });
                        }
                    }
                    undo.ConvertTypeOperation = ConvertTypeOperation;
                })(undo = editor_21.undo || (editor_21.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_19) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_22) {
                var undo;
                (function (undo) {
                    class SceneSnapshotOperation extends undo.SceneEditorOperation {
                        constructor(editor, operation) {
                            super(editor);
                            this._operation = operation;
                        }
                        async execute() {
                            this._before = this.takeSnapshot();
                            await this.performModification();
                            this._after = this.takeSnapshot();
                            this._editor.setDirty(true);
                            this._editor.refreshOutline();
                            this._editor.repaint();
                            this._editor.dispatchSelectionChanged();
                        }
                        async performModification() {
                            if (this._operation) {
                                await this._operation();
                            }
                        }
                        takeSnapshot() {
                            const scene = this.getScene();
                            return {
                                displayList: scene.getDisplayListChildren().map(obj => {
                                    const data = {};
                                    obj.getEditorSupport().writeJSON(data);
                                    return data;
                                }),
                                lists: scene.getObjectLists().getLists().map(list => {
                                    const data = {};
                                    list.writeJSON(data);
                                    return data;
                                }),
                                plainObjects: scene.getPlainObjects().map(obj => {
                                    const data = {};
                                    obj.getEditorSupport().writeJSON(data);
                                    return data;
                                }),
                                selection: this.getEditor().getSelectionManager().getSelectionIds()
                            };
                        }
                        loadSnapshot(snapshot) {
                            const editor = this.getEditor();
                            const scene = this.getScene();
                            const maker = scene.getMaker();
                            scene.removeAll();
                            scene.readPlainObjects(snapshot.plainObjects);
                            for (const data of snapshot.displayList) {
                                maker.createObject(data);
                            }
                            scene.getObjectLists().readJSON_lists(snapshot.lists);
                            editor.setDirty(true);
                            editor.repaint();
                            editor.refreshOutline();
                            editor.getSelectionManager().setSelectionByIds(snapshot.selection);
                        }
                        undo() {
                            this.loadSnapshot(this._before);
                        }
                        redo() {
                            this.loadSnapshot(this._after);
                        }
                    }
                    undo.SceneSnapshotOperation = SceneSnapshotOperation;
                })(undo = editor_22.undo || (editor_22.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_19.ui || (scene_19.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_23) {
                var undo;
                (function (undo) {
                    class CreateObjectWithAssetOperation extends undo.SceneSnapshotOperation {
                        constructor(editor, data, offsetX, offsetY) {
                            super(editor);
                            this._offsetX = offsetX;
                            this._offsetY = offsetY;
                            this._data = data;
                        }
                        async performModification() {
                            const sprites = await this.getEditor().getDropManager().createWithDropEvent(this._data, this._offsetX, this._offsetY);
                            this.getEditor().setSelection(sprites);
                        }
                    }
                    undo.CreateObjectWithAssetOperation = CreateObjectWithAssetOperation;
                })(undo = editor_23.undo || (editor_23.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_24) {
                var undo;
                (function (undo) {
                    class CutOperation extends undo.SceneSnapshotOperation {
                        constructor(editor) {
                            super(editor);
                        }
                        async performModification() {
                            this._editor.getClipboardManager().copy();
                            const lists = this._editor.getScene().getObjectLists();
                            for (const obj of this._editor.getSelection()) {
                                if (ui.sceneobjects.isGameObject(obj)) {
                                    const sprite = obj;
                                    sprite.getEditorSupport().destroy();
                                    lists
                                        .removeObjectById(sprite.getEditorSupport().getId());
                                }
                                else if (obj instanceof ui.sceneobjects.ObjectList) {
                                    lists.removeListById(obj.getId());
                                }
                            }
                            this._editor.setSelection([]);
                        }
                    }
                    undo.CutOperation = CutOperation;
                })(undo = editor_24.undo || (editor_24.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_20) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_25) {
                var undo;
                (function (undo) {
                    class DeleteOperation extends undo.SceneSnapshotOperation {
                        constructor(editor) {
                            super(editor);
                        }
                        async performModification() {
                            const editor = this._editor;
                            const scene = this._editor.getScene();
                            const lists = scene.getObjectLists();
                            for (const obj of editor.getSelectedGameObjects()) {
                                obj.getEditorSupport().destroy();
                                lists.removeObjectById(obj.getEditorSupport().getId());
                            }
                            for (const obj of editor.getSelectedLists()) {
                                lists.removeListById(obj.getId());
                            }
                            scene.removePlainObjects(editor.getSelectedPlainObjects());
                            editor.setSelection([]);
                        }
                    }
                    undo.DeleteOperation = DeleteOperation;
                })(undo = editor_25.undo || (editor_25.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_20.ui || (scene_20.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_26) {
                var undo;
                (function (undo) {
                    class DepthOperation extends undo.SceneSnapshotOperation {
                        constructor(editor, depthMove) {
                            super(editor);
                            this._depthMove = depthMove;
                        }
                        async performModification() {
                            const objects = this.getEditor().getSelectedGameObjects();
                            const displayList = this.getScene().sys.displayList;
                            objects.sort((a, b) => {
                                const aParent = ui.sceneobjects.getObjectParentOrDisplayList(a);
                                const bParent = ui.sceneobjects.getObjectParentOrDisplayList(a);
                                const aa = aParent.getIndex(a);
                                const bb = bParent.getIndex(b);
                                return aa - bb;
                            });
                            switch (this._depthMove) {
                                case "Top":
                                    for (const obj of objects) {
                                        ui.sceneobjects.getObjectParentOrDisplayList(obj).bringToTop(obj);
                                    }
                                    break;
                                case "Bottom":
                                    for (let i = 0; i < objects.length; i++) {
                                        const obj = objects[objects.length - i - 1];
                                        ui.sceneobjects.getObjectParentOrDisplayList(obj).sendToBack(obj);
                                    }
                                    break;
                                case "Up":
                                    for (let i = 0; i < objects.length; i++) {
                                        const obj = objects[objects.length - i - 1];
                                        ui.sceneobjects.getObjectParentOrDisplayList(obj).moveUp(obj);
                                    }
                                    break;
                                case "Down":
                                    for (const obj of objects) {
                                        ui.sceneobjects.getObjectParentOrDisplayList(obj).moveDown(obj);
                                    }
                                    break;
                            }
                            this.getEditor().repaint();
                        }
                    }
                    undo.DepthOperation = DepthOperation;
                })(undo = editor_26.undo || (editor_26.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_21) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_27) {
                var undo;
                (function (undo) {
                    class PasteOperation extends undo.SceneSnapshotOperation {
                        constructor(editor, pasteInPlace) {
                            super(editor);
                            this._pasteInPlace = pasteInPlace;
                        }
                        // TODO: keep an eye on this. I did a full refreshScene() for loading all the required assets,
                        // but I'm now using the data loaders in the performModification() method.
                        // So I'm commenting this, but let's see if it doesn't introduce regressions.
                        // async execute() {
                        //     await super.execute();
                        //     await this.getEditor().refreshScene();
                        // }
                        async performModification() {
                            const items = editor_27.ClipboardManager.getClipboardCopy();
                            const maker = this._editor.getSceneMaker();
                            const sel = [];
                            const scene = this._editor.getScene();
                            const nameMaker = scene.createNameMaker();
                            const prefabObj = scene.getPrefabObject();
                            const sprites = [];
                            for (const item of items) {
                                if (item.type === "ISceneObject") {
                                    const data = item.data;
                                    this.setNewObjectId(data);
                                    if (!this._pasteInPlace) {
                                        const { x, y } = this.getEditor().getMouseManager().getDropPosition();
                                        data["x"] = data["__shiftLeft_x"] + x;
                                        data["y"] = data["__shiftLeft_y"] + y;
                                    }
                                    const loaders = scene_21.ScenePlugin.getInstance().getLoaderUpdaters();
                                    for (const loader of loaders) {
                                        await loader.updateLoaderWithObjData(this.getScene(), data);
                                    }
                                    const obj = maker.createObject(data);
                                    if (obj) {
                                        sprites.push(obj);
                                        sel.push(obj);
                                    }
                                }
                            }
                            scene.visitAskChildren(obj => {
                                const support = obj.getEditorSupport();
                                support.setLabel(nameMaker.makeName(support.getLabel()));
                                return !obj.getEditorSupport().isPrefabInstance();
                            }, sprites);
                            maker.afterDropObjects(prefabObj, sprites);
                            this._editor.setSelection(sel);
                        }
                        setNewObjectId(data) {
                            data.id = Phaser.Utils.String.UUID();
                            if (data.list) {
                                for (const child of data.list) {
                                    this.setNewObjectId(child);
                                }
                            }
                            if (data.nestedPrefabs) {
                                for (const child of data.nestedPrefabs) {
                                    this.setNewObjectId(child);
                                }
                            }
                        }
                    }
                    undo.PasteOperation = PasteOperation;
                })(undo = editor_27.undo || (editor_27.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_21.ui || (scene_21.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_28) {
                var undo;
                (function (undo) {
                    class SimpleSceneSnapshotOperation extends undo.SceneSnapshotOperation {
                        constructor(editor, action) {
                            super(editor);
                            this._action = action;
                        }
                        async performModification() {
                            this._action();
                            delete this._action;
                        }
                    }
                    undo.SimpleSceneSnapshotOperation = SimpleSceneSnapshotOperation;
                })(undo = editor_28.undo || (editor_28.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var code = scene.core.code;
                    class UserComponentCodeDOMBuilder {
                        constructor(component, model, file) {
                            this._component = component;
                            this._model = model;
                            this._modelFile = file;
                        }
                        build() {
                            if (this._model.autoImport) {
                                this.buildFilesMap();
                            }
                            this._unitDom = new code.UnitCodeDOM([]);
                            const clsDom = this.createClass();
                            this._unitDom.getBody().push(clsDom);
                            return this._unitDom;
                        }
                        buildFilesMap() {
                            this._typeFileMap = new Map();
                            colibri.ui.ide.FileUtils.visitProject(file => {
                                if (file.getExtension() === "ts" || file.getExtension() === "js") {
                                    this._typeFileMap.set(file.getNameWithoutExtension(), file);
                                }
                            });
                        }
                        createClass() {
                            const clsDom = new code.ClassDeclCodeDOM(this._component.getName());
                            clsDom.setExportClass(this._model.exportClass);
                            clsDom.setSuperClass(this._component.getBaseClass());
                            this.addImportForType(clsDom.getSuperClass());
                            this.buildConstructor(clsDom);
                            this.buildFields(clsDom);
                            this.buildAccessorMethods(clsDom);
                            return clsDom;
                        }
                        buildConstructor(clsDom) {
                            const ctrDeclDom = new code.MethodDeclCodeDOM("constructor");
                            ctrDeclDom.arg("gameObject", this._component.getGameObjectType());
                            if (this.isTypeScriptOutput()) {
                                this.addImportForType(this._component.getGameObjectType());
                            }
                            const body = ctrDeclDom.getBody();
                            const superClass = this._component.getBaseClass();
                            if (superClass && superClass.trim() !== "") {
                                const superCall = new code.MethodCallCodeDOM("super");
                                superCall.arg("gameObject");
                                body.push(superCall);
                                body.push(new code.RawCodeDOM(""));
                            }
                            const initGameObjDom = new code.AssignPropertyCodeDOM("gameObject", "this");
                            initGameObjDom.value("gameObject");
                            body.push(initGameObjDom);
                            const setCompDom = new code.RawCodeDOM(this.isTypeScriptOutput() ?
                                `(gameObject as any)["__${clsDom.getName()}"] = this;`
                                : `gameObject["__${clsDom.getName()}"] = this;`);
                            body.push(setCompDom);
                            body.push(new code.RawCodeDOM(""));
                            body.push(new code.UserSectionCodeDOM("/* START-USER-CTR-CODE */", "/* END-USER-CTR-CODE */", "\n\t\t// Write your code here.\n\t\t"));
                            this.buildCustomPropertiesInit(body);
                            clsDom.getBody().push(new code.UserSectionCodeDOM("/* START-USER-CODE */", "/* END-USER-CODE */", "\n\n\t// Write your code here.\n\n\t"));
                            clsDom.getBody().push(ctrDeclDom);
                        }
                        buildCustomPropertiesInit(body) {
                            const userProps = this._component.getUserProperties();
                            const assignDomList = userProps.getProperties()
                                .filter(prop => prop.isCustomDefinition())
                                .map(prop => {
                                const fieldDecl = prop.buildFieldDeclarationCode();
                                const assignDom = new code.AssignPropertyCodeDOM(fieldDecl.getName(), "this");
                                assignDom.value(fieldDecl.getInitialValueExpr());
                                return assignDom;
                            });
                            if (assignDomList.length > 0) {
                                body.push(new code.RawCodeDOM("\n"));
                                body.push(new code.RawCodeDOM("// custom definition props"));
                            }
                            body.push(...assignDomList);
                        }
                        addImportForType(type) {
                            if (!this._model.autoImport) {
                                return;
                            }
                            if (type) {
                                if (type.startsWith("Phaser.")) {
                                    this._unitDom.addImport("Phaser", "phaser");
                                }
                                else if (this._typeFileMap.has(type)) {
                                    const importFile = this._typeFileMap.get(type);
                                    const importPath = code.getImportPath(this._modelFile, importFile);
                                    this._unitDom.addImport(type, importPath);
                                }
                            }
                        }
                        buildFields(clsDom) {
                            // gameObject field
                            const gameObjectFieldDecl = new code.FieldDeclCodeDOM("gameObject", this._component.getGameObjectType());
                            gameObjectFieldDecl.setAllowUndefined(false);
                            clsDom.getBody().push(gameObjectFieldDecl);
                            // props fields
                            const userProps = this._component.getUserProperties();
                            for (const prop of userProps.getProperties()) {
                                if (!prop.isCustomDefinition()) {
                                    const fieldDecl = prop.buildFieldDeclarationCode();
                                    clsDom.getBody().push(fieldDecl);
                                }
                            }
                            if (this.isTypeScriptOutput()) {
                                // add imports for field declarations
                                for (const elem of clsDom.getBody()) {
                                    if (elem instanceof code.FieldDeclCodeDOM) {
                                        this.addImportForType(elem.getType());
                                    }
                                }
                            }
                        }
                        isTypeScriptOutput() {
                            return this._model.outputLang === scene.core.json.SourceLang.TYPE_SCRIPT;
                        }
                        buildAccessorMethods(clsDom) {
                            {
                                // getComponent()
                                const declDom = new code.MethodDeclCodeDOM("getComponent");
                                declDom.getModifiers().push("static");
                                declDom.arg("gameObject", this._component.getGameObjectType());
                                declDom.setReturnType(clsDom.getName());
                                const returnDom = new code.RawCodeDOM(this.isTypeScriptOutput() ?
                                    `return (gameObject as any)["__${clsDom.getName()}"];`
                                    : `return gameObject["__${clsDom.getName()}"];`);
                                declDom.getBody().push(returnDom);
                                clsDom.getBody().push(declDom);
                            }
                        }
                    }
                    usercomponent.UserComponentCodeDOMBuilder = UserComponentCodeDOMBuilder;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentCodeResources extends scene.core.code.CodeResources {
                        constructor() {
                            super(scene.ScenePlugin.getInstance());
                            this.addResource("usercomponent.js", "data/UserComponent.js.txt");
                            this.addResource("usercomponent.module.js", "data/UserComponent.module.js.txt");
                            this.addResource("usercomponent.ts", "data/UserComponent.ts.txt");
                            this.addResource("usercomponent.module.ts", "data/UserComponent.module.ts.txt");
                        }
                        static getInstance() {
                            return this._instance;
                        }
                    }
                    UserComponentCodeResources._instance = new UserComponentCodeResources();
                    usercomponent.UserComponentCodeResources = UserComponentCodeResources;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentCompileAllExtension extends phasereditor2d.ide.core.CompileProjectExtension {
                        getTotal() {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            return finder.getUserComponentsModels().length;
                        }
                        async preload(monitor) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const infos = finder.getUserComponentsModels();
                            for (const info of infos) {
                                const compiler = new usercomponent.UserComponentCompiler(info.file, info.model);
                                await compiler.compile();
                                monitor.step();
                            }
                        }
                    }
                    usercomponent.UserComponentCompileAllExtension = UserComponentCompileAllExtension;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var code = scene.core.code;
                    class UserComponentCompiler {
                        constructor(componentsFile, model) {
                            this._componentsFile = componentsFile;
                            this._model = model;
                        }
                        async compile() {
                            for (const userComp of this._model.getComponents()) {
                                const builder = new usercomponent.UserComponentCodeDOMBuilder(userComp, this._model, this._componentsFile);
                                const unitDom = builder.build();
                                const generator = this.isJavaScriptOutput() ?
                                    new code.JavaScriptUnitCodeGenerator(unitDom) :
                                    new code.TypeScriptUnitCodeGenerator(unitDom);
                                if (this.isJavaScriptOutput()) {
                                    generator.setInitFieldInConstructor(this._model.javaScriptInitFieldsInConstructor);
                                }
                                let replace = "";
                                const outFile = this.getOutputFile(userComp.getName());
                                if (outFile) {
                                    replace = await colibri.ui.ide.FileUtils.preloadAndGetFileString(outFile);
                                }
                                let output = generator.generate(replace);
                                if (this._model.insertSpaces) {
                                    const tabs = " ".repeat(Math.max(1, this._model.tabSize));
                                    output = output.replace(/\t/g, tabs);
                                }
                                const folder = this._componentsFile.getParent();
                                const fileName = this.getOutputFileName(userComp.getName());
                                await colibri.ui.ide.FileUtils.createFile_async(folder, fileName, output);
                            }
                        }
                        isJavaScriptOutput() {
                            return this._model.getOutputLang() === scene.core.json.SourceLang.JAVA_SCRIPT;
                        }
                        getOutputFile(userCompName) {
                            const file = this._componentsFile.getSibling(this.getOutputFileName(userCompName));
                            return file;
                        }
                        getOutputFileName(userCompName) {
                            return userCompName + "." + (this.isJavaScriptOutput() ? "js" : "ts");
                        }
                    }
                    usercomponent.UserComponentCompiler = UserComponentCompiler;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserProperties {
                    constructor(componentPropertyBuilder) {
                        this._componentPropertyBuilder = componentPropertyBuilder;
                        this._properties = [];
                    }
                    getProperties() {
                        return this._properties;
                    }
                    add(prop) {
                        this._properties.push(prop);
                    }
                    createProperty(propType) {
                        let i = 0;
                        while (true) {
                            i++;
                            const p = this._properties.find(p2 => p2.getInfo().name === "property" + i);
                            if (!p) {
                                break;
                            }
                        }
                        const prop = new sceneobjects.UserProperty(this._componentPropertyBuilder, {
                            defValue: propType.getDefaultValue(),
                            label: "Property " + i,
                            name: "property" + i,
                            tooltip: "Property " + i,
                            customDefinition: false,
                            type: propType
                        });
                        return prop;
                    }
                    readJSON(data) {
                        this._properties = [];
                        for (const propData of data) {
                            const prop = new sceneobjects.UserProperty(this._componentPropertyBuilder);
                            prop.readJSON(propData);
                            this._properties.push(prop);
                        }
                    }
                    writeJSON(data) {
                        for (const prop of this._properties) {
                            const propData = {};
                            prop.writeJSON(propData);
                            data.push(propData);
                        }
                    }
                }
                sceneobjects.UserProperties = UserProperties;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserComponentPropertyWrapper {
                    constructor(userComp, userProp) {
                        this._userComp = userComp;
                        this._userProp = userProp;
                    }
                    getUserComponent() {
                        return this._userComp;
                    }
                    getUserProperty() {
                        return this._userProp;
                    }
                    getValue(obj) {
                        const comp = this.getComponent(obj);
                        if (comp.isPropertySet(this._userComp.getName(), this._userProp)) {
                            return comp.getPropertyValue(this._userComp.getName(), this._userProp);
                        }
                        return this._userProp.getDefaultValue();
                    }
                    setValue(obj, value) {
                        this.getComponent(obj).setPropertyValue(this._userComp.getName(), this._userProp, value);
                    }
                    getComponent(obj) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.UserComponentsEditorComponent);
                    }
                    get name() {
                        return this._userComp.getName() + "." + this._userProp.getName();
                    }
                    get codeName() {
                        return this._userProp.getName();
                    }
                    get defValue() {
                        return this._userProp.getDefaultValue();
                    }
                    get local() {
                        return false;
                    }
                    get label() {
                        return this._userProp.getLabel();
                    }
                    get tooltip() {
                        return this._userProp.getTooltip();
                    }
                }
                sceneobjects.UserComponentPropertyWrapper = UserComponentPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabUserPropertyWrapper {
                    constructor(userProp) {
                        this._userProp = userProp;
                    }
                    getUserProperty() {
                        return this._userProp;
                    }
                    getValue(obj) {
                        const comp = this.getComponent(obj);
                        if (comp.isPropertySet(this._userProp)) {
                            return this.getComponent(obj).getPropertyValue(this._userProp);
                        }
                        return this._userProp.getDefaultValue();
                    }
                    setValue(obj, value) {
                        this.getComponent(obj).setPropertyValue(this._userProp, value);
                    }
                    getComponent(obj) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.PrefabUserPropertyComponent);
                    }
                    get name() {
                        return this._userProp.getName();
                    }
                    get defValue() {
                        return this._userProp.getDefaultValue();
                    }
                    get local() {
                        return false;
                    }
                    get label() {
                        return this._userProp.getLabel();
                    }
                    get tooltip() {
                        return this._userProp.getTooltip();
                    }
                }
                sceneobjects.PrefabUserPropertyWrapper = PrefabUserPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./PrefabUserPropertyWrapper.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserComponentOptionPropertyWrapper extends sceneobjects.UserComponentPropertyWrapper {
                    constructor(userComp, userProp) {
                        super(userComp, userProp);
                    }
                    get values() {
                        return this.getUserProperty().getType().getOptions();
                    }
                    getValueLabel(value) {
                        return value;
                    }
                }
                sceneobjects.UserComponentOptionPropertyWrapper = UserComponentOptionPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../sceneobjects/userProperties/UserProperties.ts" />
/// <reference path="../../sceneobjects/userProperties/UserComponentPropertyWrapper.ts" />
/// <reference path="../../sceneobjects/userProperties/UserComponentOptionPropertyWrapper.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentProperties extends ui.sceneobjects.UserProperties {
                        constructor(userComp) {
                            super((prop) => {
                                if (prop.getType() instanceof ui.sceneobjects.OptionPropertyType) {
                                    return new ui.sceneobjects.UserComponentOptionPropertyWrapper(userComp, prop);
                                }
                                return new ui.sceneobjects.UserComponentPropertyWrapper(userComp, prop);
                            });
                        }
                    }
                    usercomponent.UserComponentProperties = UserComponentProperties;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../properties/UserPropertiesSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentPropertiesSection extends editor.properties.UserPropertiesSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.usercomponent.UserComponentPropertiesSection", "Component Properties", false, false);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/user-components-editor-edit-component.html";
                        }
                        getUserProperties() {
                            return this.getSelectionFirstElement().getUserProperties();
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                        runOperation(action, updateSelection) {
                            this.getEditor().runOperation(() => action(this.getUserProperties()));
                            if (updateSelection) {
                                this.updateWithSelection();
                            }
                        }
                        canEdit(obj, n) {
                            return obj instanceof usercomponent.UserComponent;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                    }
                    usercomponent.UserComponentPropertiesSection = UserComponentPropertiesSection;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class UserComponentSection extends controls.properties.PropertySection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.usercomponent.UserComponentSection", "Component", false, false);
                        }
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/user-components-editor-edit-component.html");
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr auto";
                            {
                                // Name
                                const text = this.stringProp(comp, "Name", "Name", "Name of the component. In the compiled code, it is used as file name and class name.");
                                this.addUpdater(() => {
                                    text.readOnly = this.getSelection().length > 1;
                                });
                            }
                            this.stringProp(comp, "GameObjectType", "Game Object Type", "Name of the type of the Game Object that this component can be added on.", () => this.createGameObjectTypeOptions());
                            this.stringProp(comp, "BaseClass", "Super Class", "Name of the super class of the component. It is optional.", () => this.createSuperClassOptions());
                        }
                        createSuperClassOptions() {
                            const options = new Set(scene.ScenePlugin.getInstance().getSceneFinder()
                                .getUserComponentsModels()
                                .flatMap(model => model.model.getComponents())
                                .map(comp => comp.getBaseClass())
                                .filter(name => name !== undefined && name !== null && name.trim().length > 0));
                            options.delete("UserComponent");
                            return ["UserComponent", ...([...options].sort())];
                        }
                        createGameObjectTypeOptions() {
                            const options = new Set(scene.ScenePlugin.getInstance().getSceneFinder()
                                .getUserComponentsModels()
                                .flatMap(model => model.model.getComponents())
                                .map(comp => comp.getGameObjectType()));
                            for (const option of scene.ScenePlugin.getInstance()
                                .getGameObjectExtensions()
                                .map(e => e.getPhaserTypeName())) {
                                options.add(option);
                            }
                            return [...options].sort();
                        }
                        stringProp(comp, prop, propName, propHelp, options) {
                            this.createLabel(comp, propName, propHelp);
                            const text = this.createText(comp);
                            text.addEventListener("change", e => {
                                this.getEditor().runOperation(() => {
                                    for (const comp1 of this.getSelection()) {
                                        comp1["set" + prop](text.value);
                                    }
                                });
                            });
                            this.addUpdater(() => {
                                text.value = this.flatValues_StringOneOrNothing(this.getSelection().map(c => c["get" + prop]()));
                            });
                            if (options) {
                                const btn = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_TREE_COLLAPSE), true);
                                btn.getCanvas().style.alignSelf = "center";
                                comp.appendChild(btn.getCanvas());
                                btn.getCanvas().addEventListener("click", e => {
                                    const menu = new controls.Menu();
                                    for (const option of options()) {
                                        menu.addAction({
                                            text: option,
                                            callback: () => {
                                                text.value = option;
                                                this.getEditor().runOperation(() => {
                                                    for (const comp1 of this.getSelection()) {
                                                        comp1["set" + prop](text.value);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                    menu.createWithEvent(e, true);
                                });
                            }
                            else {
                                text.style.gridColumn = "2 / span 2";
                            }
                            return text;
                        }
                        booleanProp(comp, prop, propName, propHelp) {
                            const checkbox = this.createCheckbox(comp, this.createLabel(comp, propName, propHelp));
                            checkbox.style.gridColumn = "2 / span 2";
                            checkbox.addEventListener("change", e => {
                                this.getEditor().runOperation(() => {
                                    for (const comp1 of this.getSelection()) {
                                        comp1["set" + prop](checkbox.checked);
                                    }
                                });
                            });
                            this.addUpdater(() => {
                                checkbox.checked = this.flatValues_BooleanAnd(this.getSelection().map(c => c["is" + prop]()));
                            });
                            return checkbox;
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                        canEdit(obj, n) {
                            return obj instanceof usercomponent.UserComponent;
                        }
                        canEditNumber(n) {
                            return n > 0;
                        }
                    }
                    usercomponent.UserComponentSection = UserComponentSection;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class UserComponentsCompilerSection extends controls.properties.PropertySection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.usercomponent.UserComponentsCompilerSection", "Compiler Settings", false, false);
                        }
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/user-components-compiler.html");
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 2);
                            {
                                // Output Lang
                                this.createLabel(comp, "Output Language", "The components code output language.");
                                const btn = this.createMenuButton(comp, "", () => [{
                                        name: "JavaScript",
                                        value: scene.core.json.SourceLang.JAVA_SCRIPT
                                    }, {
                                        name: "TypeScript",
                                        value: scene.core.json.SourceLang.TYPE_SCRIPT
                                    }], value => {
                                    this.getEditor().runOperation(model => {
                                        model.setOutputLang(value);
                                        this.updateWithSelection();
                                    });
                                });
                                this.addUpdater(() => {
                                    const lang = this.getSelectionFirstElement().getOutputLang();
                                    btn.textContent = lang === scene.core.json.SourceLang.JAVA_SCRIPT ?
                                        "JavaScript" : "TypeScript";
                                });
                            }
                            {
                                // Fields In Constructor
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Fields In Constructor (JS)", "Generate the initialization of the fields in the constructor. This is valid only when the output is JavaScript."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.javaScriptInitFieldsInConstructor = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().javaScriptInitFieldsInConstructor;
                                });
                            }
                            {
                                // Export Class
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Export Class (ES Module)", "Export the class."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.exportClass = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().exportClass;
                                });
                            }
                            {
                                // Auto Import
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Auto Import (ES Module)", "Auto import types used in the component."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.autoImport = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().autoImport;
                                });
                            }
                            {
                                // Insert Spaces
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Insert Spaces", "Use spaces for indentation."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.insertSpaces = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().insertSpaces;
                                });
                            }
                            {
                                // Tab Size
                                this.createLabel(comp, "Tab Size", "The number of spaces if the Insert Spaces option is checked.");
                                const text = this.createText(comp);
                                text.addEventListener("change", e => {
                                    const n = Number.parseInt(text.value, 10);
                                    if (isNaN(n)) {
                                        this.updateWithSelection();
                                    }
                                    else {
                                        this.getEditor().runOperation(model => {
                                            model.tabSize = n;
                                        });
                                    }
                                });
                                this.addUpdater(() => {
                                    text.value = this.getSelectionFirstElement().tabSize.toString();
                                });
                            }
                        }
                        canEdit(obj, n) {
                            return obj instanceof usercomponent.UserComponentsModel;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                    }
                    usercomponent.UserComponentsCompilerSection = UserComponentsCompilerSection;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_29) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    usercomponent.CMD_ADD_USER_COMPONENT = "phasereditor2d.scene.ui.editor.usercomponent.AddUserComponent";
                    usercomponent.CMD_COMPILE_FILE = "phasereditor2d.scene.ui.editor.usercomponent.CompileFile";
                    usercomponent.CMD_QUICK_EDIT_COMPONENT_FILE = "phasereditor2d.scene.ui.editor.usercomponent.QuickEditComponentFile";
                    usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE_IN_VSCODE = "phasereditor2d.scene.ui.editor.usercomponent.OpenComponentOutputFileInVSCode";
                    usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE = "phasereditor2d.scene.ui.editor.usercomponent.OpenComponentOutputFile";
                    usercomponent.CAT_USER_COMPONENTS_EDITOR = "phasereditor2d.scene.ui.editor.usercomponent.UserComponentsCategory";
                    class UserComponentsEditor extends colibri.ui.ide.ViewerFileEditor {
                        constructor() {
                            super(UserComponentsEditor.ID, UserComponentsEditor.getFactory());
                            this._outputFileEditorStateMap = {};
                            this._model = new usercomponent.UserComponentsModel();
                            this._outlineProvider = new usercomponent.UserComponentsEditorOutlineProvider(this);
                            this._propertyProvider = new usercomponent.UserComponentsEditorPropertySectionProvider(this);
                        }
                        static getFactory() {
                            return this._factory || (this._factory = new colibri.ui.ide.ContentTypeEditorFactory("User Components Editor", scene.core.CONTENT_TYPE_USER_COMPONENTS, () => new UserComponentsEditor()));
                        }
                        static registerCommands(manager) {
                            const editorScope = (args) => {
                                return args.activePart instanceof UserComponentsEditor ||
                                    (args.activeEditor instanceof UserComponentsEditor &&
                                        (args.activePart instanceof phasereditor2d.outline.ui.views.OutlineView
                                            || args.activePart instanceof colibri.inspector.ui.views.InspectorView));
                            };
                            manager.addCategory({
                                id: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                name: "User Components Editor"
                            });
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_ADD_USER_COMPONENT,
                                    name: "Add User Component",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                    tooltip: "Add a new User Component.",
                                    icon: colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_PLUS)
                                },
                                handler: {
                                    testFunc: editorScope,
                                    executeFunc: args => {
                                        args.activeEditor.addComponent();
                                    }
                                },
                                keys: {
                                    key: "KeyA"
                                }
                            });
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_COMPILE_FILE,
                                    name: "Compile",
                                    tooltip: "Compile User Components file.",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR
                                },
                                handler: {
                                    testFunc: editorScope,
                                    executeFunc: args => args.activeEditor.compile()
                                }
                            });
                            manager.add({
                                handler: {
                                    testFunc: args => editorScope(args) && args.activeEditor.getSelection().length > 0,
                                    executeFunc: args => {
                                        args.activeEditor.deleteSelection();
                                    }
                                }
                            }, colibri.ui.ide.actions.CMD_DELETE);
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE,
                                    icon: phasereditor2d.webContentTypes.WebContentTypesPlugin.getInstance().getIcon(phasereditor2d.webContentTypes.ICON_FILE_SCRIPT),
                                    name: "Open Component Output File",
                                    tooltip: "Open the output source file of the selected component.",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        if (args.activeEditor instanceof UserComponentsEditor) {
                                            return args.activeEditor.getSelectedComponents().length === 1;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const compiler = new usercomponent.UserComponentCompiler(editor.getInput(), editor.getModel());
                                        const component = editor.getSelectedComponents()[0];
                                        const file = compiler.getOutputFile(component.getName());
                                        colibri.Platform.getWorkbench().openEditor(file);
                                    }
                                }
                            });
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_QUICK_EDIT_COMPONENT_FILE,
                                    name: "Quick Edit Component Source File",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                    tooltip: "Open output component file in a popup editor."
                                },
                                handler: {
                                    testFunc: args => editorScope(args) && args.activeEditor.getSelectedComponents().length === 1,
                                    executeFunc: args => {
                                        args.activeEditor.openOutputFileQuickEditorDialog();
                                    }
                                },
                                keys: {
                                    key: "KeyQ"
                                }
                            });
                            if (phasereditor2d.ide.IDEPlugin.getInstance().isDesktopMode()) {
                                const editorName = phasereditor2d.ide.IDEPlugin.getInstance().getExternalEditorName();
                                manager.add({
                                    command: {
                                        id: usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE_IN_VSCODE,
                                        name: "Open Component Output File in " + editorName,
                                        category: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                        tooltip: "Open the compiler output file in the configured external editor (" + editorName + ")"
                                    },
                                    handler: {
                                        testFunc: args => {
                                            if (args.activeEditor instanceof UserComponentsEditor) {
                                                return args.activeEditor.getSelectedComponents().length === 1;
                                            }
                                            return false;
                                        },
                                        executeFunc: args => {
                                            const editor = args.activeEditor;
                                            const compiler = new usercomponent.UserComponentCompiler(editor.getInput(), editor.getModel());
                                            const component = editor.getSelectedComponents()[0];
                                            const file = compiler.getOutputFile(component.getName());
                                            if (file) {
                                                phasereditor2d.ide.IDEPlugin.getInstance().openFileExternalEditor(file);
                                            }
                                            else {
                                                alert(`Output from "${component.getName()}" not found.`);
                                            }
                                        }
                                    },
                                    keys: {
                                        control: true,
                                        alt: true,
                                        key: "KeyE"
                                    }
                                });
                            }
                        }
                        getSelectedComponents() {
                            return this.getViewer().getSelection().filter(o => o instanceof usercomponent.UserComponent);
                        }
                        getModel() {
                            return this._model;
                        }
                        revealComponent(compName) {
                            if (!this._createdPart) {
                                this._revealCompName = compName;
                            }
                            else {
                                this.revealComponentNow(compName);
                            }
                        }
                        revealComponentNow(compName) {
                            const comp = this._model.getComponents().find(c => c.getName() === compName);
                            if (comp) {
                                this.getViewer().setSelection([comp]);
                                this.getViewer().reveal(comp);
                            }
                        }
                        async onEditorInputContentChangedByExternalEditor() {
                            const sel = new Set(this.getViewer().getSelection().map(c => c.getName()));
                            await this.updateContent();
                            this.getViewer().setSelection(this._model.getComponents().filter(c => sel.has(c.getName())));
                            this.getViewer().repaint();
                        }
                        async createPart() {
                            super.createPart();
                            await this.updateContent();
                            this._createdPart = true;
                            if (this._revealCompName) {
                                this.revealComponentNow(this._revealCompName);
                            }
                            else {
                                this.getViewer().setSelection([]);
                            }
                        }
                        fillContextMenu(menu) {
                            menu.addCommand(usercomponent.CMD_ADD_USER_COMPONENT, {
                                text: "Add Component"
                            });
                            menu.addCommand(colibri.ui.ide.actions.CMD_DELETE);
                            menu.addSeparator();
                            const resourceMenu = new controls.Menu("Resources");
                            for (const mod of [false, true]) {
                                for (const ext of ["js", "ts"]) {
                                    resourceMenu.addAction({
                                        text: `Create UserComponent.${ext}${mod ? " (ES Module)" : ""}`,
                                        icon: phasereditor2d.webContentTypes.WebContentTypesPlugin
                                            .getInstance().getIcon(phasereditor2d.webContentTypes.ICON_FILE_SCRIPT),
                                        callback: async () => {
                                            const resources = usercomponent.UserComponentCodeResources.getInstance();
                                            const id = "usercomponent" + (mod ? ".module" : "") + "." + ext;
                                            const parent = this.getInput().getParent();
                                            const name = "UserComponent." + ext;
                                            if (parent.getFile(name)) {
                                                if (!confirm("The file already exists, do you want to overwrite it?")) {
                                                    return;
                                                }
                                            }
                                            const file = await resources.createFile(id, parent, name);
                                            colibri.Platform.getWorkbench().openEditor(file);
                                        }
                                    });
                                }
                            }
                            menu.addMenu(resourceMenu);
                            const compilerMenu = new controls.Menu("Compiler");
                            compilerMenu.addCommand(usercomponent.CMD_COMPILE_FILE);
                            compilerMenu.addSeparator();
                            compilerMenu.addCommand(usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE);
                            compilerMenu.addCommand(usercomponent.CMD_QUICK_EDIT_COMPONENT_FILE);
                            compilerMenu.addCommand(usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE_IN_VSCODE);
                            menu.addMenu(compilerMenu);
                        }
                        async doSave() {
                            const content = JSON.stringify(this._model.toJSON(), null, 4);
                            try {
                                await colibri.ui.ide.FileUtils.setFileString_async(this.getInput(), content);
                                this.setDirty(false);
                                this.compile();
                            }
                            catch (e) {
                                console.error(e);
                            }
                        }
                        openOutputFileQuickEditorDialog() {
                            const component = this.getSelectedComponents()[0];
                            const fileName = component.getName() + "." + (this._model.getOutputLang() === scene.core.json.SourceLang.JAVA_SCRIPT ? "js" : "ts");
                            const file = this.getInput().getSibling(fileName);
                            if (!file) {
                                return;
                            }
                            const state = this._outputFileEditorStateMap[fileName] || {};
                            const dlg = new colibri.ui.ide.QuickEditorDialog(file, state);
                            dlg.create();
                            dlg.addButton("Play", () => {
                                colibri.Platform.getWorkbench().getCommandManager()
                                    .executeCommand(phasereditor2d.ide.ui.actions.CMD_PLAY_PROJECT);
                            });
                            dlg.eventDialogClose.addListener(() => {
                                this._outputFileEditorStateMap[fileName] = dlg.getEditorState();
                                colibri.Platform.getWorkbench().setActiveEditor(this);
                            });
                        }
                        async compile() {
                            const compiler = new usercomponent.UserComponentCompiler(this.getInput(), this._model);
                            await compiler.compile();
                        }
                        async updateContent() {
                            const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(this.getInput());
                            const data = JSON.parse(content);
                            this._model.readJSON(data);
                            if (this.getViewer()) {
                                this.getViewer().setInput(this._model.getComponents());
                                this.refreshViewers();
                            }
                        }
                        refreshViewers() {
                            this.getViewer().repaint();
                            this._outlineProvider.repaint();
                        }
                        deleteSelection() {
                            const before = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            const deleteSet = new Set();
                            for (const obj of this.getViewer().getSelection()) {
                                if (obj instanceof usercomponent.UserComponent) {
                                    deleteSet.add(obj);
                                }
                                else {
                                    for (const obj2 of this._model.getComponents()) {
                                        if (obj2.getGameObjectType() === obj) {
                                            deleteSet.add(obj2);
                                        }
                                    }
                                }
                            }
                            this._model.setComponents(this._model.getComponents().filter(comp => !deleteSet.has(comp)));
                            this.getViewer().setInput(this._model.getComponents());
                            this.getViewer().setSelection([]);
                            this.setDirty(true);
                            const after = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            this.getUndoManager().add(new usercomponent.UserComponentsEditorSnapshotOperation(this, before, after));
                        }
                        addComponent() {
                            const before = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            const maker = new colibri.ui.ide.utils.NameMaker((comp) => comp.getName());
                            maker.update(this._model.getComponents());
                            const name = maker.makeName("Component");
                            const userComp = new usercomponent.UserComponent(name);
                            this._model.getComponents().push(userComp);
                            this.getViewer().setSelection([userComp]);
                            this.getViewer().reveal(userComp);
                            this.setDirty(true);
                            const after = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            this.getUndoManager().add(new usercomponent.UserComponentsEditorSnapshotOperation(this, before, after));
                        }
                        createFilteredViewer(viewer) {
                            return new controls.viewers.FilteredViewer(viewer, false);
                        }
                        createViewer() {
                            const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.editor.usercomponent.UserComponentsEditor");
                            viewer.setLabelProvider(new UserComponentSignatureLabelProvider());
                            viewer.setStyledLabelProvider(new UserComponentSignatureStyledLabelProvider());
                            viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                            viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(
                            // tslint:disable-next-line:new-parens
                            obj => new controls.viewers.IconImageCellRenderer(scene.ScenePlugin.getInstance().getIcon(scene.ICON_USER_COMPONENT))));
                            // tslint:disable-next-line:new-parens
                            viewer.setTreeRenderer(new class extends controls.viewers.TreeViewerRenderer {
                                constructor() {
                                    super(viewer);
                                }
                                prepareContextForText(args) {
                                    super.prepareContextForText(args);
                                    args.canvasContext.font = controls.getCanvasFontHeight() + "px Monospace";
                                }
                            });
                            viewer.setInput([]);
                            viewer.eventSelectionChanged.addListener(() => {
                                this._outlineProvider.setSelection(viewer.getSelection(), true, false);
                                this._outlineProvider.repaint();
                            });
                            viewer.eventOpenItem.addListener((elem) => {
                                const compiler = new usercomponent.UserComponentCompiler(this.getInput(), this._model);
                                const file = compiler.getOutputFile(elem.getName());
                                colibri.Platform.getWorkbench().openEditor(file);
                            });
                            return viewer;
                        }
                        getEditorViewerProvider(key) {
                            switch (key) {
                                case phasereditor2d.outline.ui.views.OutlineView.EDITOR_VIEWER_PROVIDER_KEY:
                                    return this._outlineProvider;
                                default:
                                    break;
                            }
                        }
                        getPropertyProvider() {
                            return this._propertyProvider;
                        }
                        createEditorToolbar(parent) {
                            const manager = new controls.ToolbarManager(parent);
                            manager.addCommand(usercomponent.CMD_ADD_USER_COMPONENT, {
                                showText: true,
                                text: "Add Component"
                            });
                            return manager;
                        }
                        runOperation(action) {
                            const before = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            action(this._model);
                            const after = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            this.getUndoManager().add(new usercomponent.UserComponentsEditorSnapshotOperation(this, before, after));
                            this.setDirty(true);
                            this.refreshViewers();
                        }
                    }
                    usercomponent.UserComponentsEditor = UserComponentsEditor;
                    class UserComponentSignatureLabelProvider {
                        getLabel(obj) {
                            const comp = obj;
                            const body = comp.getUserProperties().getProperties()
                                .map(p => p.getName() + ": " +
                                (p.getType() instanceof ui.sceneobjects.ExpressionPropertyType ?
                                    p.getType().getExpressionType()
                                    : p.getType().getName()))
                                .join(", ");
                            return `class ${comp.getName()} (gameObject: ${comp.getGameObjectType()}) { ${body} }`;
                        }
                    }
                    class UserComponentSignatureStyledLabelProvider {
                        getStyledTexts(obj, dark) {
                            const colorMap = UserComponentSignatureStyledLabelProvider.colorMap;
                            const colors = dark ? colorMap.dark : colorMap.light;
                            const comp = obj;
                            const result = [{
                                    text: "class ",
                                    color: colors.keyword
                                }, {
                                    text: comp.getName(),
                                    color: colors.typeName,
                                }, {
                                    text: " (gameObject: ",
                                    color: colors.default
                                }, {
                                    text: comp.getGameObjectType(),
                                    color: colors.typeName
                                }, {
                                    text: ") { ",
                                    color: colors.default
                                }];
                            const props = comp.getUserProperties().getProperties();
                            for (let i = 0; i < props.length; i++) {
                                const prop = props[i];
                                const typeName = prop.getType() instanceof ui.sceneobjects.ExpressionPropertyType ?
                                    prop.getType().getExpressionType()
                                    : prop.getType().getName();
                                if (i > 0) {
                                    result.push({
                                        text: ", ",
                                        color: colors.default
                                    });
                                }
                                result.push({
                                    text: prop.getName() + ": ",
                                    color: colors.default
                                }, {
                                    text: typeName,
                                    color: colors.typeName
                                });
                            }
                            result.push({
                                text: " }",
                                color: colors.default
                            });
                            return result;
                        }
                    }
                    UserComponentSignatureStyledLabelProvider.colorMap = {
                        light: {
                            keyword: "blue",
                            typeName: "#28809A",
                            default: "black"
                        },
                        dark: {
                            keyword: "#569CD6",
                            typeName: "#4BC1A9",
                            default: "white"
                        }
                    };
                })(usercomponent = editor_29.usercomponent || (editor_29.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_30) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class OutlineContentProvider {
                        constructor(editor) {
                            this._editor = editor;
                        }
                        getRoots(input) {
                            return [...new Set(input.getComponents().map(c => c.getGameObjectType()))];
                        }
                        getChildren(parent) {
                            return this._editor.getModel().getComponents().filter(c => c.getGameObjectType() === parent);
                        }
                    }
                    class UserComponentsEditorOutlineProvider extends colibri.ui.ide.EditorViewerProvider {
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        getContentProvider() {
                            // // tslint:disable-next-line:new-parens
                            // return new class extends controls.viewers.ArrayTreeContentProvider {
                            //     getRoots(input: UserComponentsModel) {
                            //         return input.getComponents();
                            //     }
                            // };
                            return new OutlineContentProvider(this._editor);
                        }
                        getLabelProvider() {
                            return new controls.viewers.LabelProvider(obj => {
                                return obj instanceof usercomponent.UserComponent ? obj.getName() : obj;
                            });
                        }
                        getCellRendererProvider() {
                            return new controls.viewers.EmptyCellRendererProvider(obj => new controls.viewers.IconImageCellRenderer(scene.ScenePlugin.getInstance().getIcon(obj instanceof usercomponent.UserComponent ?
                                scene.ICON_USER_COMPONENT : scene.ICON_GROUP)));
                        }
                        getTreeViewerRenderer(viewer) {
                            return new controls.viewers.TreeViewerRenderer(viewer);
                        }
                        getPropertySectionProvider() {
                            return this._editor.getPropertyProvider();
                        }
                        getInput() {
                            return this._editor.getModel();
                        }
                        preload(complete) {
                            return Promise.resolve();
                        }
                        getUndoManager() {
                            return this._editor.getUndoManager();
                        }
                        onViewerSelectionChanged(selection) {
                            const viewer = this._editor.getViewer();
                            viewer.setSelection(selection);
                            viewer.reveal(...selection);
                            viewer.repaint();
                        }
                        fillContextMenu(menu) {
                            this._editor.fillContextMenu(menu);
                        }
                    }
                    usercomponent.UserComponentsEditorOutlineProvider = UserComponentsEditorOutlineProvider;
                })(usercomponent = editor_30.usercomponent || (editor_30.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_31) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class UserComponentsEditorPropertySectionProvider extends controls.properties.PropertySectionProvider {
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        addSections(page, sections) {
                            sections.push(new usercomponent.UserComponentsCompilerSection(page));
                            sections.push(new usercomponent.UserComponentSection(page));
                            sections.push(new usercomponent.UserComponentPropertiesSection(page));
                        }
                        getEmptySelectionObject() {
                            return this._editor.getModel();
                        }
                    }
                    usercomponent.UserComponentsEditorPropertySectionProvider = UserComponentsEditorPropertySectionProvider;
                })(usercomponent = editor_31.usercomponent || (editor_31.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_32) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentsEditorSnapshotOperation extends colibri.ui.ide.undo.Operation {
                        constructor(editor, before, after) {
                            super();
                            this._editor = editor;
                            this._before = before;
                            this._after = after;
                        }
                        static takeSnapshot(editor) {
                            return {
                                selection: editor.getSelectedComponents().map((userComp) => userComp.getName()),
                                model: editor.getModel().toJSON()
                            };
                        }
                        loadSnapshot(data) {
                            this._editor.getModel().readJSON(data.model);
                            const sel = data.selection
                                .map(name => this._editor.getModel().getComponents().find(userComp => userComp.getName() === name))
                                .filter(userComp => userComp !== undefined);
                            const viewer = this._editor.getViewer();
                            viewer.setInput(this._editor.getModel().getComponents());
                            viewer.setSelection(sel);
                            viewer.reveal(...sel);
                            this._editor.refreshViewers();
                            this._editor.setDirty(true);
                        }
                        undo() {
                            this.loadSnapshot(this._before);
                        }
                        redo() {
                            this.loadSnapshot(this._after);
                        }
                    }
                    usercomponent.UserComponentsEditorSnapshotOperation = UserComponentsEditorSnapshotOperation;
                })(usercomponent = editor_32.usercomponent || (editor_32.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var write = colibri.core.json.write;
                    var read = colibri.core.json.read;
                    class UserComponentsModel {
                        constructor() {
                            this._components = [];
                            this.outputLang = scene.core.json.SourceLang.JAVA_SCRIPT;
                            this.javaScriptInitFieldsInConstructor = false;
                            this.insertSpaces = false;
                            this.tabSize = 4;
                            this.exportClass = false;
                            this.autoImport = false;
                        }
                        toJSON() {
                            const data = {
                                components: this._components.map(comp => comp.toJSON()),
                                meta: {
                                    app: "Phaser Editor 2D - Object Script Editor",
                                    url: "https://phasereditor2d.com",
                                    contentType: scene.core.CONTENT_TYPE_SCENE
                                }
                            };
                            write(data, "outputLang", this.outputLang, scene.core.json.SourceLang.JAVA_SCRIPT);
                            write(data, "javaScriptInitFieldsInConstructor", this.javaScriptInitFieldsInConstructor, false);
                            write(data, "insertSpaces", this.insertSpaces, false);
                            write(data, "tabSize", this.tabSize, 4);
                            write(data, "exportClass", this.exportClass, false);
                            write(data, "autoImport", this.autoImport, false);
                            return data;
                        }
                        readJSON(data) {
                            this.outputLang = read(data, "outputLang", scene.core.json.SourceLang.JAVA_SCRIPT);
                            this.javaScriptInitFieldsInConstructor = read(data, "javaScriptInitFieldsInConstructor", false);
                            this.insertSpaces = read(data, "insertSpaces", false);
                            this.tabSize = read(data, "tabSize", 4);
                            this.exportClass = read(data, "exportClass", false);
                            this.autoImport = read(data, "autoImport", false);
                            this._components = data.components.map(userCompData => {
                                const userComp = new usercomponent.UserComponent(userCompData.name);
                                userComp.readJSON(userCompData);
                                return userComp;
                            });
                        }
                        getOutputLang() {
                            return this.outputLang;
                        }
                        setOutputLang(outputLang) {
                            this.outputLang = outputLang;
                        }
                        getComponents() {
                            return this._components;
                        }
                        setComponents(components) {
                            this._components = components;
                        }
                    }
                    usercomponent.UserComponentsModel = UserComponentsModel;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                var read = colibri.core.json.read;
                var write = colibri.core.json.write;
                class Component {
                    constructor(obj, properties) {
                        this._obj = obj;
                        this._properties = new Set(properties);
                    }
                    getProperties() {
                        return this._properties;
                    }
                    getObject() {
                        return this._obj;
                    }
                    getEditorSupport() {
                        return this._obj.getEditorSupport();
                    }
                    getPropertyDefaultValue(prop) {
                        return this.getEditorSupport().getPropertyDefaultValue(prop);
                    }
                    write(ser, ...properties) {
                        for (const prop of properties) {
                            ser.write(prop.name, prop.getValue(this._obj), this.getPropertyDefaultValue(prop));
                        }
                    }
                    read(ser, ...properties) {
                        for (const prop of properties) {
                            const value = ser.read(prop.name, this.getPropertyDefaultValue(prop));
                            prop.setValue(this._obj, value);
                        }
                    }
                    writeLocal(ser, ...properties) {
                        for (const prop of properties) {
                            write(ser.getData(), prop.name, prop.getValue(this._obj), this.getPropertyDefaultValue(prop));
                        }
                    }
                    readLocal(ser, ...properties) {
                        for (const prop of properties) {
                            const value = read(ser.getData(), prop.name, this.getPropertyDefaultValue(prop));
                            prop.setValue(this._obj, value);
                        }
                    }
                    helperBuildSetObjectPropertyCodeDOM_StringProperty(args, properties, verbatim) {
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            if (verbatim) {
                                dom.value(args2.value);
                            }
                            else {
                                dom.valueLiteral(args2.value);
                            }
                            args.statements.push(dom);
                        });
                    }
                    buildSetObjectPropertyCodeDOM_StringProperty(args, ...properties) {
                        this.helperBuildSetObjectPropertyCodeDOM_StringProperty(args, properties, false);
                    }
                    buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, ...properties) {
                        this.helperBuildSetObjectPropertyCodeDOM_StringProperty(args, properties, true);
                    }
                    buildSetObjectPropertyCodeDOM_BooleanProperty(args, ...properties) {
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            dom.valueBool(args2.value);
                            args.statements.push(dom);
                        });
                    }
                    buildSetObjectPropertyCodeDOM(properties, codeDomBuilder) {
                        for (const prop of properties) {
                            const fieldCodeName = prop.codeName ?? prop.name;
                            const value = prop.getValue(this.getObject());
                            let local = true;
                            if (this.getEditorSupport().isPrefabInstance()) {
                                local = false;
                                if (prop instanceof sceneobjects.UserComponentPropertyWrapper) {
                                    local = this.getEditorSupport().isLocalUserProperty(prop);
                                }
                                if (!local) {
                                    if (this.getEditorSupport().isUnlockedProperty(prop)) {
                                        codeDomBuilder({ prop, fieldCodeName, value });
                                    }
                                }
                            }
                            if (local) {
                                const defValue = this.getPropertyDefaultValue(prop);
                                if (value !== defValue) {
                                    codeDomBuilder({ prop, fieldCodeName, value });
                                }
                            }
                        }
                    }
                    buildSetObjectPropertyCodeDOM_FloatProperty(args, ...properties) {
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            const codeValue = args2.prop.valueToCodeConverter ? args2.prop.valueToCodeConverter(args2.value) : args2.value;
                            dom.valueFloat(codeValue);
                            args.statements.push(dom);
                        });
                    }
                    async buildDependenciesHash(args) {
                        // nothing by default
                    }
                    writeJSON(ser) {
                        for (const prop of this.getProperties()) {
                            this.writeProperty(ser, prop);
                        }
                    }
                    writeProperty(ser, prop, local) {
                        local = local ?? prop.local;
                        if (local) {
                            this.writeLocal(ser, prop);
                        }
                        else {
                            this.write(ser, prop);
                        }
                    }
                    readJSON(ser) {
                        for (const prop of this.getProperties()) {
                            if (prop.local) {
                                this.readLocal(ser, prop);
                            }
                            else {
                                this.read(ser, prop);
                            }
                        }
                    }
                }
                sceneobjects.Component = Component;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./Component.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChildrenComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            ChildrenComponent.allowPickChildren,
                            ChildrenComponent.showChildrenInOutline
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        // nothing
                    }
                }
                ChildrenComponent.allowPickChildren = {
                    name: "allowPickChildren",
                    label: "Allow Picking Children In Scene",
                    tooltip: "If this object's children can be pickable (mouse-selected) in the scene.",
                    defValue: true,
                    local: true,
                    getValue: obj => obj.getEditorSupport().isAllowPickChildren(),
                    setValue: (obj, value) => obj.getEditorSupport().setAllowPickChildren(value)
                };
                ChildrenComponent.showChildrenInOutline = {
                    name: "showChildrenInOutline",
                    label: "Show Children In Outline",
                    tooltip: "If showing the children in the Outline view.",
                    defValue: true,
                    local: true,
                    getValue: obj => obj.getEditorSupport().isShowChildrenInOutline(),
                    setValue: (obj, value) => obj.getEditorSupport().setShowChildrenInOutline(value)
                };
                sceneobjects.ChildrenComponent = ChildrenComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_22) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SceneGameObjectSection extends ui.editor.properties.BaseSceneSection {
                    isPrefabSceneObject(obj) {
                        const support = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                        if (support) {
                            const scene = support.getScene();
                            if (scene.isPrefabSceneType()) {
                                if (scene.getPrefabObject() === obj) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    createGridElementWithPropertiesXY(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto auto 1fr auto 1fr";
                        return comp;
                    }
                    createGridElementWithPropertiesBoolXY(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto auto 1fr auto 1fr";
                        return comp;
                    }
                    createLock(parent, ...properties) {
                        const mutableIcon = new controls.IconControl();
                        const element = mutableIcon.getCanvas();
                        element.classList.add("PropertyLockIcon");
                        parent.appendChild(element);
                        const lockedIcon = scene_22.ScenePlugin.getInstance().getIcon(scene_22.ICON_LOCKED);
                        const unlockedIcon = scene_22.ScenePlugin.getInstance().getIcon(scene_22.ICON_UNLOCKED);
                        element.addEventListener("click", e => {
                            const unlocked = !this.isUnlocked(...properties);
                            this.getEditor().getUndoManager().add(new sceneobjects.PropertyUnlockOperation(this.getEditor(), this.getSelection(), properties, unlocked));
                        });
                        this.addUpdater(() => {
                            const thereIsPrefabInstances = this.getSelection()
                                .map(obj => obj.getEditorSupport().isPrefabInstance())
                                .find(b => b);
                            if (thereIsPrefabInstances) {
                                element.style.width = controls.RENDER_ICON_SIZE + "px";
                                const unlocked = this.isUnlocked(...properties);
                                mutableIcon.setIcon(unlocked ? unlockedIcon : lockedIcon);
                            }
                            else {
                                element.style.width = "0px";
                            }
                        });
                    }
                    isUnlocked(...properties) {
                        for (const obj of this.getSelection()) {
                            for (const property of properties) {
                                const locked = !obj.getEditorSupport().isUnlockedProperty(property);
                                if (locked) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    createNumberPropertyRow(parent, prop, fullWidth = true) {
                        this.createLock(parent, prop);
                        this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip))
                            .style.gridColumn = "2/ span 2";
                        this.createFloatField(parent, prop)
                            .style.gridColumn = fullWidth ? "4 / span 3" : "4";
                    }
                    createNumberProperty(parent, prop) {
                        this.createLock(parent, prop);
                        this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                        this.createFloatField(parent, prop);
                    }
                    createPropertyBoolean(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const elements = this.createBooleanField(parent, prop);
                        elements.labelElement.style.gridColumn = "2 / auto";
                        return elements;
                    }
                    createPropertyBoolXYRow(parent, propXY, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, propXY.x, propXY.y);
                            this.createLabel(parent, propXY.label, scene_22.PhaserHelp(propXY.tooltip));
                        }
                        else {
                            const label = this.createLabel(parent, propXY.label, scene_22.PhaserHelp(propXY.tooltip));
                            label.style.gridColumn = "2";
                        }
                        for (const prop of [propXY.x, propXY.y]) {
                            this.createBooleanField(parent, prop);
                        }
                    }
                    createPropertyFloatRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const text = this.createFloatField(parent, prop);
                        return text;
                    }
                    createPropertyStringRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const text = this.createStringField(parent, prop);
                        return text;
                    }
                    createPropertyStringDialogRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        return this.createStringDialogField(parent, prop);
                    }
                    createPropertyColorRow(parent, prop, allowAlpha = true, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const text = this.createColorField(parent, prop, allowAlpha);
                        return text;
                    }
                    createPropertyEnumRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const btn = this.createEnumField(parent, prop);
                        return btn;
                    }
                    createPropertyXYRow(parent, propXY, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, propXY.x, propXY.y);
                            this.createLabel(parent, propXY.label, scene_22.PhaserHelp(propXY.tooltip));
                        }
                        else {
                            const label = this.createLabel(parent, propXY.label, scene_22.PhaserHelp(propXY.tooltip));
                            label.style.gridColumn = "2";
                        }
                        for (const prop of [propXY.x, propXY.y]) {
                            this.createLabel(parent, prop.label, scene_22.PhaserHelp(prop.tooltip));
                            this.createFloatField(parent, prop);
                        }
                    }
                    createEnumField(parent, property, checkUnlocked = true, filter) {
                        const getItems = () => property.values
                            .filter(v => !filter || filter(v))
                            .map(value => {
                            return {
                                name: property.getValueLabel(value),
                                value
                            };
                        });
                        const btn = this.createMenuButton(parent, "", getItems, value => {
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            btn.disabled = checkUnlocked && !this.isUnlocked(property);
                            btn.textContent = this.flatValues_StringJoinDifferent(this.getSelection()
                                .map(obj => property.getValueLabel(property.getValue(obj))));
                        });
                        return btn;
                    }
                    // tslint:disable-next-line:ban-types
                    createFloatField(parent, property) {
                        const text = this.createText(parent, false);
                        text.addEventListener("change", e => {
                            const textValue = text.value;
                            let value;
                            if (textValue.trim() === "") {
                                value = property.defValue;
                            }
                            else {
                                value = this.parseNumberExpression(text);
                            }
                            if (isNaN(value)) {
                                this.updateWithSelection();
                            }
                            else {
                                this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                            }
                        });
                        this.addUpdater(() => {
                            text.readOnly = !this.isUnlocked(property);
                            text.value = this.flatValues_Number(this.getSelection()
                                .map(obj => property.getValue(obj)));
                        });
                        return text;
                    }
                    createStringField(parent, property, checkUnlock = true, readOnlyOnMultiple = false, multiLine = false) {
                        const text = multiLine ? this.createTextArea(parent, false) : this.createText(parent, false);
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                .map(obj => property.getValue(obj)));
                        });
                        return text;
                    }
                    createStringDialogField(parent, property, checkUnlock = true, readOnlyOnMultiple = false) {
                        const { text, btn } = this.createTextDialog(parent, property.label, false);
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                .map(obj => property.getValue(obj)));
                            btn.disabled = text.readOnly;
                        });
                        return text;
                    }
                    createColorField(parent, property, allowAlpha = true, checkUnlock = true, readOnlyOnMultiple = false) {
                        const colorElement = this.createColor(parent, false, allowAlpha);
                        const text = colorElement.text;
                        const btn = colorElement.btn;
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            btn.disabled = text.readOnly;
                            text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                .map(obj => property.getValue(obj)));
                            btn.style.background = text.value.endsWith("selected)") ? "transparent" : text.value;
                        });
                        return colorElement;
                    }
                    createBooleanField(parent, property, checkUnlock = true) {
                        const labelElement = this.createLabel(parent, property.label, scene_22.PhaserHelp(property.tooltip));
                        const checkElement = this.createCheckbox(parent, labelElement);
                        checkElement.addEventListener("change", e => {
                            const value = checkElement.checked;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            checkElement.disabled = checkUnlock && !this.isUnlocked(property);
                            const list = this.getSelection()
                                .map(obj => property.getValue(obj))
                                .filter(b => !b);
                            checkElement.checked = list.length === 0;
                        });
                        return {
                            labelElement,
                            checkElement
                        };
                    }
                }
                sceneobjects.SceneGameObjectSection = SceneGameObjectSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_22.ui || (scene_22.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChildrenSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ChildrenSection", "Children", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/container-object.html#container-properties";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.createBooleanField(comp, sceneobjects.ChildrenComponent.allowPickChildren, false);
                        this.createBooleanField(comp, sceneobjects.ChildrenComponent.showChildrenInOutline, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ChildrenComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ChildrenSection = ChildrenSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class DirtyObjectManager {
                    constructor(obj) {
                        this._object = obj;
                        this._properties = [];
                        this._values = [];
                    }
                    start(redrawCallback) {
                        const updateListener = () => {
                            if (this.isDirty()) {
                                redrawCallback();
                            }
                        };
                        const awakeListener = () => {
                            this._values = this._properties.map(p => p.getValue(this._object));
                            redrawCallback();
                            this._object.scene.events.on("update", updateListener);
                        };
                        this._object.scene.events.once("update", awakeListener);
                        this._object.once("destroy", () => {
                            this._object.scene.events.off("update", awakeListener);
                            this._object.scene.events.off("update", updateListener);
                        });
                    }
                    addProperties(...properties) {
                        this._properties.push(...properties);
                    }
                    addComponents(...compCtrs) {
                        for (const ctr of compCtrs) {
                            const comp = this._object.getEditorSupport().getComponent(ctr);
                            this.addProperties(...comp.getProperties());
                        }
                    }
                    getKey() {
                        const name = this._object.getEditorSupport().getExtension().getTypeName();
                        return `${name}[${this._values.map(v => JSON.stringify(v)).join(",")}]`;
                    }
                    isDirty() {
                        let dirty = false;
                        for (let i = 0; i < this._properties.length; i++) {
                            const v = this._properties[i].getValue(this._object);
                            if (v !== this._values[i]) {
                                this._values[i] = v;
                                dirty = true;
                            }
                        }
                        return dirty;
                    }
                }
                sceneobjects.DirtyObjectManager = DirtyObjectManager;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_23) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                let ObjectScope;
                (function (ObjectScope) {
                    ObjectScope["METHOD"] = "METHOD";
                    ObjectScope["CLASS"] = "CLASS";
                    ObjectScope["PUBLIC"] = "PUBLIC";
                    ObjectScope["NESTED_PREFAB"] = "NESTED_PREFAB";
                })(ObjectScope = sceneobjects.ObjectScope || (sceneobjects.ObjectScope = {}));
                class EditorSupport {
                    constructor(obj, label, scene) {
                        this._object = obj;
                        this._scene = scene;
                        this._label = label;
                        this._useGameObjectName = false;
                        this._scope = ObjectScope.METHOD;
                        this.setId(Phaser.Utils.String.UUID());
                    }
                    static getEditorSupport(obj) {
                        if (obj["getEditorSupport"]) {
                            const support = obj["getEditorSupport"]();
                            if (support instanceof EditorSupport)
                                return support;
                        }
                        return null;
                    }
                    computeContentHash() {
                        return "";
                    }
                    isMethodScope() {
                        return this._scope === ObjectScope.METHOD;
                    }
                    getObject() {
                        return this._object;
                    }
                    getLabel() {
                        return this._label;
                    }
                    setLabel(label) {
                        this._label = label;
                    }
                    isUseGameObjectName() {
                        return this._useGameObjectName;
                    }
                    setUseGameObjectName(useGameObjectName) {
                        this._useGameObjectName = useGameObjectName;
                    }
                    getScope() {
                        return this._scope;
                    }
                    isNestedPrefabScope() {
                        return this._scope === ObjectScope.NESTED_PREFAB;
                    }
                    isPublic() {
                        return this._scope === ObjectScope.PUBLIC
                            || this._scope === ObjectScope.NESTED_PREFAB;
                    }
                    setScope(scope) {
                        this._scope = scope;
                    }
                    getScene() {
                        return this._scene;
                    }
                    setScene(scene) {
                        this._scene = scene;
                    }
                    getPropertyDefaultValue(prop) {
                        return prop.defValue;
                    }
                }
                sceneobjects.EditorSupport = EditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_23.ui || (scene_23.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                /**
                 * This class provides the methods to build the CodeDOM of the different aspects
                 * of the code generation associated to game objects.
                 *
                 * Each object extension provides an instance of this class, that is used by the Scene compiler.
                 */
                class GameObjectCodeDOMBuilder {
                    /**
                     * Adds the X and Y arguments to the prefab's instance creation.
                     *
                     * @param args This method args.
                     */
                    buildCreatePrefabInstanceCodeDOM_XY_Arguments(args) {
                        const obj = args.obj;
                        const call = args.methodCallDOM;
                        if (obj.getEditorSupport().isUnlockedPropertyXY(sceneobjects.TransformComponent.position)) {
                            call.argFloat(obj.x);
                            call.argFloat(obj.y);
                        }
                        else {
                            call.arg("undefined");
                            call.arg("undefined");
                        }
                    }
                    /**
                     * Adds the Width and Height arguments to the prefab's instance creation.
                     *
                     * @param args This method args.
                     */
                    buildCreatePrefabInstanceCodeDOM_Size_Arguments(args) {
                        const obj = args.obj;
                        const call = args.methodCallDOM;
                        if (obj.getEditorSupport().isUnlockedPropertyXY(sceneobjects.SizeComponent.size)) {
                            call.argFloat(obj.width);
                            call.argFloat(obj.height);
                        }
                        else {
                            call.arg("undefined");
                            call.arg("undefined");
                        }
                    }
                    /**
                     * Adds the X and Y parameters to the `super` statement of a prefab constructor.
                     *
                     * @param args Method args
                     */
                    buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args) {
                        const obj = args.prefabObj;
                        const call = args.superMethodCallCodeDOM;
                        if (obj.getEditorSupport().isUnlockedPropertyXY(sceneobjects.TransformComponent.position)) {
                            call.arg(`x ?? ${sceneobjects.TransformComponent.x.getValue(obj)}`);
                            call.arg(`y ?? ${sceneobjects.TransformComponent.y.getValue(obj)}`);
                        }
                        else {
                            call.arg("x");
                            call.arg("y");
                        }
                    }
                    /**
                     * Adds the Width and Height parameters to the `super` statement of a prefab constructor.
                     *
                     * @param args Method args
                     */
                    buildPrefabConstructorDeclarationSupperCallCodeDOM_SizeParameters(args) {
                        const obj = args.prefabObj;
                        const call = args.superMethodCallCodeDOM;
                        if (obj.getEditorSupport().isUnlockedProperty(sceneobjects.SizeComponent.width)) {
                            call.arg("width ?? " + obj.width);
                            call.arg("height ?? " + obj.height);
                        }
                        else {
                            call.arg("width");
                            call.arg("height");
                        }
                    }
                }
                sceneobjects.GameObjectCodeDOMBuilder = GameObjectCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_24) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function isNestedPrefabInstance(obj) {
                    const support = GameObjectEditorSupport.getEditorSupport(obj);
                    if (support) {
                        return support.isNestedPrefabInstance();
                    }
                    return false;
                }
                sceneobjects.isNestedPrefabInstance = isNestedPrefabInstance;
                function isGameObject(obj) {
                    return GameObjectEditorSupport.hasEditorSupport(obj);
                }
                sceneobjects.isGameObject = isGameObject;
                function getObjectChildren(obj) {
                    if (obj instanceof sceneobjects.Layer || obj instanceof sceneobjects.Container) {
                        return obj.getChildren();
                    }
                    return [];
                }
                sceneobjects.getObjectChildren = getObjectChildren;
                function getObjectParent(obj) {
                    return GameObjectEditorSupport.getObjectParent(obj);
                }
                sceneobjects.getObjectParent = getObjectParent;
                function getObjectParentOrDisplayList(obj) {
                    return getObjectParent(obj) || obj.getEditorSupport().getScene().sys.displayList;
                }
                sceneobjects.getObjectParentOrDisplayList = getObjectParentOrDisplayList;
                class GameObjectEditorSupport extends sceneobjects.EditorSupport {
                    constructor(extension, obj, scene) {
                        super(obj, extension.getTypeName().toLowerCase(), scene);
                        this._extension = extension;
                        this._unlockedProperties = new Set();
                        this._serializables = [];
                        this._componentMap = new Map();
                        this._mutableNestedPrefab = false;
                        obj.setDataEnabled();
                        this.setId(Phaser.Utils.String.UUID());
                        this.addComponent(new sceneobjects.VariableComponent(obj));
                        this.addComponent(new sceneobjects.PrefabUserPropertyComponent(obj));
                        this.addComponent(new sceneobjects.UserComponentsEditorComponent(obj));
                        this.setInteractive();
                        scene.sys.displayList.add(obj);
                    }
                    static getObjectParent(obj) {
                        if (obj.parentContainer) {
                            return obj.parentContainer;
                        }
                        if (obj.displayList instanceof sceneobjects.Layer) {
                            return obj.displayList;
                        }
                        return null;
                    }
                    static getObjectChildren(obj) {
                        if (obj instanceof sceneobjects.Container
                            || obj instanceof sceneobjects.Layer
                            || obj instanceof Phaser.GameObjects.DisplayList) {
                            return obj.list;
                        }
                        return [];
                    }
                    getChildren() {
                        return GameObjectEditorSupport.getObjectChildren(this.getObject());
                    }
                    computeContentHashWithProperties(obj, ...properties) {
                        return properties.map(prop => prop.name + "=" + prop.getValue(obj)).join(";");
                    }
                    computeContentHashWithComponent(obj, ...compConstructors) {
                        const props = compConstructors.flatMap(ctr => [...obj.getEditorSupport().getComponent(ctr).getProperties()]);
                        return this.computeContentHashWithProperties(obj, ...props);
                    }
                    /**
                     * Destroy the object. Return `true` if it requires a complete refresh of the scene, to re-build all objects.
                     */
                    destroy() {
                        const obj = this.getObject();
                        obj.disableInteractive();
                        obj.destroy();
                        obj.active = false;
                        obj.visible = false;
                        // hack, to remove the object from the input list
                        const list = this.getScene().input["_list"];
                        const i = list.indexOf(obj);
                        if (i > 0) {
                            list.splice(i, 1);
                        }
                        return false;
                    }
                    hasProperty(property) {
                        for (const comp of this._componentMap.values()) {
                            if (comp.getProperties().has(property)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    hasUnlockedProperties() {
                        return this._unlockedProperties.size > 0;
                    }
                    isLockedProperty(property) {
                        return !this.isUnlockedProperty(property);
                    }
                    isUnlockedPropertyXY(property) {
                        return this.isUnlockedProperty(property.x) && this.isUnlockedProperty(property.y);
                    }
                    isUnlockedProperty(property) {
                        if (this.isPrefabInstance()) {
                            if (property instanceof sceneobjects.UserComponentPropertyWrapper) {
                                if (this.isLocalUserProperty(property)) {
                                    return true;
                                }
                            }
                            return this._unlockedProperties.has(property.name);
                        }
                        return true;
                    }
                    isLocalUserProperty(property) {
                        const userComp = property.getUserComponent();
                        const editorUserComp = this.getComponent(sceneobjects.UserComponentsEditorComponent);
                        if (editorUserComp.hasLocalUserComponent(userComp.getName())) {
                            return true;
                        }
                        return false;
                    }
                    setUnlockedProperty(property, unlock) {
                        if (unlock) {
                            this._unlockedProperties.add(property.name);
                        }
                        else {
                            this._unlockedProperties.delete(property.name);
                        }
                    }
                    _clearUnlockProperties() {
                        this._unlockedProperties.clear();
                    }
                    static async buildPrefabDependencyHash(builder, prefabId) {
                        if (!prefabId) {
                            return;
                        }
                        const finder = scene_24.ScenePlugin.getInstance().getSceneFinder();
                        const file = finder.getPrefabFile(prefabId);
                        if (!file) {
                            return;
                        }
                        const token = "prefab(" + prefabId + "," + file.getModTime() + ")";
                        builder.addPartialToken(token);
                        const sceneData = finder.getSceneData(file);
                        if (!sceneData) {
                            return;
                        }
                        for (const objData of sceneData.displayList) {
                            this.buildPrefabDependencyHash(builder, objData.prefabId);
                        }
                    }
                    async buildDependencyHash(args) {
                        GameObjectEditorSupport.buildPrefabDependencyHash(args.builder, this._prefabId);
                        for (const comp of this.getComponents()) {
                            comp.buildDependenciesHash(args);
                        }
                    }
                    getScreenBounds(camera) {
                        const sprite = this.getObject();
                        const points = [
                            new Phaser.Math.Vector2(0, 0),
                            new Phaser.Math.Vector2(0, 0),
                            new Phaser.Math.Vector2(0, 0),
                            new Phaser.Math.Vector2(0, 0)
                        ];
                        let w = sprite.width;
                        let h = sprite.height;
                        if (sprite instanceof Phaser.GameObjects.BitmapText) {
                            // the BitmapText.width is considered a displayWidth, it is already multiplied by the scale
                            w = w / sprite.scaleX;
                            h = h / sprite.scaleY;
                        }
                        const { originX, originY } = this.computeOrigin();
                        const x = -w * originX;
                        const y = -h * originY;
                        const tx = sprite.getWorldTransformMatrix();
                        tx.transformPoint(x, y, points[0]);
                        tx.transformPoint(x + w, y, points[1]);
                        tx.transformPoint(x + w, y + h, points[2]);
                        tx.transformPoint(x, y + h, points[3]);
                        return points.map(p => camera.getScreenPoint(p.x, p.y));
                    }
                    getOriginSectionId() {
                        return sceneobjects.OriginSection.SECTION_ID;
                    }
                    getOriginProperties() {
                        if (this.hasComponent(sceneobjects.OriginComponent)) {
                            return [sceneobjects.OriginComponent.originX, sceneobjects.OriginComponent.originY];
                        }
                        return [];
                    }
                    supportsOrigin() {
                        return this.getOriginProperties().length > 0;
                    }
                    computeOrigin() {
                        const { originX, originY } = this.getObject();
                        return { originX, originY };
                    }
                    computeDisplayOrigin() {
                        const { width, height } = this.computeSize();
                        const { originX, originY } = this.computeOrigin();
                        return {
                            displayOriginX: width * originX,
                            displayOriginY: height * originY
                        };
                    }
                    computeSize() {
                        const obj = this.getObject();
                        return { width: obj.width, height: obj.height };
                    }
                    // tslint:disable-next-line:ban-types
                    getComponent(ctr) {
                        return this._componentMap.get(ctr);
                    }
                    // tslint:disable-next-line:ban-types
                    hasComponent(ctr) {
                        return this._componentMap.has(ctr);
                    }
                    getComponents() {
                        return this._componentMap.values();
                    }
                    // tslint:disable-next-line:ban-types
                    static getObjectComponent(obj, ctr) {
                        if (this.hasEditorSupport(obj)) {
                            const support = obj.getEditorSupport();
                            return support.getComponent(ctr) ?? null;
                        }
                        return null;
                    }
                    static hasEditorSupport(obj) {
                        try {
                            // tslint:disable-next-line:ban-types
                            const support = obj["getEditorSupport"];
                            return support.apply(obj) instanceof GameObjectEditorSupport;
                        }
                        catch (e) {
                            // nothing
                        }
                        return false;
                    }
                    static getEditorSupport(obj) {
                        if (this.hasEditorSupport(obj)) {
                            return obj.getEditorSupport();
                        }
                        return null;
                    }
                    // tslint:disable-next-line:ban-types
                    static hasObjectComponent(obj, ctr) {
                        return this.getObjectComponent(obj, ctr) !== null;
                    }
                    addComponent(...components) {
                        for (const c of components) {
                            this._componentMap.set(c.constructor, c);
                        }
                        this._serializables.push(...components);
                    }
                    setNewId(sprite) {
                        this.setId(Phaser.Utils.String.UUID());
                    }
                    getExtension() {
                        return this._extension;
                    }
                    getId() {
                        return this.getObject().name;
                    }
                    setId(id) {
                        this.getObject().name = id;
                    }
                    getParentId() {
                        const parent = GameObjectEditorSupport.getObjectParent(this.getObject());
                        if (parent) {
                            return parent.getEditorSupport().getId();
                        }
                        return undefined;
                    }
                    /**
                     * Checks if it is a nested prefab instance that can be modified (published to the scene,
                     * accessible from the prefab instance's root).
                     *
                     * @returns If active.
                     */
                    isMutableNestedPrefabInstance() {
                        if (this._mutableNestedPrefab) {
                            const parentSupport = getObjectParent(this.getObject()).getEditorSupport();
                            return parentSupport.isMutableNestedPrefabInstance() || parentSupport.isPrefabInstanceRoot();
                        }
                        return false;
                    }
                    _setMutableNestedPrefab(b) {
                        this._mutableNestedPrefab = b;
                    }
                    isRootPrefabDefined() {
                        return this.isPrefabInstance() && !this.isNestedPrefabDefined();
                    }
                    isNestedPrefabDefined() {
                        const finder = scene_24.ScenePlugin.getInstance().getSceneFinder();
                        if (this.isPrefabInstance()) {
                            const id = finder.getOriginalPrefabId(this.getPrefabId());
                            return finder.isNestedPrefab(id);
                        }
                        return false;
                    }
                    /**
                     * Checks if the object is a prefab instance and the parent isn't a prefab instance.
                     *
                     * @returns If it is the root.
                     */
                    isPrefabInstanceRoot() {
                        if (this.isPrefabInstance() && !this.isNestedPrefabInstance()) {
                            const parent = getObjectParent(this.getObject());
                            if (!parent || !parent.getEditorSupport().isPrefabInstance()) {
                                return true;
                            }
                        }
                        return false;
                    }
                    isNestedPrefabInstance() {
                        return this.isPrefabInstance() && this.getOwnerPrefabInstance() !== this.getObject();
                    }
                    isPrefabInstance() {
                        return this._prefabId !== undefined && this._prefabId !== null;
                    }
                    /**
                     * Checks if the object is a child or nested child of prefab instance.
                     *
                     * @returns If it is element.
                     */
                    isPrefabInstanceElement() {
                        const owner = this.getOwnerPrefabInstance();
                        if (owner) {
                            return owner !== this.getObject();
                        }
                        return false;
                    }
                    getAllParents() {
                        const list = [];
                        this.getAllParents2(this.getObject(), list);
                        return list;
                    }
                    getSizeProperties() {
                        if (this.hasComponent(sceneobjects.SizeComponent)) {
                            return [sceneobjects.SizeComponent.width, sceneobjects.SizeComponent.height];
                        }
                        return [];
                    }
                    getSizeSectionId() {
                        return sceneobjects.SizeSection.SECTION_ID;
                    }
                    isDescendentOf(parent) {
                        const set = new Set(this.getAllParents());
                        return set.has(parent);
                    }
                    getAllParents2(obj, list) {
                        const objParent = GameObjectEditorSupport.getObjectParent(obj);
                        if (objParent) {
                            list.push(objParent);
                            this.getAllParents2(objParent, list);
                        }
                        return list;
                    }
                    isScenePrefabObject() {
                        return this.getScene().isPrefabSceneType() && this.getScene().getPrefabObject() === this.getObject();
                    }
                    getNestedActivePrefabInstances() {
                        if (this.isPrefabInstance()) {
                            const children = sceneobjects.getObjectChildren(this.getObject());
                            return children
                                .filter(obj => obj.getEditorSupport().isMutableNestedPrefabInstance());
                        }
                        return [];
                    }
                    getOwnerPrefabInstance() {
                        const parents = this.getAllParents().reverse();
                        for (const parent of parents) {
                            if (parent.getEditorSupport().isPrefabInstance()) {
                                return parent;
                            }
                        }
                        if (this.isPrefabInstance()) {
                            return this.getObject();
                        }
                        return null;
                    }
                    getPrefabId() {
                        return this._prefabId;
                    }
                    setPrefabId(id) {
                        this._prefabId = id;
                    }
                    getPrefabName() {
                        const file = this.getPrefabFile();
                        if (file) {
                            return file.getNameWithoutExtension();
                        }
                        return null;
                    }
                    getPrefabFile() {
                        if (this._prefabId) {
                            const finder = scene_24.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getPrefabFile(this._prefabId);
                            return file;
                        }
                        return null;
                    }
                    getPrefabOrNestedPrefabFile() {
                        const finder = scene_24.ScenePlugin.getInstance().getSceneFinder();
                        if (this.isNestedPrefabInstance()) {
                            const originalId = finder.getOriginalPrefabId(this._prefabId);
                            if (finder.isNestedPrefab(originalId)) {
                                return null;
                            }
                            else {
                                return finder.getPrefabFile(originalId);
                            }
                        }
                        return this.getPrefabFile();
                    }
                    getPrefabData() {
                        if (this._prefabId) {
                            const finder = scene_24.ScenePlugin.getInstance().getSceneFinder();
                            const data = finder.getPrefabData(this._prefabId);
                            return data;
                        }
                        return null;
                    }
                    getPrefabSettings() {
                        if (this._prefabId) {
                            const finder = scene_24.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getPrefabFile(this._prefabId);
                            if (file) {
                                return finder.getSceneSettings(file);
                            }
                        }
                        return null;
                    }
                    getPrefabSerializer() {
                        const data = this.getPrefabData();
                        if (data) {
                            return this.getScene().getMaker().getSerializer(data);
                        }
                        return null;
                    }
                    getObjectType() {
                        const ser = this.getScene().getMaker().getSerializer({
                            id: this.getId(),
                            type: this._extension.getTypeName(),
                            prefabId: this._prefabId,
                            label: "temporal"
                        });
                        return ser.getType();
                    }
                    getPhaserType() {
                        const ser = this.getScene().getMaker().getSerializer({
                            id: this.getId(),
                            type: this._extension.getTypeName(),
                            prefabId: this._prefabId,
                            label: "temporal",
                        });
                        return ser.getPhaserType();
                    }
                    getSerializer(data) {
                        return this.getScene().getMaker().getSerializer(data);
                    }
                    writeJSON(data) {
                        if (this.isPrefabInstance()) {
                            data.prefabId = this._prefabId;
                        }
                        else {
                            data.type = this._extension.getTypeName();
                        }
                        data.id = this.getId();
                        if (this._prefabId && this._unlockedProperties.size > 0) {
                            data["unlock"] = [...this._unlockedProperties];
                        }
                        const ser = this.getSerializer(data);
                        for (const s of this._serializables) {
                            s.writeJSON(ser);
                        }
                    }
                    readJSON(data) {
                        const ser = this.getSerializer(data);
                        this.setId(data.id);
                        this._prefabId = data.prefabId;
                        this._unlockedProperties = new Set(data["unlock"] ?? []);
                        for (const s of this._serializables) {
                            s.readJSON(ser);
                        }
                    }
                }
                sceneobjects.GameObjectEditorSupport = GameObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_24.ui || (scene_24.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_25) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class LoaderUpdaterExtension extends colibri.Extension {
                    constructor() {
                        super(LoaderUpdaterExtension.POINT_ID);
                    }
                }
                LoaderUpdaterExtension.POINT_ID = "phasereditor2d.scene.ui.sceneobjects.AssetLoaderExtension";
                sceneobjects.LoaderUpdaterExtension = LoaderUpdaterExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_25.ui || (scene_25.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./LoaderUpdaterExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_26) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ImageLoaderExtension extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(game) {
                        const list = game.textures.list;
                        for (const key in list) {
                            if (key === "__DEFAULT" || key === "__MISSING") {
                                continue;
                            }
                            if (list.hasOwnProperty(key)) {
                                const texture = list[key];
                                texture.destroy();
                                delete list[key];
                            }
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem
                            || asset instanceof phasereditor2d.pack.core.AssetPackImageFrame;
                    }
                    async updateLoader(scene, asset) {
                        let imageFrameContainerPackItem = null;
                        if (asset instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                            imageFrameContainerPackItem = asset;
                        }
                        else if (asset instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                            imageFrameContainerPackItem = asset.getPackItem();
                        }
                        if (imageFrameContainerPackItem !== null) {
                            await imageFrameContainerPackItem.preload();
                            await imageFrameContainerPackItem.preloadImages();
                            imageFrameContainerPackItem.addToPhaserCache(scene.game, scene.getPackCache());
                        }
                    }
                    async updateLoaderWithObjData(scene, data) {
                        const serializer = new scene_26.core.json.Serializer(data);
                        const textureKeys = serializer.read("texture");
                        if (textureKeys) {
                            const { key, frame } = textureKeys;
                            if (key) {
                                const finder = scene.getMaker().getPackFinder();
                                const asset = finder.getAssetPackItemImage(key, frame);
                                if (asset) {
                                    if (this.acceptAsset(asset)) {
                                        await this.updateLoader(scene, asset);
                                    }
                                }
                            }
                        }
                    }
                }
                sceneobjects.ImageLoaderExtension = ImageLoaderExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_26.ui || (scene_26.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_27) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function interactive_shape(hitArea, x, y, obj) {
                    const sprite = obj;
                    return sprite.geom.contains(x, y);
                }
                sceneobjects.interactive_shape = interactive_shape;
                function interactive_getAlpha_SharedTexture(hitArea, x, y, obj) {
                    const sprite = obj;
                    const textureManager = obj.getEditorSupport().getScene().textures;
                    if (sprite.flipX) {
                        x = 2 * sprite.width * sprite.originX - x;
                    }
                    if (sprite.flipY) {
                        y = 2 * sprite.height * sprite.originY - y;
                    }
                    const alpha = textureManager.getPixelAlpha(x, y, sprite.texture.key, sprite.frame.name);
                    return alpha > 0;
                }
                sceneobjects.interactive_getAlpha_SharedTexture = interactive_getAlpha_SharedTexture;
                function interactive_getAlpha_RenderTexture(hitArea, x, y, obj) {
                    const sprite = obj;
                    // TODO: lets fix the bound checking.
                    // const hitBounds = x >= 0 && y >= 0 && x <= sprite.width && y <= sprite.height;
                    // if (!hitBounds) {
                    //     return false;
                    // }
                    const scene = obj.getEditorSupport().getScene();
                    const renderTexture = new Phaser.GameObjects.RenderTexture(scene, 0, 0, 5, 5);
                    const scaleX = sprite.scaleX;
                    const scaleY = sprite.scaleY;
                    const originX = sprite.originX;
                    const originY = sprite.originY;
                    const angle = sprite.angle;
                    sprite.setScale(1, 1);
                    sprite.setOrigin(0, 0);
                    sprite.setAngle(0);
                    renderTexture.draw([sprite], -x, -y);
                    sprite.setScale(scaleX, scaleY);
                    sprite.setOrigin(originX, originY);
                    sprite.setAngle(angle);
                    const colorArray = [];
                    // catches an error caused by a Phaser bug.
                    try {
                        renderTexture.snapshotPixel(0, 0, (c) => {
                            colorArray[0] = c;
                        });
                    }
                    catch (e) {
                        console.log(e);
                        return x >= 0 && y >= 0 && x <= sprite.width && y <= sprite.height;
                    }
                    renderTexture.destroy();
                    const color = colorArray[0];
                    const alpha = color ? color.alpha : 0;
                    return alpha > 0;
                }
                sceneobjects.interactive_getAlpha_RenderTexture = interactive_getAlpha_RenderTexture;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_27.ui || (scene_27.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                function parseColor(color) {
                    const rgba = controls.Colors.parseColor(color);
                    const result = Phaser.Display.Color.GetColor(rgba.r, rgba.g, rgba.b);
                    return result;
                }
                function NumberColorProperty(name, defValue, label, tooltip) {
                    return {
                        name,
                        defValue: defValue,
                        label,
                        tooltip,
                        local: false,
                        getValue: obj => {
                            const val = obj["color__" + name];
                            return val === undefined ? defValue : val;
                        },
                        setValue: (obj, value) => {
                            if (typeof (value) === "string" && value.trim() === "") {
                                value = defValue;
                            }
                            // update the real object color property
                            try {
                                const color = parseColor(value);
                                obj[name] = color;
                                // store the original value in the object
                                obj["color__" + name] = value;
                            }
                            catch (e) {
                                // possible color syntax error.
                                console.log(e);
                            }
                        }
                    };
                }
                sceneobjects.NumberColorProperty = NumberColorProperty;
                function NumberColorPropertyCodeDomAdapter(p) {
                    const name = p.name;
                    const defValue = parseColor(p.defValue);
                    return {
                        name: name,
                        defValue,
                        label: p.label,
                        tooltip: p.tooltip,
                        local: p.local,
                        getValue: obj => {
                            const val = obj["color__" + name];
                            if (val === undefined) {
                                return defValue;
                            }
                            const color = parseColor(val);
                            return color;
                        },
                        setValue: (obj, value) => {
                            throw new Error("Unreachable code!");
                        }
                    };
                }
                sceneobjects.NumberColorPropertyCodeDomAdapter = NumberColorPropertyCodeDomAdapter;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectListDocSection extends ui.editor.properties.DocsSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ObjectListSection");
                    }
                    getHelp() {
                        // tslint:disable-next-line:no-trailing-whitespace
                        const help = `An array of objects. Like in:

\`\`\`
const itemList = [collectable1,
    collectable2,
    coin1,
    coin2];
\`\`\`

`;
                        return help;
                    }
                    canEdit(obj, n) {
                        return obj === sceneobjects.ObjectList;
                    }
                }
                sceneobjects.ObjectListDocSection = ObjectListDocSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../editor/properties/DocsSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectTypeDocSection extends ui.editor.properties.DocsSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ObjectTypeDocSection");
                    }
                    getHelp() {
                        return this.getSelectionFirstElement().getHelp();
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.SceneObjectExtension;
                    }
                }
                sceneobjects.ObjectTypeDocSection = ObjectTypeDocSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ParentGameObjectEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor() {
                        super(...arguments);
                        this._allowPickChildren = true;
                        this._showChildrenInOutline = true;
                    }
                    isAllowPickChildren() {
                        return this._allowPickChildren;
                    }
                    setAllowPickChildren(childrenPickable) {
                        this._allowPickChildren = childrenPickable;
                    }
                    isShowChildrenInOutline() {
                        return this._showChildrenInOutline;
                    }
                    setShowChildrenInOutline(showChildrenInOutline) {
                        this._showChildrenInOutline = showChildrenInOutline;
                    }
                    setInteractive() {
                        // nothing
                    }
                    destroy() {
                        for (const obj of this.getObject().getChildren()) {
                            obj.getEditorSupport().destroy();
                        }
                        super.destroy();
                    }
                    getCellRenderer() {
                        if (this.isPrefabInstance() && !this.isNestedPrefabInstance()) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getPrefabFile(this.getPrefabId());
                            if (file) {
                                const image = ui.SceneThumbnailCache.getInstance().getContent(file);
                                if (image) {
                                    return new controls.viewers.ImageCellRenderer(image);
                                }
                            }
                        }
                        return new controls.viewers.IconImageCellRenderer(scene.ScenePlugin.getInstance().getIcon(scene.ICON_GROUP));
                    }
                    writeJSON(containerData) {
                        super.writeJSON(containerData);
                        this.writeJSON_children(this.getObject(), containerData);
                    }
                    readJSON(containerData) {
                        super.readJSON(containerData);
                        this.readJSON_children(this.getObject(), containerData);
                    }
                    writeJSON_children(container, containerData) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const support = container.getEditorSupport();
                        if (support.isPrefabInstance()) {
                            containerData.nestedPrefabs = container.getChildren()
                                .filter(obj => obj.getEditorSupport().isMutableNestedPrefabInstance())
                                .filter(obj => finder.existsPrefab(obj.getEditorSupport().getPrefabId()))
                                .map(obj => {
                                const objData = {};
                                obj.getEditorSupport().writeJSON(objData);
                                return objData;
                            })
                                .filter(data => (data.nestedPrefabs ?? []).length > 0
                                || (data.unlock ?? []).length > 0
                                || (data.components ?? []).length > 0);
                        }
                        else {
                            containerData.list = container.getChildren().map(obj => {
                                const objData = {};
                                obj.getEditorSupport().writeJSON(objData);
                                return objData;
                            });
                        }
                    }
                    readJSON_children(container, containerData) {
                        const support = container.getEditorSupport();
                        const ser = support.getSerializer(containerData);
                        const originalChildren = ser.read("list", []);
                        const maker = support.getScene().getMaker();
                        container.removeAll(true);
                        const children = containerData.prefabId ?
                            ParentGameObjectEditorSupport.buildPrefabChildrenData(containerData, originalChildren) : originalChildren;
                        let i = 0;
                        for (const childData of children) {
                            // creates an empty object
                            const sprite = maker.createObject({
                                id: childData.id,
                                prefabId: childData.prefabId,
                                type: childData.type,
                                label: childData.label,
                            });
                            if (sprite) {
                                container.add(sprite);
                                const originalData = originalChildren[i];
                                if (originalData.scope === sceneobjects.ObjectScope.NESTED_PREFAB) {
                                    sprite.getEditorSupport()._setMutableNestedPrefab(true);
                                }
                                // updates the object with the final data
                                sprite.getEditorSupport().readJSON(childData);
                            }
                            i++;
                        }
                    }
                    static buildPrefabChildrenData(objData, originalPrefabChildren) {
                        const result = [];
                        const localNestedPrefabs = objData.nestedPrefabs ?? [];
                        for (const originalChild of originalPrefabChildren) {
                            if (originalChild.scope !== sceneobjects.ObjectScope.NESTED_PREFAB) {
                                result.push(originalChild);
                            }
                            else {
                                // find a local nested prefab
                                let localNestedPrefab;
                                for (const local of localNestedPrefabs) {
                                    const localOriginalIdOfNestedPrefab = this.findOriginalIdOfNestedPrefab(local);
                                    if (localOriginalIdOfNestedPrefab === originalChild.id) {
                                        const remoteNestedPrefab = this.findRemoteNestedPrefab(objData.prefabId, originalChild.id);
                                        if (remoteNestedPrefab) {
                                            localNestedPrefab = colibri.core.json.copy(local);
                                            localNestedPrefab.prefabId = remoteNestedPrefab.id;
                                        }
                                        else {
                                            localNestedPrefab = local;
                                        }
                                        break;
                                    }
                                }
                                if (localNestedPrefab) {
                                    result.push(localNestedPrefab);
                                }
                                else {
                                    // we don't have a local prefab, find one remote and create a pointer to it
                                    const remoteNestedPrefab = this.findRemoteNestedPrefab(objData.prefabId, originalChild.id);
                                    if (remoteNestedPrefab) {
                                        // we found a remote nested prefab, create a link to it
                                        const nestedPrefab = {
                                            id: Phaser.Utils.String.UUID(),
                                            prefabId: remoteNestedPrefab.id,
                                            label: remoteNestedPrefab.label,
                                        };
                                        result.push(nestedPrefab);
                                    }
                                    else {
                                        // ok, just create a link with the original child
                                        const nestedPrefab = {
                                            id: Phaser.Utils.String.UUID(),
                                            prefabId: originalChild.id,
                                            label: originalChild.label,
                                        };
                                        result.push(nestedPrefab);
                                    }
                                }
                            }
                        }
                        return result;
                    }
                    static findRemoteNestedPrefab(parentPrefabId, originalNestedPrefabId) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabData = finder.getPrefabData(parentPrefabId);
                        if (!prefabData) {
                            return null;
                        }
                        const nestedPrefab = (prefabData.nestedPrefabs ?? []).find(obj => {
                            // const thisOriginalId = finder.getOriginalPrefabId(obj.prefabId);
                            const thisOriginalId = this.findOriginalIdOfNestedPrefab(obj);
                            return thisOriginalId === originalNestedPrefabId;
                        });
                        if (nestedPrefab) {
                            return nestedPrefab;
                        }
                        if (prefabData.prefabId) {
                            return this.findRemoteNestedPrefab(prefabData.prefabId, originalNestedPrefabId);
                        }
                        return null;
                    }
                    static findOriginalIdOfNestedPrefab(obj) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        if (obj.prefabId && finder.isNestedPrefab(obj.prefabId)) {
                            const prefabData = finder.getPrefabData(obj.prefabId);
                            return this.findOriginalIdOfNestedPrefab(prefabData);
                        }
                        return obj.id;
                    }
                    async buildDependencyHash(args) {
                        super.buildDependencyHash(args);
                        if (!this.isPrefabInstance()) {
                            for (const obj of this.getObject().getChildren()) {
                                obj.getEditorSupport().buildDependencyHash(args);
                            }
                        }
                    }
                }
                sceneobjects.ParentGameObjectEditorSupport = ParentGameObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SceneObjectExtension extends colibri.Extension {
                    constructor(config) {
                        super(config.extensionPoint);
                        this._typeName = config.typeName;
                        this._typeNameAlias = config.typeNameAlias || [];
                        this._phaserTypeName = config.phaserTypeName;
                        this._category = config.category;
                        this._iconDescriptor = config.icon;
                    }
                    /**
                     * Some types like TilemapLayer are too complex to be included in a prefab instance.
                     * For now, those types should be excluded from a prefab scene.
                     */
                    isAvailableAsPrefabElement() {
                        return true;
                    }
                    /**
                     * Collect the data used to create a new, empty object. For example, a BitmapText requires
                     * a BitmapFont key to be created, so this method opens a dialog to select the font.
                     */
                    async collectExtraDataForCreateDefaultObject(editor) {
                        return {};
                    }
                    getIcon() {
                        return this._iconDescriptor.getIcon();
                    }
                    getBlockCellRenderer() {
                        return new controls.viewers.IconImageCellRenderer(this.getIcon());
                    }
                    getCategory() {
                        return this._category;
                    }
                    getTypeName() {
                        return this._typeName;
                    }
                    getTypeNameAlias() {
                        return this._typeNameAlias;
                    }
                    getPhaserTypeName() {
                        return this._phaserTypeName;
                    }
                    getHelp() {
                        return scene.ScenePlugin.getInstance().getPhaserDocs().getDoc(this.getPhaserTypeName());
                    }
                }
                sceneobjects.SceneObjectExtension = SceneObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneObjectExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SceneGameObjectExtension extends sceneobjects.SceneObjectExtension {
                    constructor(config) {
                        super({
                            extensionPoint: SceneGameObjectExtension.POINT_ID,
                            ...config
                        });
                    }
                    /**
                     * Adapt the data taken from a type conversion.
                     *
                     * @param serializer Serializer of the data resulted by the type-conversion.
                     * @param originalObject The original object that was converted.
                     * @param extraData Sometimes, to create the object, some extra data is needed.
                     * For example, the bitmap font of a bitmap text.
                     */
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        // nothing by default
                    }
                }
                SceneGameObjectExtension.POINT_ID = "phasereditor2d.scene.ui.SceneGameObjectExtension";
                sceneobjects.SceneGameObjectExtension = SceneGameObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_28) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ScenePlainObjectEditorSupport extends sceneobjects.EditorSupport {
                    constructor(extension, obj, scene) {
                        super(obj, extension.getTypeName().toLowerCase(), scene);
                        this._extension = extension;
                        this.setScope(sceneobjects.ObjectScope.CLASS);
                    }
                    writeJSON(objData) {
                        objData.id = this._id;
                        objData.type = this._extension.getTypeName();
                        objData.label = this.getLabel();
                        colibri.core.json.write(objData, "scope", this.getScope(), sceneobjects.ObjectScope.CLASS);
                    }
                    readJSON(objData) {
                        this._id = objData.id;
                        this.setScope(colibri.core.json.read(objData, "scope", sceneobjects.ObjectScope.CLASS));
                        this.setLabel(objData.label);
                    }
                    getExtension() {
                        return this._extension;
                    }
                    getCellRenderer() {
                        return new controls.viewers.IconImageCellRenderer(this._extension.getIcon());
                    }
                    getId() {
                        return this._id;
                    }
                    setId(id) {
                        this._id = id;
                    }
                    getPhaserType() {
                        return this._extension.getPhaserTypeName();
                    }
                    static hasEditorSupport(obj) {
                        if (typeof obj.getEditorSupport === "function") {
                            return obj.getEditorSupport() instanceof ScenePlainObjectEditorSupport;
                        }
                        return false;
                    }
                }
                sceneobjects.ScenePlainObjectEditorSupport = ScenePlainObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_28.ui || (scene_28.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScenePlainObjectExtension extends sceneobjects.SceneObjectExtension {
                    constructor(config) {
                        super({
                            extensionPoint: ScenePlainObjectExtension.POINT_ID,
                            ...config
                        });
                    }
                }
                ScenePlainObjectExtension.POINT_ID = "phasereditor2d.scene.ui.sceneobjects.ScenePlainObjectExtension";
                sceneobjects.ScenePlainObjectExtension = ScenePlainObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScenePlainObjectVariableSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ScenePlainObjectVariableSection", "Variable", false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name");
                            const text = this.createText(comp);
                            text.addEventListener("change", e => {
                                this.performChange(objects => {
                                    const obj = objects[0];
                                    obj.getEditorSupport().setLabel(text.value);
                                });
                            });
                            this.addUpdater(() => {
                                text.readOnly = this.getSelection().length !== 1;
                                text.value = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => obj.getEditorSupport().getLabel()));
                            });
                        }
                        {
                            // Type
                            this.createLabel(comp, "Type");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => obj.getEditorSupport().getExtension().getTypeName()));
                            });
                        }
                        {
                            // Scope
                            this.createLabel(comp, "Scope", "The lexical scope of the object.");
                            const items = [{
                                    name: "Method",
                                    value: sceneobjects.ObjectScope.METHOD
                                }, {
                                    name: "Class",
                                    value: sceneobjects.ObjectScope.CLASS
                                }, {
                                    name: "Public",
                                    value: sceneobjects.ObjectScope.PUBLIC
                                }];
                            const btn = this.createMenuButton(comp, "", () => items, scope => {
                                this.performChange(objects => {
                                    for (const obj of objects) {
                                        obj.getEditorSupport().setScope(scope);
                                    }
                                });
                            });
                            this.addUpdater(() => {
                                btn.textContent = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => {
                                    const scope = obj.getEditorSupport().getScope();
                                    return items.find(i => i.value === scope).name;
                                }));
                            });
                        }
                    }
                    performChange(performChange) {
                        this.getUndoManager().add(new ui.editor.undo.SceneSnapshotOperation(this.getEditor(), async () => {
                            performChange(this.getSelection());
                        }));
                    }
                    canEdit(obj, n) {
                        return sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ScenePlainObjectVariableSection = ScenePlainObjectVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function SimpleProperty(name, defValue, label, tooltip, local = false, afterSetValue) {
                    return {
                        name,
                        defValue,
                        label,
                        tooltip: tooltip,
                        local,
                        getValue: obj => obj[name],
                        setValue: (obj, value) => {
                            obj[name] = value;
                            if (afterSetValue) {
                                afterSetValue(obj);
                            }
                        }
                    };
                }
                sceneobjects.SimpleProperty = SimpleProperty;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [SizeComponent.width, SizeComponent.height]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const prop = SizeComponent.size;
                        if (support.isNestedPrefabInstance()
                            && support.isUnlockedPropertyXY(prop)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setSize", args.objectVarName);
                            dom.argFloat(prop.x.getValue(obj));
                            dom.argFloat(prop.y.getValue(obj));
                            args.statements.push(dom);
                            args.statements.push(new scene.core.code.MethodCallCodeDOM("updateDisplayOrigin", args.objectVarName));
                        }
                    }
                }
                // static width = SimpleProperty("width", 0, "Width", "The object's width.", false, updateDisplayOrigin);
                // static height = SimpleProperty("height", 0, "Height", "The object's height.", false, updateDisplayOrigin);
                SizeComponent.width = {
                    name: "width",
                    defValue: 0,
                    tooltip: "The object's width.",
                    local: false,
                    getValue: obj => obj.width,
                    setValue: (obj, value) => {
                        obj.setSize(value, obj.height);
                        obj.updateDisplayOrigin();
                    }
                };
                SizeComponent.height = {
                    name: "height",
                    defValue: 0,
                    tooltip: "The object's height.",
                    local: false,
                    getValue: obj => obj.height,
                    setValue: (obj, value) => {
                        obj.setSize(obj.width, value);
                        obj.updateDisplayOrigin();
                    }
                };
                SizeComponent.size = {
                    label: "Size",
                    x: SizeComponent.width,
                    y: SizeComponent.height
                };
                sceneobjects.SizeComponent = SizeComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, SizeSection.SECTION_ID, "Size", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.SizeComponent.size);
                    }
                    canEdit(obj, n) {
                        if (sceneobjects.isGameObject(obj)) {
                            const support = obj.getEditorSupport();
                            return support.hasComponent(sceneobjects.SizeComponent);
                        }
                        return false;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                SizeSection.SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.SizeSection";
                sceneobjects.SizeSection = SizeSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextContentComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [TextContentComponent.text]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_StringProperty(args, TextContentComponent.text);
                    }
                }
                TextContentComponent.text = sceneobjects.SimpleProperty("text", "", "Text", "The text content.");
                sceneobjects.TextContentComponent = TextContentComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextContentSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor.scene.ui.sceneobjects.TextContentSection", "Text Content", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/text-property.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createLock(comp, sceneobjects.TextContentComponent.text);
                        this.createLabel(comp, sceneobjects.TextContentComponent.text.label, scene.PhaserHelp(sceneobjects.TextContentComponent.text.tooltip));
                        this.createStringField(comp, sceneobjects.TextContentComponent.text, true, false, true);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TextContentComponent);
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TextContentSection = TextContentSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_29) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapFontLoaderUpdater extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(game) {
                        const fontCache = game.cache.bitmapFont;
                        const keys = fontCache.getKeys();
                        for (const key of keys) {
                            fontCache.remove(key);
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem;
                    }
                    async updateLoader(scene, asset) {
                        const font = asset;
                        await font.preload();
                        await font.preloadImages();
                        font.addToPhaserCache(scene.game, scene.getPackCache());
                    }
                    async updateLoaderWithObjData(scene, data) {
                        const serializer = new scene_29.core.json.Serializer(data);
                        const type = serializer.getType();
                        if (type === sceneobjects.BitmapTextExtension.getInstance().getTypeName()) {
                            const font = serializer.read("font");
                            if (font) {
                                const finder = scene.getMaker().getPackFinder();
                                const asset = finder.findAssetPackItem(font);
                                if (asset && asset instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem) {
                                    await this.updateLoader(scene, asset);
                                }
                            }
                        }
                    }
                }
                sceneobjects.BitmapFontLoaderUpdater = BitmapFontLoaderUpdater;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_29.ui || (scene_29.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_30) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapText extends Phaser.GameObjects.BitmapText {
                    constructor(scene, x, y, font, text) {
                        super(scene, x, y, BitmapText.getFont(scene, font), "New BitmapText");
                        this._editorSupport = new sceneobjects.BitmapTextEditorSupport(this, scene);
                    }
                    static getFont(scene, font) {
                        let entry = scene.sys.cache.bitmapFont.get(font);
                        if (!entry) {
                            font = "__missing__";
                            entry = scene.sys.cache.bitmapFont.get(font);
                            if (!entry) {
                                const data = {
                                    chars: {},
                                    font,
                                    lineHeight: 10,
                                    retroFont: false,
                                    size: 10
                                };
                                entry = { data };
                                scene.sys.cache.bitmapFont.add(font, entry);
                            }
                        }
                        return font;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    /**
                     * For compatibility with other game objects. It is used for LayoutExtension.
                     */
                    get displayWidth() {
                        return this.width * this.scaleX;
                    }
                    /**
                     * For compatibility with other game objects. It is used for LayoutExtension.
                     */
                    get displayHeight() {
                        return this.height * this.scaleY;
                    }
                }
                sceneobjects.BitmapText = BitmapText;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_30.ui || (scene_30.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class BitmapTextCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const call = new code.MethodCallCodeDOM("bitmapText", args.gameObjectFactoryExpr);
                        const obj = args.obj;
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argLiteral(obj.font);
                        call.argLiteral(obj.text);
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        const obj = args.obj;
                        const support = args.obj.getEditorSupport();
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.BitmapTextComponent.font)) {
                            call.argLiteral(obj.font);
                        }
                        else {
                            call.arg("undefined");
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("font", "string", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        if (support.isLockedProperty(sceneobjects.BitmapTextComponent.font)) {
                            call.arg("font");
                        }
                        else {
                            call.arg("font ?? " + code.CodeDOM.quote(obj.font));
                        }
                    }
                }
                sceneobjects.BitmapTextCodeDOMBuilder = BitmapTextCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            BitmapTextComponent.font,
                            BitmapTextComponent.align,
                            BitmapTextComponent.fontSize,
                            BitmapTextComponent.letterSpacing,
                            BitmapTextComponent.maxWidth,
                            BitmapTextComponent.dropShadowX,
                            BitmapTextComponent.dropShadowY,
                            BitmapTextComponent.dropShadowAlpha,
                            BitmapTextComponent.dropShadowColor
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const support = this.getObject().getEditorSupport();
                        if (support.isUnlockedProperty(BitmapTextComponent.font) && support.isNestedPrefabInstance()) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setFont", args.objectVarName);
                            dom.argLiteral(this.getObject().font);
                            args.statements.push(dom);
                        }
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, BitmapTextComponent.fontSize, BitmapTextComponent.align, BitmapTextComponent.letterSpacing, BitmapTextComponent.maxWidth, BitmapTextComponent.dropShadowX, BitmapTextComponent.dropShadowY, BitmapTextComponent.dropShadowAlpha, sceneobjects.NumberColorPropertyCodeDomAdapter(BitmapTextComponent.dropShadowColor));
                    }
                }
                BitmapTextComponent.font = {
                    name: "font",
                    label: "Font",
                    tooltip: "phaser:Phaser.GameObjects.BitmapText.setFont",
                    defValue: undefined,
                    getValue: obj => obj.font,
                    setValue: (obj, value) => obj.setFont(value)
                };
                BitmapTextComponent.align = {
                    name: "align",
                    label: "Align",
                    tooltip: "phaser:Phaser.GameObjects.BitmapText.align",
                    defValue: Phaser.GameObjects.BitmapText.ALIGN_LEFT,
                    getValue: obj => obj.align,
                    setValue: (obj, value) => obj.align = value,
                    getValueLabel: value => {
                        return {
                            [Phaser.GameObjects.BitmapText.ALIGN_LEFT]: "LEFT",
                            [Phaser.GameObjects.BitmapText.ALIGN_CENTER]: "CENTER",
                            [Phaser.GameObjects.BitmapText.ALIGN_RIGHT]: "RIGHT"
                        }[value];
                    },
                    values: [
                        Phaser.GameObjects.BitmapText.ALIGN_LEFT,
                        Phaser.GameObjects.BitmapText.ALIGN_CENTER,
                        Phaser.GameObjects.BitmapText.ALIGN_RIGHT
                    ]
                };
                BitmapTextComponent.fontSize = {
                    name: "fontSize",
                    label: "Font Size",
                    tooltip: "phaser:Phaser.GameObjects.BitmapText.setFontSize",
                    defValue: 0,
                    getValue: obj => obj.fontSize,
                    setValue: (obj, value) => obj.setFontSize(value)
                };
                BitmapTextComponent.letterSpacing = {
                    name: "letterSpacing",
                    label: "Letter Spacing",
                    tooltip: "phaser:Phaser.GameObjects.BitmapText.setLetterSpacing",
                    defValue: 0,
                    getValue: obj => obj.letterSpacing,
                    setValue: (obj, value) => obj.setLetterSpacing(value)
                };
                BitmapTextComponent.maxWidth = {
                    name: "maxWidth",
                    label: "Max Width",
                    tooltip: "phaser:Phaser.GameObjects.BitmapText.maxWidth",
                    defValue: 0,
                    getValue: obj => obj.maxWidth,
                    setValue: (obj, value) => obj.setMaxWidth(value)
                };
                BitmapTextComponent.dropShadowX = sceneobjects.SimpleProperty("dropShadowX", 0, "Drop Shadow X", "phaser:Phaser.GameObjects.BitmapText.dropShadowX");
                BitmapTextComponent.dropShadowY = sceneobjects.SimpleProperty("dropShadowY", 0, "Drop Shadow Y", "phaser:Phaser.GameObjects.BitmapText.dropShadowY");
                BitmapTextComponent.dropShadowAlpha = sceneobjects.SimpleProperty("dropShadowAlpha", 0.5, "Drop Shadow Alpha", "phaser:Phaser.GameObjects.BitmapText.dropShadowAlpha");
                BitmapTextComponent.dropShadowColor = sceneobjects.NumberColorProperty("dropShadowColor", "#000000", "Drop Shadow Color", "phaser:Phaser.GameObjects.BitmapText.dropShadowColor");
                sceneobjects.BitmapTextComponent = BitmapTextComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_31) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.BitmapTextExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaComponent(obj), new sceneobjects.TintComponent(obj), new sceneobjects.TextContentComponent(obj), new sceneobjects.BitmapTextComponent(obj));
                    }
                    computeContentHash() {
                        const obj = this.getObject();
                        return this.computeContentHashWithComponent(obj, sceneobjects.TintComponent, sceneobjects.TextContentComponent, sceneobjects.BitmapTextComponent);
                    }
                    getCellRenderer() {
                        return new sceneobjects.ObjectCellRenderer();
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_RenderTexture);
                    }
                    getPropertyDefaultValue(prop) {
                        if (prop === sceneobjects.OriginComponent.originX || prop === sceneobjects.OriginComponent.originY) {
                            return 0;
                        }
                        return super.getPropertyDefaultValue(prop);
                    }
                }
                sceneobjects.BitmapTextEditorSupport = BitmapTextEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_31.ui || (scene_31.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.BitmapText",
                            typeName: "BitmapText",
                            category: scene.SCENE_OBJECT_TEXT_CATEGORY,
                            icon: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_BITMAP_FONT_TYPE)
                        });
                    }
                    static getInstance() {
                        return this._instance;
                    }
                    acceptsDropData(data) {
                        return data instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem;
                    }
                    createSceneObjectWithAsset(args) {
                        const font = args.asset;
                        return new sceneobjects.BitmapText(args.scene, args.x, args.y, font.getKey(), "New BitmapText");
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        const bitmapFont = extraData;
                        if (bitmapFont && bitmapFont instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem) {
                            let size = 64;
                            const newData = serializer.getData();
                            if ("height" in originalObject) {
                                size = originalObject["height"];
                            }
                            if (typeof originalObject["text"] !== "string") {
                                newData["text"] = "New Bitmap Text";
                            }
                            newData["fontSize"] = size;
                            newData["font"] = bitmapFont.getKey();
                        }
                    }
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog();
                        dlg.create();
                        dlg.getViewer().setInput(finder.getPacks()
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem));
                        dlg.getViewer().setCellSize(128, true);
                        dlg.setTitle("Select Bitmap Font");
                        const promise = new Promise((resolver, reject) => {
                            dlg.setSelectionCallback(async (sel) => {
                                const item = sel[0];
                                await item.preload();
                                await item.preloadImages();
                                const result = {
                                    data: item
                                };
                                resolver(result);
                            });
                            dlg.setCancelCallback(() => {
                                const result = {
                                    abort: true
                                };
                                resolver(result);
                            });
                        });
                        return promise;
                    }
                    createDefaultSceneObject(args) {
                        const fontAsset = args.extraData;
                        fontAsset.addToPhaserCache(args.scene.game, args.scene.getPackCache());
                        return [new sceneobjects.BitmapText(args.scene, args.x, args.y, fontAsset.getKey(), "New BitmapText")];
                    }
                    createGameObjectWithData(args) {
                        const serializer = new scene.core.json.Serializer(args.data);
                        const font = serializer.read(sceneobjects.BitmapTextComponent.font.name);
                        const obj = new sceneobjects.BitmapText(args.scene, 0, 0, font, "");
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    async getAssetsFromObjectData(args) {
                        const font = args.serializer.read(sceneobjects.BitmapTextComponent.font.name);
                        const asset = args.finder.findAssetPackItem(font);
                        if (asset instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem) {
                            return [asset];
                        }
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.BitmapTextCodeDOMBuilder();
                    }
                }
                BitmapTextExtension._instance = new BitmapTextExtension();
                sceneobjects.BitmapTextExtension = BitmapTextExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor.scene.ui.sceneobjects.BitmapTextSection", "Bitmap Text");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/bitmap-text-object.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        {
                            // font
                            this.createLock(comp, sceneobjects.BitmapTextComponent.font);
                            this.createLabel(comp, sceneobjects.BitmapTextComponent.font.label, scene.PhaserHelp(sceneobjects.BitmapTextComponent.font.tooltip));
                            const btn = this.createButton(comp, "", async () => {
                                const input = this.getEditor().getPackFinder().getPacks()
                                    .flatMap(pack => pack.getItems())
                                    .filter(item => item instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem);
                                const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog();
                                dlg.create();
                                dlg.setTitle("Select Bitmap Font");
                                dlg.getViewer().setCellSize(128, true);
                                dlg.getViewer().setInput(input);
                                dlg.getViewer().repaint();
                                dlg.setSelectionCallback(async (sel) => {
                                    const item = sel[0];
                                    await item.preload();
                                    await item.preloadImages();
                                    item.addToPhaserCache(this.getEditor().getGame(), this.getEditor().getScene().getPackCache());
                                    this.getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), sceneobjects.BitmapTextComponent.font, item.getKey()));
                                });
                            });
                            this.addUpdater(() => {
                                if (this.getSelection().length !== 1) {
                                    btn.textContent = this.getSelection().length + " selected";
                                }
                                else {
                                    btn.textContent = this.getSelectionFirstElement().font;
                                }
                            });
                        }
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.fontSize);
                        this.createPropertyEnumRow(comp, sceneobjects.BitmapTextComponent.align);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.letterSpacing);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.maxWidth);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.dropShadowX);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.dropShadowY);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.dropShadowAlpha);
                        this.createPropertyColorRow(comp, sceneobjects.BitmapTextComponent.dropShadowColor);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.BitmapText;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.BitmapTextSection = BitmapTextSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/undo/SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_32) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BreakParentOperation extends ui.editor.undo.SceneSnapshotOperation {
                    async performModification() {
                        const editor = this.getEditor();
                        const scene = editor.getScene();
                        const selectedObjects = editor.getSelectedGameObjects();
                        const sel = BreakParentOperation.breakParent(scene, selectedObjects);
                        this.getEditor().setSelection(sel);
                    }
                    static breakParent(scene, selectedObjects) {
                        const displayList = scene.sys.displayList;
                        const sel = [];
                        for (const obj of selectedObjects) {
                            const parent = obj;
                            const children = [...parent.getChildren()];
                            for (const child of children) {
                                const sprite = child;
                                const p = new Phaser.Math.Vector2(0, 0);
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                                sel.push(sprite);
                                parent.remove(sprite);
                                displayList.remove(sprite);
                                sprite.displayList = null;
                                if (parent.parentContainer) {
                                    parent.parentContainer.getWorldTransformMatrix().applyInverse(p.x, p.y, p);
                                    parent.parentContainer.add(sprite);
                                }
                                else {
                                    if (parent.displayList instanceof sceneobjects.Layer) {
                                        parent.displayList.add(sprite);
                                    }
                                    else {
                                        const i = displayList.getIndex(parent);
                                        displayList.addAt(sprite, i, true);
                                    }
                                }
                                sprite.x = p.x;
                                sprite.y = p.y;
                            }
                            parent.getEditorSupport().destroy();
                        }
                        return sel;
                    }
                }
                sceneobjects.BreakParentOperation = BreakParentOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_32.ui || (scene_32.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class ContainerCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    static getInstance() {
                        return this._instance;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("container", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        return call;
                    }
                }
                ContainerCodeDOMBuilder._instance = new ContainerCodeDOMBuilder();
                sceneobjects.ContainerCodeDOMBuilder = ContainerCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ParentGameObjectEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_33) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ContainerEditorSupport extends sceneobjects.ParentGameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ContainerExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj));
                        this.addComponent(new sceneobjects.VisibleComponent(obj));
                        this.addComponent(new sceneobjects.AlphaSingleComponent(obj));
                        this.addComponent(new sceneobjects.ChildrenComponent(obj));
                    }
                    computeSize() {
                        const obj = this.getObject();
                        const b = obj.getBounds();
                        return {
                            width: b.width / obj.scaleX,
                            height: b.height / obj.scaleY
                        };
                    }
                    computeOrigin() {
                        const obj = this.getObject();
                        const b = obj.getBounds();
                        const originX = (obj.x - b.x) / b.width;
                        const originY = (obj.y - b.y) / b.height;
                        return { originX, originY };
                    }
                    getScreenBounds(camera) {
                        const container = this.getObject();
                        if (container.list.length === 0) {
                            return [];
                        }
                        const minPoint = new Phaser.Math.Vector2(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        const maxPoint = new Phaser.Math.Vector2(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
                        const points = [];
                        for (const obj of container.getChildren()) {
                            const bounds = obj.getEditorSupport().getScreenBounds(camera);
                            points.push(...bounds);
                        }
                        const worldPoint = new Phaser.Math.Vector2(0, 0);
                        container.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                        const p = camera.getScreenPoint(worldPoint.x, worldPoint.y);
                        points.push(p);
                        for (const point of points) {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                        return [
                            new Phaser.Math.Vector2(minPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, maxPoint.y),
                            new Phaser.Math.Vector2(minPoint.x, maxPoint.y)
                        ];
                    }
                    trim() {
                        const container = this.getObject();
                        if (container.length === 0) {
                            return;
                        }
                        let minX = Number.MAX_SAFE_INTEGER;
                        let minY = Number.MAX_SAFE_INTEGER;
                        for (const child of container.list) {
                            const sprite = child;
                            minX = Math.min(sprite.x, minX);
                            minY = Math.min(sprite.y, minY);
                        }
                        for (const child of container.list) {
                            const sprite = child;
                            sprite.x -= minX;
                            sprite.y -= minY;
                        }
                        const p = new Phaser.Math.Vector2(0, 0);
                        container.getWorldTransformMatrix().transformPoint(minX, minY, p);
                        if (container.parentContainer) {
                            container.parentContainer.getWorldTransformMatrix().applyInverse(p.x, p.y, p);
                        }
                        container.x = p.x;
                        container.y = p.y;
                    }
                }
                sceneobjects.ContainerEditorSupport = ContainerEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_33.ui || (scene_33.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_34) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ContainerExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            typeName: "Container",
                            phaserTypeName: "Phaser.GameObjects.Container",
                            category: scene_34.SCENE_OBJECT_GROUPING_CATEGORY,
                            icon: scene_34.ScenePlugin.getInstance().getIconDescriptor(scene_34.ICON_GROUP)
                        });
                    }
                    static getInstance() {
                        return this._instance || (this._instance = new ContainerExtension());
                    }
                    getCodeDOMBuilder() {
                        return sceneobjects.ContainerCodeDOMBuilder.getInstance();
                    }
                    static async getAssetsFromNestedData(args) {
                        const list = [];
                        const children = args.serializer.read("list", []);
                        const nestedPrefabs = sceneobjects.ParentGameObjectEditorSupport.buildPrefabChildrenData(args.serializer.getData(), children);
                        for (const objData of [...children, ...nestedPrefabs]) {
                            const ser = args.serializer.getSerializer(objData);
                            const type = ser.getType();
                            const ext = scene_34.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            if (ext) {
                                const list2 = await ext.getAssetsFromObjectData({
                                    serializer: ser,
                                    scene: args.scene,
                                    finder: args.finder
                                });
                                list.push(...list2);
                            }
                        }
                        return list;
                    }
                    async getAssetsFromObjectData(args) {
                        return ContainerExtension.getAssetsFromNestedData(args);
                    }
                    createDefaultSceneObject(args) {
                        return [this.createContainerObject(args.scene, 0, 0, [])];
                    }
                    createGameObjectWithData(args) {
                        const container = this.createContainerObject(args.scene, 0, 0, []);
                        container.getEditorSupport().readJSON(args.data);
                        return container;
                    }
                    createContainerObject(scene, x, y, list) {
                        const container = new sceneobjects.Container(scene, x, y, list);
                        container.getEditorSupport().setScene(scene);
                        scene.sys.displayList.add(container);
                        return container;
                    }
                    createContainerObjectWithChildren(scene, objectList) {
                        const container = this.createContainerObject(scene, 0, 0, objectList);
                        const name = scene.makeNewName("container");
                        container.getEditorSupport().setLabel(name);
                        return container;
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        return null;
                    }
                }
                sceneobjects.ContainerExtension = ContainerExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_34.ui || (scene_34.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/undo/SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CreateContainerWithObjectsOperation extends ui.editor.undo.SceneSnapshotOperation {
                    async performModification() {
                        const [container] = sceneobjects.ContainerExtension.getInstance().createDefaultSceneObject({
                            scene: this.getScene(),
                            x: 0,
                            y: 0
                        });
                        container.getEditorSupport().setLabel(this.getScene().makeNewName("container"));
                        const list = [...this._editor.getSelectedGameObjects()];
                        this._editor.getScene().sortObjectsByRenderingOrder(list);
                        let newParent;
                        for (const obj of list) {
                            const objParent = sceneobjects.getObjectParent(obj);
                            if (objParent) {
                                if (newParent) {
                                    if (newParent.getEditorSupport().isDescendentOf(objParent)) {
                                        newParent = objParent;
                                    }
                                }
                                else {
                                    newParent = objParent;
                                }
                            }
                        }
                        if (newParent) {
                            this.getScene().sys.displayList.remove(container);
                            newParent.add(container);
                        }
                        for (const obj of list) {
                            const sprite = obj;
                            const worldPoint = new Phaser.Math.Vector2(0, 0);
                            sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                            const objParent = sceneobjects.getObjectParent(obj);
                            if (objParent) {
                                objParent.remove(sprite);
                            }
                            container.add(sprite);
                            const localPoint = new Phaser.Math.Vector2(0, 0);
                            container.getWorldTransformMatrix().applyInverse(worldPoint.x, worldPoint.y, localPoint);
                            sprite.x = localPoint.x;
                            sprite.y = localPoint.y;
                        }
                        container.getEditorSupport().trim();
                        this.getEditor().setSelection([container]);
                    }
                }
                sceneobjects.CreateContainerWithObjectsOperation = CreateContainerWithObjectsOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TrimContainerOperation extends ui.editor.undo.SceneSnapshotOperation {
                    async performModification() {
                        for (const obj of this._editor.getSelectedGameObjects()) {
                            const container = obj;
                            container.getEditorSupport().trim();
                        }
                        this.getEditor().dispatchSelectionChanged();
                    }
                }
                sceneobjects.TrimContainerOperation = TrimContainerOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../GameObjectCodeDOMBuilder.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class BaseImageCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    constructor(factoryMethodName) {
                        super();
                        this._factoryMethodName = factoryMethodName;
                    }
                    getFactoryMethodName() {
                        return this._factoryMethodName;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        if (support.isLockedProperty(sceneobjects.TextureComponent.texture)) {
                            call.arg("texture");
                            call.arg("frame");
                        }
                        else {
                            const texture = sceneobjects.TextureComponent.texture.getValue(obj);
                            const key = texture.key || "__DEFAULT";
                            const frame = texture.frame;
                            call.arg("texture || " + code.CodeDOM.quote(key));
                            let frameCode;
                            if (typeof frame === "string") {
                                frameCode = code.CodeDOM.quote(frame);
                            }
                            else if (typeof frame === "number") {
                                frameCode = frame.toString();
                            }
                            if (frameCode) {
                                call.arg("frame ?? " + frameCode);
                            }
                            else {
                                call.arg("frame");
                            }
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("texture", "string", true);
                        ctr.arg("frame", "number | string", true);
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.TextureComponent.texture)) {
                            this.addTextureFrameArgsToObjectFactoryMethodCallDOM(args.methodCallDOM, args.obj);
                        }
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM(this._factoryMethodName, args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        this.addTextureFrameArgsToObjectFactoryMethodCallDOM(call, args.obj);
                        return call;
                    }
                    addTextureFrameArgsToObjectFactoryMethodCallDOM(call, obj) {
                        const texture = sceneobjects.TextureComponent.texture.getValue(obj);
                        if (texture.key) {
                            call.argLiteral(texture.key);
                            call.argStringOrInt(texture.frame);
                        }
                        else {
                            call.argLiteral("_MISSING");
                        }
                    }
                }
                sceneobjects.BaseImageCodeDOMBuilder = BaseImageCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_35) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseImageEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(extension, obj, scene, includeTextureComponent = true) {
                        super(extension, obj, scene);
                        if (includeTextureComponent) {
                            this.addComponent(new sceneobjects.TextureComponent(obj));
                        }
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.FlipComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaComponent(obj), new sceneobjects.TintComponent(obj));
                    }
                    getCellRenderer() {
                        return new sceneobjects.TextureCellRenderer();
                    }
                    getTextureComponent() {
                        return this.getComponent(sceneobjects.TextureComponent);
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_SharedTexture);
                    }
                }
                sceneobjects.BaseImageEditorSupport = BaseImageEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_35.ui || (scene_35.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_36) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseImageExtension extends sceneobjects.SceneGameObjectExtension {
                    async getAssetsFromObjectData(args) {
                        const { key } = args.serializer.read(sceneobjects.TextureComponent.texture.name, {});
                        const finder = args.finder;
                        const item = finder.findAssetPackItem(key);
                        if (item) {
                            return [item];
                        }
                        return [];
                    }
                    static isImageOrImageFrameAsset(data) {
                        return data instanceof phasereditor2d.pack.core.AssetPackImageFrame || data instanceof phasereditor2d.pack.core.ImageAssetPackItem;
                    }
                    acceptsDropData(data) {
                        return sceneobjects.ImageExtension.isImageOrImageFrameAsset(data);
                    }
                    createDefaultSceneObject(args) {
                        return [this.createImageObject(args.scene, args.x, args.y)];
                    }
                    createSceneObjectWithAsset(args) {
                        let key;
                        let frame;
                        let baseLabel;
                        if (args.asset instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                            const packItem = args.asset.getPackItem();
                            key = packItem.getKey();
                            frame = args.asset.getName();
                            baseLabel = frame.toString();
                            if (packItem instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem) {
                                baseLabel = key + frame.toString();
                            }
                        }
                        else if (args.asset instanceof phasereditor2d.pack.core.ImageAssetPackItem) {
                            key = args.asset.getKey();
                            frame = undefined;
                            baseLabel = key;
                        }
                        const sprite = this.createImageObject(args.scene, args.x, args.y, key, frame);
                        const support = sprite.getEditorSupport();
                        support.setLabel(baseLabel);
                        const textureComponent = support.getComponent(sceneobjects.TextureComponent);
                        textureComponent.setTextureKeys({ key, frame });
                        return sprite;
                    }
                    createGameObjectWithData(args) {
                        let key;
                        let frame;
                        const textureData = args.data;
                        if (textureData.texture) {
                            key = textureData.texture.key;
                            frame = textureData.texture.frame;
                        }
                        const sprite = this.createImageObject(args.scene, 0, 0, key, frame);
                        sprite.getEditorSupport().readJSON(args.data);
                        return sprite;
                    }
                    createImageObject(scene, x, y, key, frame) {
                        const sprite = this.newObject(scene, x, y, key, frame);
                        return sprite;
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        const support = originalObject.getEditorSupport();
                        if (support.isPrefabInstance()) {
                            const textureComponent = support.getComponent(sceneobjects.TextureComponent);
                            if (extraData.keepOriginalTexture) {
                                // create a new serializer with the original prefab
                                // so we can find the real texture, and keep it.
                                const data2 = JSON.parse(JSON.stringify(serializer.getData()));
                                data2.prefabId = support.getPrefabId();
                                const serializer2 = serializer.getSerializer(data2);
                                const keys = serializer2.read(sceneobjects.TextureComponent.texture.name, {});
                                // we write the texture directly into the data, bypassing unlocking validation of the serializer
                                colibri.core.json.write(serializer.getData(), sceneobjects.TextureComponent.texture.name, keys);
                            }
                            else {
                                const keys = textureComponent.getTextureKeys();
                                serializer.write(sceneobjects.TextureComponent.texture.name, keys, {});
                            }
                        }
                        if (extraData.keepOriginalTexture) {
                            serializer.setUnlocked(sceneobjects.TextureComponent.texture.name, true);
                        }
                    }
                }
                sceneobjects.BaseImageExtension = BaseImageExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_36.ui || (scene_36.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_37) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Image extends Phaser.GameObjects.Image {
                    constructor(scene, x, y, texture, frame) {
                        super(scene, x, y, texture, frame);
                        this._editorSupport = new sceneobjects.ImageEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Image = Image;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_37.ui || (scene_37.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_38) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ImageEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ImageExtension.getInstance(), obj, scene);
                    }
                }
                sceneobjects.ImageEditorSupport = ImageEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_38.ui || (scene_38.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseImageExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_39) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ImageExtension extends sceneobjects.BaseImageExtension {
                    constructor() {
                        super({
                            typeName: "Image",
                            phaserTypeName: "Phaser.GameObjects.Image",
                            category: scene_39.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: scene_39.ScenePlugin.getInstance().getIconDescriptor(scene_39.ICON_IMAGE_TYPE)
                        });
                    }
                    static getInstance() {
                        return this._instance ?? (this._instance = new ImageExtension());
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.BaseImageCodeDOMBuilder("image");
                    }
                    newObject(scene, x, y, key, frame) {
                        return new sceneobjects.Image(scene, x, y, key || null, frame);
                    }
                }
                sceneobjects.ImageExtension = ImageExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_39.ui || (scene_39.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/undo/SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CreateLayerWithObjectsOperation extends ui.editor.undo.SceneSnapshotOperation {
                    findParentLayer(obj) {
                        const parent = sceneobjects.getObjectParent(obj);
                        if (parent) {
                            if (parent instanceof sceneobjects.Layer) {
                                return parent;
                            }
                            return this.findParentLayer(parent);
                        }
                        return null;
                    }
                    async performModification() {
                        const [layer] = sceneobjects.LayerExtension.getInstance().createDefaultSceneObject({
                            scene: this.getScene(),
                            x: 0,
                            y: 0
                        });
                        layer.getEditorSupport().setLabel(this.getScene().makeNewName("layer"));
                        const list = [...this._editor.getSelectedGameObjects()];
                        this._editor.getScene().sortObjectsByRenderingOrder(list);
                        let newParent;
                        for (const obj of list) {
                            const objParent = this.findParentLayer(obj);
                            if (objParent && objParent instanceof sceneobjects.Layer) {
                                if (newParent) {
                                    if (newParent.getEditorSupport().isDescendentOf(objParent)) {
                                        newParent = objParent;
                                    }
                                }
                                else {
                                    newParent = objParent;
                                }
                            }
                        }
                        if (newParent) {
                            this.getScene().sys.displayList.remove(layer);
                            newParent.add(layer);
                        }
                        for (const obj of list) {
                            const sprite = obj;
                            const worldPoint = new Phaser.Math.Vector2(0, 0);
                            sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                            const objParent = sceneobjects.getObjectParentOrDisplayList(obj);
                            objParent.remove(sprite);
                            layer.add(sprite);
                            sprite.x = worldPoint.x;
                            sprite.y = worldPoint.y;
                        }
                        this.getEditor().setSelection([layer]);
                    }
                }
                sceneobjects.CreateLayerWithObjectsOperation = CreateLayerWithObjectsOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class LayerCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    static getInstance() {
                        return this._instance;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        // nothing
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        // nothing
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const call = new code.MethodCallCodeDOM("layer", args.gameObjectFactoryExpr);
                        return call;
                    }
                }
                LayerCodeDOMBuilder._instance = new LayerCodeDOMBuilder();
                sceneobjects.LayerCodeDOMBuilder = LayerCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_40) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class LayerEditorSupport extends sceneobjects.ParentGameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.LayerExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.ChildrenComponent(obj));
                    }
                    getScreenBounds(camera) {
                        const layer = this.getObject();
                        if (layer.list.length === 0) {
                            return [];
                        }
                        const minPoint = new Phaser.Math.Vector2(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        const maxPoint = new Phaser.Math.Vector2(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
                        const points = [];
                        for (const obj of layer.getChildren()) {
                            const bounds = obj.getEditorSupport().getScreenBounds(camera);
                            points.push(...bounds);
                        }
                        for (const point of points) {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                        return [
                            new Phaser.Math.Vector2(minPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, maxPoint.y),
                            new Phaser.Math.Vector2(minPoint.x, maxPoint.y)
                        ];
                    }
                }
                sceneobjects.LayerEditorSupport = LayerEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_40.ui || (scene_40.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_41) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class LayerExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            category: scene_41.SCENE_OBJECT_GROUPING_CATEGORY,
                            icon: scene_41.ScenePlugin.getInstance().getIconDescriptor(scene_41.ICON_LAYER),
                            phaserTypeName: "Phaser.GameObjects.Layer",
                            typeName: "Layer"
                        });
                    }
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new LayerExtension());
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        if (originalObject instanceof sceneobjects.Container) {
                            const containerData = serializer.getData();
                            const children = originalObject.getChildren();
                            // tslint:disable-next-line:prefer-for-of
                            for (let i = 0; i < children.length; i++) {
                                const child = children[i];
                                if (child.getEditorSupport().hasComponent(sceneobjects.TransformComponent)) {
                                    const sprite = child;
                                    const p = new Phaser.Math.Vector2();
                                    sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                                    const spriteData = containerData.list[i];
                                    if (spriteData) {
                                        spriteData["x"] = p.x;
                                        spriteData["y"] = p.y;
                                    }
                                }
                            }
                        }
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const container = this.createLayerObject(args.scene, []);
                        container.getEditorSupport().readJSON(args.data);
                        return container;
                    }
                    createLayerObject(scene, list) {
                        const layer = new sceneobjects.Layer(scene, list);
                        layer.getEditorSupport().setScene(scene);
                        scene.sys.displayList.add(layer);
                        return layer;
                    }
                    getAssetsFromObjectData(args) {
                        return sceneobjects.ContainerExtension.getAssetsFromNestedData(args);
                    }
                    createDefaultSceneObject(args) {
                        return [this.createLayerObject(args.scene, [])];
                    }
                    getCodeDOMBuilder() {
                        return sceneobjects.LayerCodeDOMBuilder.getInstance();
                    }
                }
                sceneobjects.LayerExtension = LayerExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_41.ui || (scene_41.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ListSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ListSection", "List", true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "1fr";
                        comp.style.gridTemplateRows = "1fr auto";
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.ListSection");
                        viewer.setCellSize(64, true);
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        const filteredViewer = new colibri.ui.ide.properties
                            .FilteredViewerInPropertySection(this.getPage(), viewer, true);
                        comp.appendChild(filteredViewer.getElement());
                        this.addUpdater(() => {
                            const list = this.getSelectionFirstElement();
                            const map = this.getEditor().getScene().buildObjectIdMap();
                            const input = list.getObjectIds()
                                .map(id => map.get(id))
                                .filter(obj => obj !== undefined);
                            viewer.setInput(input);
                            viewer.setSelection([]);
                        });
                        const btnRow = document.createElement("div");
                        comp.appendChild(btnRow);
                        const selectBtn = this.createButton(btnRow, "Select In Scene", () => {
                            this.getEditor().setSelection(viewer.getSelection());
                        });
                        selectBtn.style.float = "right";
                        const removeBtn = this.createButton(btnRow, "Remove From List", () => {
                            this.getUndoManager().add(new sceneobjects.RemoveObjectsFromListOperation(this.getEditor(), this.getSelectionFirstElement(), viewer.getSelection()));
                        });
                        removeBtn.style.float = "right";
                        removeBtn.style.marginRight = "5px";
                        viewer.eventSelectionChanged.addListener(() => {
                            selectBtn.disabled = removeBtn.disabled = viewer.getSelection().length === 0;
                        });
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.ObjectList;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.ListSection = ListSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ListVariableSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ListVariableSection", "Variable", false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name");
                            const text = this.createText(comp);
                            text.addEventListener("change", e => {
                                this.performChange(list => {
                                    list.setLabel(text.value);
                                });
                            });
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().getLabel();
                            });
                        }
                        {
                            // Type
                            this.createLabel(comp, "Type");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                const map = this.getEditor().getScene().buildObjectIdMap();
                                text.value = this.getSelectionFirstElement().inferType(map);
                            });
                        }
                        {
                            // Scope
                            this.createLabel(comp, "Scope", "The lexical scope of the object.");
                            const items = [{
                                    name: "Method",
                                    value: sceneobjects.ObjectScope.METHOD
                                }, {
                                    name: "Class",
                                    value: sceneobjects.ObjectScope.CLASS
                                }, {
                                    name: "Public",
                                    value: sceneobjects.ObjectScope.PUBLIC
                                }];
                            const btn = this.createMenuButton(comp, "", () => items, scope => {
                                this.performChange(list => {
                                    list.setScope(scope);
                                });
                            });
                            this.addUpdater(() => {
                                btn.textContent = items
                                    .find(item => item.value === this.getSelectionFirstElement().getScope())
                                    .name;
                            });
                        }
                    }
                    performChange(performChange) {
                        this.getUndoManager().add(new sceneobjects.ChangeListOperation(this.getEditor(), this.getSelectionFirstElement(), performChange));
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.ObjectList;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.ListVariableSection = ListVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectList {
                    constructor() {
                        this._id = Phaser.Utils.String.UUID();
                        this._label = "list";
                        this._scope = sceneobjects.ObjectScope.CLASS;
                        this._objectIds = [];
                    }
                    getObjectIds() {
                        return this._objectIds;
                    }
                    setObjectsIds(ids) {
                        this._objectIds = ids;
                    }
                    getId() {
                        return this._id;
                    }
                    setId(id) {
                        this._id = id;
                    }
                    getLabel() {
                        return this._label;
                    }
                    setLabel(label) {
                        this._label = label;
                    }
                    getScope() {
                        return this._scope;
                    }
                    setScope(scope) {
                        this._scope = scope;
                    }
                    inferType(objMap) {
                        const types = new Set(this.getObjectIds()
                            .map(id => objMap.get(id))
                            .filter(obj => obj !== undefined)
                            .map(obj => {
                            const support = obj.getEditorSupport();
                            if (support.isPrefabInstance()) {
                                return support.getPrefabName();
                            }
                            return support.getPhaserType();
                        }));
                        let listType = [...types].join("|");
                        if (types.size === 0) {
                            listType = "Array<any>";
                        }
                        else if (types.size === 1) {
                            listType = listType + "[]";
                        }
                        else {
                            listType = "Array<" + listType + ">";
                        }
                        return listType;
                    }
                    readJSON(data) {
                        this._id = data.id;
                        this._label = data.label;
                        this._objectIds = data.objectIds || [];
                        this._scope = data.scope || sceneobjects.ObjectScope.CLASS;
                    }
                    writeJSON(data) {
                        data.id = this._id;
                        data.label = this._label;
                        data.objectIds = this._objectIds.length === 0 ? undefined : [...this._objectIds];
                        data.scope = this._scope === sceneobjects.ObjectScope.CLASS ? undefined : this._scope;
                    }
                }
                sceneobjects.ObjectList = ObjectList;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectLists {
                    constructor() {
                        this._lists = [];
                    }
                    getLists() {
                        return this._lists;
                    }
                    getListById(id) {
                        return this._lists.find(list => list.getId() === id);
                    }
                    getListsByObjectId(objectId) {
                        const result = this._lists
                            .filter(list => list.getObjectIds().findIndex(id => id === objectId) >= 0);
                        return result;
                    }
                    readJSON_lists(listsArray) {
                        this._lists = [];
                        for (const listData of listsArray) {
                            const list = new sceneobjects.ObjectList();
                            list.readJSON(listData);
                            this._lists.push(list);
                        }
                    }
                    readJSON(sceneData) {
                        const lists = sceneData.lists;
                        if (Array.isArray(lists)) {
                            this.readJSON_lists(lists);
                        }
                        else {
                            this._lists = [];
                        }
                    }
                    writeJSON(sceneData) {
                        sceneData.lists = undefined;
                        if (this._lists.length > 0) {
                            sceneData.lists = this.toJSON_lists();
                        }
                    }
                    toJSON_lists() {
                        const listsData = [];
                        for (const list of this._lists) {
                            const listData = {};
                            list.writeJSON(listData);
                            listsData.push(listData);
                        }
                        return listsData;
                    }
                    removeListById(id) {
                        const i = this._lists.findIndex(l => l.getId() === id);
                        if (i >= 0) {
                            this._lists.splice(i, 1);
                        }
                    }
                    removeObjectById(objId) {
                        for (const list of this._lists) {
                            const i = list.getObjectIds().findIndex(id => id === objId);
                            if (i >= 0) {
                                list.getObjectIds().splice(i, 1);
                            }
                        }
                    }
                }
                sceneobjects.ObjectLists = ObjectLists;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ListsSnapshotOperation extends ui.editor.undo.SceneEditorOperation {
                    constructor(editor) {
                        super(editor);
                    }
                    async execute() {
                        const lists = this._editor.getScene().getObjectLists();
                        this._before = lists.toJSON_lists();
                        this.performChange(lists);
                        this._after = lists.toJSON_lists();
                        this.loadData(this._after);
                    }
                    loadData(data) {
                        const lists = this._editor.getScene().getObjectLists();
                        lists.readJSON_lists(data);
                        this._editor.setDirty(true);
                        this._editor.refreshOutline();
                        this._editor.getSelectionManager().refreshSelection();
                    }
                    undo() {
                        this.loadData(this._before);
                    }
                    redo() {
                        this.loadData(this._after);
                    }
                }
                sceneobjects.ListsSnapshotOperation = ListsSnapshotOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ListsSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AddObjectListOperation extends sceneobjects.ListsSnapshotOperation {
                    constructor(editor, list) {
                        super(editor);
                        this._list = list;
                    }
                    performChange(lists) {
                        lists.getLists().push(this._list);
                        this._editor.refreshOutline();
                        this._editor.setSelection([this._list]);
                    }
                }
                sceneobjects.AddObjectListOperation = AddObjectListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AddObjectsToListOperation extends sceneobjects.ListsSnapshotOperation {
                    constructor(editor, list, objects) {
                        super(editor);
                        this._list = list;
                        this._objects = objects;
                    }
                    performChange(lists) {
                        this._list.getObjectIds().push(...this._objects.map(obj => obj.getEditorSupport().getId()));
                        delete this._list;
                        delete this._objects;
                    }
                }
                sceneobjects.AddObjectsToListOperation = AddObjectsToListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AddObjectsToNewListOperation extends sceneobjects.ListsSnapshotOperation {
                    constructor(editor, label, objects) {
                        super(editor);
                        this._label = label;
                        this._objects = objects;
                    }
                    performChange(lists) {
                        const list = new sceneobjects.ObjectList();
                        list.setLabel(this._label);
                        list.getObjectIds().push(...this._objects.map(obj => obj.getEditorSupport().getId()));
                        lists.getLists().push(list);
                    }
                }
                sceneobjects.AddObjectsToNewListOperation = AddObjectsToNewListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChangeListOperation extends ui.editor.undo.SceneEditorOperation {
                    constructor(editor, list, performChange) {
                        super(editor);
                        this._list = list;
                        this._performChange = performChange;
                    }
                    async execute() {
                        this._before = {};
                        this._list.writeJSON(this._before);
                        this._performChange(this._list);
                        this._after = {};
                        this._list.writeJSON(this._after);
                        delete this._list;
                        this.loadData(this._after);
                    }
                    loadData(listData) {
                        const list = this._editor.getScene().getObjectLists().getListById(listData.id);
                        list.readJSON(listData);
                        this._editor.setDirty(true);
                        this._editor.refreshOutline();
                        this._editor.dispatchSelectionChanged();
                    }
                    undo() {
                        this.loadData(this._before);
                    }
                    redo() {
                        this.loadData(this._after);
                    }
                }
                sceneobjects.ChangeListOperation = ChangeListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NewListOperation extends sceneobjects.ListsSnapshotOperation {
                    performChange(lists) {
                        const list = new sceneobjects.ObjectList();
                        list.setLabel(this.getEditor().getScene().makeNewName("list"));
                        lists.getLists().push(list);
                        this.getEditor().setSelection([list]);
                    }
                }
                sceneobjects.NewListOperation = NewListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ListsSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RemoveObjectListOperation extends sceneobjects.ListsSnapshotOperation {
                    constructor(editor, toDeleteArray) {
                        super(editor);
                        this._toDeleteArray = toDeleteArray;
                    }
                    performChange(sceneLists) {
                        for (const list of this._toDeleteArray) {
                            const i = sceneLists.getLists().indexOf(list);
                            sceneLists.getLists().splice(i, 1);
                        }
                        this._editor.refreshOutline();
                        this._editor.setSelection([]);
                    }
                }
                sceneobjects.RemoveObjectListOperation = RemoveObjectListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RemoveObjectsFromListOperation extends sceneobjects.ListsSnapshotOperation {
                    constructor(editor, list, objects) {
                        super(editor);
                        this._list = list;
                        this._objects = objects;
                    }
                    performChange(lists) {
                        const objectsInListIds = this._list.getObjectIds();
                        const objectsIds = new Set(this._objects.map(obj => obj.getEditorSupport().getId()));
                        this._list.setObjectsIds(objectsInListIds.filter(id => !objectsIds.has(id)));
                        delete this._list;
                        delete this._objects;
                    }
                }
                sceneobjects.RemoveObjectsFromListOperation = RemoveObjectsFromListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            AlphaComponent.alpha,
                            AlphaComponent.alphaTopLeft,
                            AlphaComponent.alphaTopRight,
                            AlphaComponent.alphaBottomLeft,
                            AlphaComponent.alphaBottomRight
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ...this.getProperties());
                    }
                }
                AlphaComponent.alpha = {
                    name: "alpha",
                    label: "Alpha",
                    tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alpha",
                    defValue: 1,
                    getValue: obj => obj.alpha,
                    setValue: (obj, value) => obj.alpha = value
                };
                AlphaComponent.alphaTopLeft = {
                    name: "alphaTopLeft",
                    label: "Left",
                    tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaTopLeft",
                    defValue: 1,
                    getValue: obj => obj.alphaTopLeft,
                    setValue: (obj, value) => obj.alphaTopLeft = value
                };
                AlphaComponent.alphaTopRight = {
                    name: "alphaTopRight",
                    label: "Right",
                    tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaTopRight",
                    defValue: 1,
                    getValue: obj => obj.alphaTopRight,
                    setValue: (obj, value) => obj.alphaTopRight = value
                };
                AlphaComponent.alphaBottomLeft = {
                    name: "alphaBottomLeft",
                    label: "Left",
                    tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaBottomLeft",
                    defValue: 1,
                    getValue: obj => obj.alphaBottomLeft,
                    setValue: (obj, value) => obj.alphaBottomLeft = value
                };
                AlphaComponent.alphaBottomRight = {
                    name: "alphaBottomRight",
                    label: "Right",
                    tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaBottomRight",
                    defValue: 1,
                    getValue: obj => obj.alphaBottomRight,
                    setValue: (obj, value) => obj.alphaBottomRight = value
                };
                AlphaComponent.alphaTop = {
                    label: "Alpha Top",
                    x: AlphaComponent.alphaTopLeft,
                    y: AlphaComponent.alphaTopRight
                };
                AlphaComponent.alphaBottom = {
                    label: "Alpha Bottom",
                    x: AlphaComponent.alphaBottomLeft,
                    y: AlphaComponent.alphaBottomRight
                };
                sceneobjects.AlphaComponent = AlphaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaSingleComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            AlphaSingleComponent.alpha,
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, AlphaSingleComponent.alpha);
                    }
                }
                AlphaSingleComponent.alpha = sceneobjects.SimpleProperty("alpha", 1, "Alpha", "phaser:Phaser.GameObjects.Components.Alpha.alpha");
                sceneobjects.AlphaSingleComponent = AlphaSingleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FlipComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [FlipComponent.flipX, FlipComponent.flipY]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ...this.getProperties());
                    }
                }
                FlipComponent.flipX = sceneobjects.SimpleProperty("flipX", false, "Flip X", "phaser:Phaser.GameObjects.Components.Flip.flipX");
                FlipComponent.flipY = sceneobjects.SimpleProperty("flipY", false, "Flip Y", "phaser:Phaser.GameObjects.Components.Flip.flipY");
                sceneobjects.FlipComponent = FlipComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ObjectCellRenderer {
                    constructor(maxWidth = 1024, maxHeight = 1024) {
                        this._maxWidth = maxWidth;
                        this._maxHeight = maxHeight;
                    }
                    renderCell(args) {
                        const obj = args.obj;
                        const cache = obj.getEditorSupport().getScene().getEditor().getCellRendererCache();
                        // const cached = obj.getData("__renderer_image") as controls.IImage;
                        const cached = cache.getImage(obj);
                        if (cached) {
                            cached.paint(args.canvasContext, args.x, args.y, args.w, args.h, false);
                        }
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const obj = args.obj;
                        if (!obj.scene) {
                            return controls.PreloadResult.NOTHING_LOADED;
                        }
                        const cache = obj.getEditorSupport().getScene().getEditor().getCellRendererCache();
                        return cache.preloadImage(obj);
                    }
                }
                sceneobjects.ObjectCellRenderer = ObjectCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../Component.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class OriginComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            OriginComponent.originX,
                            OriginComponent.originY
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        let add = false;
                        if (this.getEditorSupport().isPrefabInstance()) {
                            if (this.getEditorSupport().isUnlockedPropertyXY(OriginComponent.origin)) {
                                add = true;
                            }
                        }
                        else {
                            const defaultOriginX = this.getPropertyDefaultValue(OriginComponent.originX);
                            const defaultOriginY = this.getPropertyDefaultValue(OriginComponent.originY);
                            if (defaultOriginX !== obj.originX || defaultOriginY !== obj.originY) {
                                add = true;
                            }
                        }
                        if (add) {
                            const dom = new code.MethodCallCodeDOM("setOrigin", args.objectVarName);
                            dom.argFloat(obj.originX);
                            dom.argFloat(obj.originY);
                            args.statements.push(dom);
                        }
                    }
                }
                OriginComponent.originX = {
                    name: "originX",
                    label: "X",
                    tooltip: "phaser:Phaser.GameObjects.Components.Origin.originX",
                    defValue: 0.5,
                    getValue: obj => obj.originX,
                    setValue: (obj, value) => obj.setOrigin(value, obj.originY)
                };
                OriginComponent.originY = {
                    name: "originY",
                    label: "Y",
                    tooltip: "phaser:Phaser.GameObjects.Components.Origin.originY",
                    defValue: 0.5,
                    getValue: obj => obj.originY,
                    setValue: (obj, value) => obj.setOrigin(obj.originX, value)
                };
                OriginComponent.origin = {
                    label: "Origin",
                    tooltip: "phaser:Phaser.GameObjects.Components.Origin.setOrigin",
                    x: OriginComponent.originX,
                    y: OriginComponent.originY
                };
                sceneobjects.OriginComponent = OriginComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabUserPropertyComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, []);
                        this._data = {};
                    }
                    setPropertyValue(prop, value) {
                        this._data[prop.getName()] = value;
                    }
                    getPropertyValue(prop) {
                        return this._data[prop.getName()];
                    }
                    isPropertySet(prop) {
                        return prop.getName() in this._data;
                    }
                    getPropertiesByPrefab() {
                        const propertiesInObject = [];
                        const editorSupport = this.getObject().getEditorSupport();
                        if (editorSupport.isPrefabInstance()) {
                            const prefabFile = this.getObject().getEditorSupport().getPrefabOrNestedPrefabFile();
                            if (prefabFile) {
                                this.getPrefabProperties(propertiesInObject, prefabFile);
                            }
                        }
                        return propertiesInObject;
                    }
                    getPrefabProperties(propertiesInObject, prefabFile) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const sceneData = finder.getSceneData(prefabFile);
                        if (sceneData.sceneType === scene.core.json.SceneType.PREFAB) {
                            if (sceneData.displayList.length > 0) {
                                const objData = sceneData.displayList[sceneData.displayList.length - 1];
                                if (objData.prefabId) {
                                    const prefabFile2 = finder.getPrefabFile(objData.prefabId);
                                    if (prefabFile2) {
                                        this.getPrefabProperties(propertiesInObject, prefabFile2);
                                    }
                                }
                            }
                        }
                        const userProps = new sceneobjects.PrefabUserProperties();
                        userProps.readJSON(sceneData.prefabProperties || []);
                        const properties = userProps.getProperties();
                        propertiesInObject.push({
                            prefabFile,
                            properties
                        });
                    }
                    getProperties() {
                        const properties = this.getPropertiesByPrefab()
                            .flatMap(data => data.properties)
                            .map(userProp => userProp.getComponentProperty());
                        return new Set(properties);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const mark = args.lazyStatements.length;
                        const temp = args.statements;
                        args.statements = args.lazyStatements;
                        for (const prop of this.getProperties()) {
                            const userProp = prop.getUserProperty();
                            userProp.getType().buildSetObjectPropertyCodeDOM(this, args, userProp);
                        }
                        args.statements = temp;
                        if (args.lazyStatements.length > mark) {
                            args.lazyStatements.splice(mark, 0, new scene.core.code.RawCodeDOM(""), new scene.core.code.RawCodeDOM(`// ${args.objectVarName} (prefab fields)`));
                        }
                    }
                }
                sceneobjects.PrefabUserPropertyComponent = PrefabUserPropertyComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SceneGameObjectOperation extends ui.editor.undo.SceneEditorOperation {
                    constructor(editor, objects, value) {
                        super(editor);
                        this._objects = objects;
                        this._value = value;
                    }
                    async execute() {
                        this._objIdList = this._objects.map(obj => obj.getEditorSupport().getId());
                        this._values1 = this._objects.map(_ => this._value);
                        this._values2 = this._objects.map(obj => this.getValue(obj));
                        // don't keep the objects reference, we have the ids.
                        this._objects = null;
                        this.update(this._values1);
                    }
                    undo() {
                        this.update(this._values2);
                    }
                    redo() {
                        this.update(this._values1);
                    }
                    update(values) {
                        for (let i = 0; i < this._objIdList.length; i++) {
                            const id = this._objIdList[i];
                            const obj = this._editor.getScene().getByEditorId(id);
                            const value = values[i];
                            if (obj) {
                                this.setValue(obj, value);
                            }
                        }
                        this._editor.setSelection(this._editor.getSelection());
                        this._editor.setDirty(true);
                    }
                }
                sceneobjects.SceneGameObjectOperation = SceneGameObjectOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SimpleOperation extends sceneobjects.SceneGameObjectOperation {
                    constructor(editor, objects, property, value) {
                        super(editor, objects, value);
                        this._property = property;
                    }
                    getValue(obj) {
                        return this._property.getValue(obj);
                    }
                    setValue(obj, value) {
                        this._property.setValue(obj, value);
                    }
                }
                sceneobjects.SimpleOperation = SimpleOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                function colorStringToColorNumberConverter(value) {
                    if (typeof (value) === "string" && value.trim() === "") {
                        value = "#ffffff";
                    }
                    // update the real object tint property
                    try {
                        const rgba = controls.Colors.parseColor(value);
                        const color = Phaser.Display.Color.GetColor(rgba.r, rgba.g, rgba.b);
                        return color;
                    }
                    catch (e) {
                        // possible color syntax error.
                        console.log(e);
                    }
                    return 0;
                }
                function TintProperty(name, label, tooltip) {
                    return {
                        name,
                        defValue: "#ffffff",
                        label,
                        tooltip: tooltip ?? "phaser:Phaser.GameObjects.Components.Tint." + name,
                        local: false,
                        getValue: obj => {
                            const val = obj["tint_" + name];
                            return val === undefined ? "#ffffff" : val;
                        },
                        setValue: (obj, value) => {
                            const validColor = colorStringToColorNumberConverter(value);
                            obj[name] = validColor;
                            // store the original, string color value in the object
                            obj["tint_" + name] = value;
                        },
                        valueToCodeConverter: colorStringToColorNumberConverter
                    };
                }
                sceneobjects.TintProperty = TintProperty;
                class TintComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            TintComponent.tintTopLeft,
                            TintComponent.tintTopRight,
                            TintComponent.tintBottomLeft,
                            TintComponent.tintBottomRight,
                            TintComponent.tintFill
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, TintComponent.tintFill);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintTopLeft);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintTopRight);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintBottomLeft);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintBottomRight);
                    }
                }
                TintComponent.tintFill = sceneobjects.SimpleProperty("tintFill", false, "Tint Fill", "phaser:Phaser.GameObjects.Components.Tint.tintFill");
                TintComponent.tintTopLeft = TintProperty("tintTopLeft", "Tint Top Left");
                TintComponent.tintTopRight = TintProperty("tintTopRight", "Tint Top Right");
                TintComponent.tintBottomLeft = TintProperty("tintBottomLeft", "Tint Bottom Left");
                TintComponent.tintBottomRight = TintProperty("tintBottomRight", "Tint Bottom Right");
                sceneobjects.TintComponent = TintComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../Component.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TransformComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            TransformComponent.x,
                            TransformComponent.y,
                            TransformComponent.scaleX,
                            TransformComponent.scaleY,
                            TransformComponent.angle
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const prop = TransformComponent.position;
                        if (support.isNestedPrefabInstance()
                            && support.isUnlockedPropertyXY(prop)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setPosition", args.objectVarName);
                            dom.argFloat(prop.x.getValue(obj));
                            dom.argFloat(prop.y.getValue(obj));
                            args.statements.push(dom);
                        }
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TransformComponent.scaleX, TransformComponent.scaleY, TransformComponent.angle);
                    }
                }
                TransformComponent.x = sceneobjects.SimpleProperty("x", 0, "X", "phaser:Phaser.GameObjects.Components.Transform.x");
                TransformComponent.y = sceneobjects.SimpleProperty("y", 0, "Y", "phaser:Phaser.GameObjects.Components.Transform.y");
                TransformComponent.position = {
                    label: "Position",
                    tooltip: "phaser:Phaser.GameObjects.Components.Transform.setPosition",
                    x: TransformComponent.x,
                    y: TransformComponent.y
                };
                TransformComponent.scaleX = sceneobjects.SimpleProperty("scaleX", 1, "X", "phaser:Phaser.GameObjects.Components.Transform.scaleX");
                TransformComponent.scaleY = sceneobjects.SimpleProperty("scaleY", 1, "Y", "phaser:Phaser.GameObjects.Components.Transform.scaleY");
                TransformComponent.scale = {
                    label: "Scale",
                    x: TransformComponent.scaleX,
                    y: TransformComponent.scaleY
                };
                TransformComponent.angle = sceneobjects.SimpleProperty("angle", 0, "Angle", "phaser:Phaser.GameObjects.Components.Transform.angle");
                sceneobjects.TransformComponent = TransformComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class VariableComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            VariableComponent.label,
                            VariableComponent.useGameObjectName,
                            VariableComponent.scope
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        if (this.getEditorSupport().isUseGameObjectName()) {
                            const dom = new code.AssignPropertyCodeDOM("name", args.objectVarName);
                            dom.valueLiteral(this.getEditorSupport().getLabel());
                            args.statements.push(dom);
                        }
                    }
                }
                VariableComponent.label = {
                    name: "label",
                    tooltip: "The variable name of the object.",
                    defValue: undefined,
                    local: true,
                    getValue: obj => obj.getEditorSupport().getLabel(),
                    setValue: (obj, value) => obj.getEditorSupport().setLabel(value)
                };
                VariableComponent.useGameObjectName = {
                    name: "useGameObjectName",
                    label: "GO Name",
                    tooltip: "Also set the Game Object's name",
                    defValue: false,
                    local: true,
                    getValue: obj => obj.getEditorSupport().isUseGameObjectName(),
                    setValue: (obj, value) => obj.getEditorSupport().setUseGameObjectName(value)
                };
                VariableComponent.scope = {
                    name: "scope",
                    tooltip: "The variable lexical scope.",
                    defValue: sceneobjects.ObjectScope.METHOD,
                    local: true,
                    getValue: obj => obj.getEditorSupport().getScope(),
                    setValue: (obj, value) => obj.getEditorSupport().setScope(value),
                    values: [sceneobjects.ObjectScope.METHOD, sceneobjects.ObjectScope.CLASS, sceneobjects.ObjectScope.PUBLIC, sceneobjects.ObjectScope.NESTED_PREFAB],
                    getValueLabel: value => value.split("_").map(v => v[0] + v.substring(1).toLowerCase()).join(" ")
                };
                sceneobjects.VariableComponent = VariableComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class VisibleComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [VisibleComponent.visible]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, VisibleComponent.visible);
                    }
                }
                VisibleComponent.visible = {
                    name: "visible",
                    label: "Visible",
                    tooltip: "phaser:Phaser.GameObjects.Components.Visible.visible",
                    defValue: true,
                    getValue: obj => obj.visible,
                    setValue: (obj, value) => obj.visible = value
                };
                sceneobjects.VisibleComponent = VisibleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.AlphaSection", "Alpha", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/alpha-properties.html";
                        ;
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createNumberPropertyRow(comp, sceneobjects.AlphaComponent.alpha, true);
                        this.createPropertyXYRow(comp, sceneobjects.AlphaComponent.alphaTop);
                        this.createPropertyXYRow(comp, sceneobjects.AlphaComponent.alphaBottom);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.AlphaComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.AlphaSection = AlphaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaSingleSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.AlphaSingleSection", "Alpha", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/alpha-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createNumberProperty(comp, sceneobjects.AlphaComponent.alpha);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.AlphaSingleComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.AlphaSingleSection = AlphaSingleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FlipSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.FlipSection", "Flip", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/flip-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto auto auto auto";
                        this.createLock(comp, sceneobjects.FlipComponent.flipX, sceneobjects.FlipComponent.flipY);
                        this.createBooleanField(comp, sceneobjects.FlipComponent.flipX);
                        this.createBooleanField(comp, sceneobjects.FlipComponent.flipY);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.FlipComponent) !== null;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.FlipSection = FlipSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_42) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class GameObjectListSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.GameObjectListSection", "Lists", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/lists-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.createLabel(comp, "Lists", "The lists where this object belongs to.");
                        const btn = this.createButton(comp, "", e => {
                            const listsRoot = this.getEditor().getScene().getObjectLists();
                            const menu = new controls.Menu();
                            const selObjIds = this.getSelection().map(obj => obj.getEditorSupport().getId());
                            const usedLists = new Set(selObjIds.flatMap(objId => listsRoot.getListsByObjectId(objId)));
                            const notUsedLists = listsRoot.getLists().filter(list => !usedLists.has(list));
                            for (const list of notUsedLists) {
                                menu.add(new controls.Action({
                                    icon: colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_PLUS),
                                    text: list.getLabel(),
                                    callback: () => {
                                        this.getUndoManager().add(new sceneobjects.AddObjectsToListOperation(this.getEditor(), list, this.getEditor().getSelectedGameObjects()));
                                    }
                                }));
                            }
                            menu.addSeparator();
                            for (const list of usedLists) {
                                menu.add(new controls.Action({
                                    icon: colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_MINUS),
                                    text: list.getLabel(),
                                    callback: () => {
                                        this.getUndoManager().add(new sceneobjects.RemoveObjectsFromListOperation(this.getEditor(), list, this.getEditor().getSelectedGameObjects()));
                                    }
                                }));
                            }
                            menu.addSeparator();
                            menu.add(new controls.Action({
                                text: "Add To New List",
                                callback: () => {
                                    const dlg = new controls.dialogs.InputDialog();
                                    dlg.create();
                                    dlg.setTitle("New List");
                                    dlg.setMessage("Enter the name of the new list");
                                    dlg.setInitialValue("list");
                                    dlg.setInputValidator(name => {
                                        return this.getEditor().getScene().getObjectLists().getLists().findIndex(list => list.getLabel() === name) < 0;
                                    });
                                    dlg.setResultCallback(name => {
                                        this.getUndoManager().add(new sceneobjects.AddObjectsToNewListOperation(this.getEditor(), name, this.getEditor().getSelectedGameObjects()));
                                    });
                                    dlg.validate();
                                }
                            }));
                            menu.createWithEvent(e);
                        });
                        controls.Tooltip.tooltip(btn, "Change the lists containing this object.");
                        this.addUpdater(() => {
                            const scene = this.getEditor().getScene();
                            if (!scene) {
                                return;
                            }
                            const listsRoot = scene.getObjectLists();
                            const lists = new Set(this.getSelection()
                                .map(obj => obj.getEditorSupport().getId())
                                .flatMap(objId => listsRoot.getListsByObjectId(objId))
                                .map(list => list.getLabel()));
                            btn.textContent = "[" + [...lists].join(",") + "]";
                        });
                    }
                    canEdit(obj, n) {
                        return sceneobjects.isGameObject(obj) && !this.isPrefabSceneObject(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.GameObjectListSection = GameObjectListSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_42.ui || (scene_42.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class GameObjectVariableSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.GameObjectVariableSection", "Variable", false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/variable-properties.html";
                    }
                    createMenu(menu) {
                        const creator = this.getEditor().getMenuCreator();
                        creator.createTypeMenuItems(menu);
                        menu.addSeparator();
                        menu.addCommand(ui.editor.commands.CMD_CREATE_PREFAB_WITH_OBJECT);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name", "The name of the variable associated to this object. This name is used by the compiler.");
                            this.createStringField(comp, sceneobjects.VariableComponent.label, false, true);
                        }
                        {
                            // GameObject name
                            this.createBooleanField(comp, sceneobjects.VariableComponent.useGameObjectName, false);
                        }
                        {
                            // Type
                            this.createLabel(comp, "Type", "The type of the object.");
                            const btn = this.createButton(comp, "", e => {
                                const dlg = new ui.editor.ConvertTypeDialog(this.getEditor());
                                dlg.create();
                            });
                            this.addUpdater(() => {
                                btn.textContent = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => {
                                    const support = obj.getEditorSupport();
                                    let typename = support.getObjectType();
                                    if (support.isPrefabInstance()) {
                                        typename = `prefab ${support.getPrefabName()} (${typename})`;
                                    }
                                    return typename;
                                }));
                            });
                        }
                        {
                            // Scope
                            this.createLabel(comp, "Scope", "The lexical scope of this object's variable, in code.");
                            this.createEnumField(comp, sceneobjects.VariableComponent.scope, false, scope => {
                                if (this.getEditor().getScene().isPrefabSceneType()) {
                                    return true;
                                }
                                return scope !== sceneobjects.ObjectScope.NESTED_PREFAB;
                            });
                        }
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.VariableComponent)
                            && !this.isPrefabSceneObject(obj)
                            && !sceneobjects.isNestedPrefabInstance(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.GameObjectVariableSection = GameObjectVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_43) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class MoveToParentOperation extends ui.editor.undo.SceneSnapshotOperation {
                    constructor(editor, parentId) {
                        super(editor);
                        this._parentId = parentId;
                    }
                    static canMoveAllTo(objList, parent) {
                        for (const obj of objList) {
                            if (!this.canMoveTo(obj, parent)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    static canMoveTo(obj, targetParent) {
                        if (!(targetParent instanceof sceneobjects.Container || targetParent instanceof sceneobjects.Layer)) {
                            return false;
                        }
                        if (targetParent.getEditorSupport().isPrefabInstance() || targetParent.getEditorSupport().isNestedPrefabInstance()) {
                            return false;
                        }
                        const objParent = sceneobjects.getObjectParent(obj);
                        if (objParent === targetParent) {
                            return false;
                        }
                        if (obj instanceof sceneobjects.Container || obj instanceof sceneobjects.Layer) {
                            if (obj === targetParent) {
                                return false;
                            }
                            const parents = new Set(targetParent.getEditorSupport().getAllParents());
                            if (parents.has(obj)) {
                                return false;
                            }
                            if (obj instanceof sceneobjects.Layer && targetParent instanceof sceneobjects.Container) {
                                return false;
                            }
                        }
                        return true;
                    }
                    async performModification() {
                        const scene = this.getScene();
                        const map = scene.buildObjectIdMap();
                        const displayList = scene.sys.displayList;
                        const objects = this.getEditor().getSelectedGameObjects();
                        scene.sortObjectsByIndex(objects);
                        for (const obj of objects) {
                            const sprite = obj;
                            const hasPosition = obj.getEditorSupport().isUnlockedProperty(sceneobjects.TransformComponent.x);
                            const currentParent = sceneobjects.getObjectParent(obj);
                            const objSupport = obj.getEditorSupport();
                            if (objSupport.getParentId() === this._parentId) {
                                continue;
                            }
                            const worldPoint = new Phaser.Math.Vector2(0, 0);
                            if (hasPosition) {
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                            }
                            if (currentParent) {
                                currentParent.remove(obj);
                            }
                            else {
                                displayList.remove(obj);
                            }
                            if (this._parentId) {
                                const newParent = map.get(this._parentId);
                                const p = new Phaser.Math.Vector2(0, 0);
                                if (newParent instanceof sceneobjects.Container) {
                                    newParent.getWorldTransformMatrix().applyInverse(worldPoint.x, worldPoint.y, p);
                                }
                                else {
                                    p.set(worldPoint.x, worldPoint.y);
                                }
                                if (hasPosition) {
                                    sprite.x = p.x;
                                    sprite.y = p.y;
                                }
                                newParent.add(sprite);
                            }
                            else {
                                if (hasPosition) {
                                    sprite.x = worldPoint.x;
                                    sprite.y = worldPoint.y;
                                }
                                displayList.add(sprite, true);
                            }
                        }
                    }
                }
                sceneobjects.MoveToParentOperation = MoveToParentOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_43.ui || (scene_43.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, OriginSection.SECTION_ID, "Origin", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/origin-properties.html";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.OriginTool.ID);
                        menu.addSeparator();
                        this.getEditor().getMenuCreator().createOriginMenuItems(menu);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.OriginComponent.origin);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.OriginComponent) !== null;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                OriginSection.SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.OriginSection";
                sceneobjects.OriginSection = OriginSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ParentDialog extends controls.dialogs.ViewerDialog {
                    constructor(editor) {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.ParentDialog"), false);
                        this._editor = editor;
                    }
                    create() {
                        const viewer = this.getViewer();
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setContentProvider(new ParentContentProvider(this._editor));
                        if (this._editor.getScene().isPrefabSceneType()) {
                            const obj = this._editor.getScene().getPrefabObject();
                            if (obj instanceof Phaser.GameObjects.Container || obj instanceof Phaser.GameObjects.Layer) {
                                viewer.setInput(obj);
                            }
                            else {
                                viewer.setInput([]);
                            }
                        }
                        else {
                            viewer.setInput(this._editor.getScene().sys.displayList);
                        }
                        viewer.setExpanded(viewer.getInput(), true);
                        super.create();
                        this.setTitle("Parent");
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Move", sel => {
                            const parent = sel[0];
                            if (parent instanceof Phaser.GameObjects.DisplayList) {
                                this._editor.getUndoManager().add(new sceneobjects.MoveToParentOperation(this._editor));
                            }
                            else {
                                this._editor.getUndoManager().add(new sceneobjects.MoveToParentOperation(this._editor, parent.getEditorSupport().getId()));
                            }
                        }));
                        this.addCancelButton();
                    }
                }
                sceneobjects.ParentDialog = ParentDialog;
                class ParentContentProvider {
                    constructor(editor) {
                        this._editor = editor;
                    }
                    getRoots(input) {
                        return [input];
                    }
                    getChildren(parent) {
                        if (parent instanceof Phaser.Structs.List) {
                            return this.filterList(parent.list);
                        }
                        if (parent instanceof Phaser.GameObjects.DisplayList) {
                            return this.filterList(parent.list);
                        }
                        if (parent instanceof sceneobjects.Container) {
                            return this.filterList(parent.list);
                        }
                        return [];
                    }
                    filterList(list) {
                        const sel = this._editor.getSelectedGameObjects();
                        return list.filter(obj => {
                            return sceneobjects.MoveToParentOperation.canMoveAllTo(sel, obj);
                        }).reverse();
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ParentSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ParentSection", "Parent", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/parent-container-properties.html";
                    }
                    createMenu(menu) {
                        menu.addCommand(ui.editor.commands.CMD_JOIN_IN_LAYER);
                        menu.addCommand(ui.editor.commands.CMD_JOIN_IN_CONTAINER);
                        menu.addCommand(ui.editor.commands.CMD_MOVE_TO_PARENT);
                        menu.addCommand(ui.editor.commands.CMD_SELECT_PARENT);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.createLabel(comp, "Parent", "The parent Container or Layer of the object, or the Display List");
                        const btn = this.createButton(comp, "(Select)", e => {
                            const dlg = new sceneobjects.ParentDialog(this.getEditor());
                            dlg.create();
                            dlg.eventDialogClose.addListener(() => {
                                this.updateWithSelection();
                            });
                        });
                        controls.Tooltip.tooltip(btn, "Moves the objects for a new container or the Display List.");
                        this.addUpdater(() => {
                            const sel = this.getSelection();
                            const parents = sel
                                .map(obj => sceneobjects.getObjectParent(obj))
                                .filter(cont => cont);
                            const parentsSet = new Set(parents);
                            let str;
                            if (parentsSet.size === 1 && parents.length === sel.length) {
                                str = parents[0].getEditorSupport().getLabel();
                            }
                            else if (parents.length === 0) {
                                str = "Display List";
                            }
                            else {
                                str = `(${parentsSet.size} selected)`;
                            }
                            btn.textContent = str;
                        });
                    }
                    canEdit(obj, n) {
                        return sceneobjects.isGameObject(obj) && !sceneobjects.isNestedPrefabInstance(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ParentSection = ParentSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class PrefabInstanceSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.PrefabInstanceUserPropertySection", "Prefab Instance");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/prefab-user-properties.html#user-properties-in-a-prefab-instance";
                    }
                    createMenu(menu) {
                        menu.addCommand(ui.editor.commands.CMD_OPEN_PREFAB);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "1fr";
                        this._propArea = this.createGridElement(comp);
                        this._propArea.style.gridTemplateColumns = "auto auto 1fr";
                        comp.appendChild(this._propArea);
                        this.addUpdater(() => {
                            this._propArea.innerHTML = "";
                            const obj = this.getSelectionFirstElement();
                            if (obj.getEditorSupport().isNestedPrefabInstance()) {
                                const file = obj.getEditorSupport().getPrefabFile();
                                this.createPrefabLink(file, `Root Prefab: ${file.getNameWithoutExtension()}`);
                            }
                            const userPropsComponent = sceneobjects.GameObjectEditorSupport
                                .getObjectComponent(obj, sceneobjects.PrefabUserPropertyComponent);
                            const propsByPrefabList = userPropsComponent.getPropertiesByPrefab();
                            for (const propsByPrefab of propsByPrefabList) {
                                const prefabFile = propsByPrefab.prefabFile;
                                const prefabName = prefabFile.getNameWithoutExtension();
                                const headerDiv = this.createPrefabLink(prefabFile);
                                // const headerDiv = document.createElement("div");
                                // headerDiv.classList.add("PrefabLink");
                                // headerDiv.style.gridColumn = "1 / span 3";
                                // headerDiv.style.width = "100%";
                                // this._propArea.appendChild(headerDiv);
                                // const prefabBtn = document.createElement("a");
                                // prefabBtn.href = "#";
                                // prefabBtn.innerHTML = prefabName;
                                // headerDiv.appendChild(prefabBtn);
                                // const openFileCallback = () => colibri.Platform.getWorkbench().openEditor(propsByPrefab.prefabFile);
                                // prefabBtn.addEventListener("click", openFileCallback);
                                this.createMenuIcon(headerDiv, () => {
                                    const menu = new controls.Menu();
                                    menu.addAction({
                                        text: `Select All ${prefabName}`,
                                        callback: () => {
                                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                            const sel = [];
                                            this.getEditor().getScene().visitAll(obj2 => {
                                                if (sceneobjects.GameObjectEditorSupport.hasEditorSupport(obj2)) {
                                                    const editorSupport = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj2);
                                                    if (editorSupport.isPrefabInstance()) {
                                                        const prefabFiles = finder.getPrefabHierarchy(editorSupport.getPrefabId());
                                                        if (prefabFiles.indexOf(prefabFile) >= 0) {
                                                            sel.push(obj2);
                                                        }
                                                    }
                                                }
                                            });
                                            this.getEditor().setSelection(sel);
                                        }
                                    });
                                    menu.addAction({
                                        text: `Open ${prefabName} File`,
                                        callback: () => colibri.Platform.getWorkbench().openEditor(prefabFile)
                                    });
                                    return menu;
                                });
                                for (const prop of propsByPrefab.properties) {
                                    prop.getType().createInspectorPropertyEditor(this, this._propArea, prop, true);
                                }
                            }
                        });
                    }
                    createPrefabLink(file, btnText) {
                        const headerDiv = document.createElement("div");
                        headerDiv.classList.add("PrefabLink");
                        headerDiv.style.gridColumn = "1 / span 3";
                        headerDiv.style.width = "100%";
                        this._propArea.appendChild(headerDiv);
                        const prefabBtn = document.createElement("a");
                        prefabBtn.href = "#";
                        prefabBtn.innerHTML = btnText ?? file.getNameWithoutExtension();
                        headerDiv.appendChild(prefabBtn);
                        prefabBtn.addEventListener("click", () => colibri.Platform.getWorkbench().openEditor(file));
                        return headerDiv;
                    }
                    canEdit(obj, n) {
                        return true;
                    }
                    canEditNumber(n) {
                        if (n === 0) {
                            return false;
                        }
                        const obj = this.getSelectionFirstElement();
                        if (sceneobjects.GameObjectEditorSupport.hasEditorSupport(obj)) {
                            const support = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                            if (support.isPrefabInstance()) {
                                const prefabFile = support.getPrefabFile();
                                for (const obj2 of this.getSelection()) {
                                    if (sceneobjects.GameObjectEditorSupport.hasEditorSupport(obj2)) {
                                        const support2 = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj2);
                                        if (support2.isPrefabInstance()) {
                                            const prefabFile2 = support2.getPrefabFile();
                                            if (prefabFile !== prefabFile2) {
                                                return false;
                                            }
                                        }
                                        else {
                                            return false;
                                        }
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                        return false;
                    }
                }
                sceneobjects.PrefabInstanceSection = PrefabInstanceSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../SceneGameObjectOperation.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PropertyUnlockOperation extends sceneobjects.SceneGameObjectOperation {
                    constructor(editor, objects, properties, unlocked) {
                        super(editor, objects, unlocked);
                        this._properties = properties;
                    }
                    getValue(obj) {
                        for (const prop of this._properties) {
                            const locked = !obj.getEditorSupport().isUnlockedProperty(prop);
                            if (locked) {
                                return false;
                            }
                        }
                        return true;
                    }
                    setValue(obj, unlocked) {
                        for (const prop of this._properties) {
                            const support = obj.getEditorSupport();
                            if (support.isPrefabInstance()) {
                                if (!unlocked) {
                                    const prefabSer = support.getPrefabSerializer();
                                    const propValue = prefabSer.read(prop.name, support.getPropertyDefaultValue(prop));
                                    prop.setValue(obj, propValue);
                                }
                                obj.getEditorSupport().setUnlockedProperty(prop, unlocked);
                            }
                        }
                    }
                }
                sceneobjects.PropertyUnlockOperation = PropertyUnlockOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/properties/BaseSceneSection.ts"/>
/// <reference path="./SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TransformSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, TransformSection.SECTION_ID, "Transform", false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/transform-properties.html";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.TranslateTool.ID);
                        this.createToolMenuItem(menu, sceneobjects.ScaleTool.ID);
                        this.createToolMenuItem(menu, sceneobjects.RotateTool.ID);
                        menu.addSeparator();
                        this.getEditor().getMenuCreator().createCoordsMenuItems(menu);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.TransformComponent.position);
                        this.createPropertyXYRow(comp, sceneobjects.TransformComponent.scale);
                        this.createNumberPropertyRow(comp, sceneobjects.TransformComponent.angle, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.TransformComponent) !== null && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                TransformSection.SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.TransformSection";
                sceneobjects.TransformSection = TransformSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var UserComponent = ui.editor.usercomponent.UserComponent;
                class UserComponentInstancePropertySection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.UserComponentInstancePropertySection", "User Components", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/user-components-instancing.html";
                    }
                    getCommonComponents(getComponents) {
                        const nameCountMap = new Map();
                        for (const obj of this.getSelection()) {
                            const editorComp = sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.UserComponentsEditorComponent);
                            const result = getComponents(editorComp);
                            for (const name of result) {
                                if (nameCountMap.has(name)) {
                                    const count = nameCountMap.get(name);
                                    nameCountMap.set(name, count + 1);
                                }
                                else {
                                    nameCountMap.set(name, 1);
                                }
                            }
                        }
                        const total = this.getSelection().length;
                        const names = [...nameCountMap.keys()];
                        return names
                            .filter(name => nameCountMap.get(name) === total);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "1fr";
                        this._propArea = this.createGridElement(comp);
                        this._propArea.style.gridTemplateColumns = "1fr";
                        comp.appendChild(this._propArea);
                        this.addUpdater(() => {
                            this._propArea.innerHTML = "";
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const editorCompList = this.getSelection()
                                .map(obj => sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.UserComponentsEditorComponent));
                            const commonLocalComponents = this.getCommonComponents(c => c.getUserComponents().map(info => info.component.getName()));
                            for (const compName of commonLocalComponents) {
                                const compInfo = finder.getUserComponentByName(compName);
                                const headerDiv = document.createElement("div");
                                headerDiv.classList.add("PrefabLink");
                                headerDiv.style.width = "100%";
                                this._propArea.appendChild(headerDiv);
                                const compBtn = document.createElement("a");
                                headerDiv.appendChild(compBtn);
                                compBtn.href = "#";
                                compBtn.innerHTML = compName;
                                compBtn.addEventListener("click", e => {
                                    const info = finder.getUserComponentByName(compName);
                                    const editor = colibri.Platform.getWorkbench().openEditor(info.file);
                                    editor.revealComponent(compName);
                                    colibri.Platform.getWorkbench().openEditor(compInfo.file);
                                });
                                this.createComponentMenuIcon(headerDiv, editorCompList, compName, true);
                                {
                                    const props = compInfo.component.getUserProperties().getProperties();
                                    if (props.length > 0) {
                                        const compPropArea = this.createGridElement(this._propArea);
                                        compPropArea.style.gridTemplateColumns = "auto auto 1fr";
                                        compPropArea.style.width = "100%";
                                        for (const prop of props) {
                                            prop.getType().createInspectorPropertyEditor(this, compPropArea, prop, false);
                                        }
                                    }
                                }
                            }
                            // prefab components
                            const commonPrefabComponents = new Set(this.getCommonComponents(c => c.getPrefabUserComponents()
                                .flatMap(info => info.components)
                                .flatMap(comp2 => comp2.getName())));
                            for (const editorComp of editorCompList) {
                                const result = editorComp.getPrefabUserComponents();
                                for (const compInfo of result) {
                                    for (const userComp of compInfo.components) {
                                        if (commonPrefabComponents.has(userComp.getName())) {
                                            commonPrefabComponents.delete(userComp.getName());
                                        }
                                        else {
                                            continue;
                                        }
                                        const headerDiv = document.createElement("div");
                                        headerDiv.classList.add("PrefabLink");
                                        headerDiv.style.width = "100%";
                                        this._propArea.appendChild(headerDiv);
                                        // open prefab file
                                        const prefabBtn = document.createElement("a");
                                        headerDiv.appendChild(prefabBtn);
                                        prefabBtn.href = "#";
                                        prefabBtn.innerHTML = compInfo.prefabFile.getNameWithoutExtension();
                                        prefabBtn.addEventListener("click", e => {
                                            colibri.Platform.getWorkbench().openEditor(compInfo.prefabFile);
                                        });
                                        const elem = document.createElement("label");
                                        elem.innerHTML = " &rsaquo; ";
                                        headerDiv.appendChild(elem);
                                        // open components file
                                        const compBtn = document.createElement("a");
                                        headerDiv.appendChild(compBtn);
                                        compBtn.href = "#";
                                        compBtn.innerHTML = userComp.getName();
                                        compBtn.addEventListener("click", e => {
                                            const info = finder.getUserComponentByName(userComp.getName());
                                            const editor = colibri.Platform.getWorkbench().openEditor(info.file);
                                            editor.revealComponent(userComp.getName());
                                        });
                                        this.createComponentMenuIcon(headerDiv, editorCompList, userComp.getName(), false);
                                        {
                                            const props = userComp.getUserProperties().getProperties();
                                            if (props.length > 0) {
                                                const compPropArea = this.createGridElement(this._propArea);
                                                compPropArea.style.gridTemplateColumns = "auto auto 1fr";
                                                compPropArea.style.width = "100%";
                                                for (const prop of props) {
                                                    prop.getType().createInspectorPropertyEditor(this, compPropArea, prop, true);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            // Add Components button
                            const btn = this.createButton(this._propArea, "Add Component", () => {
                                const used = new Set([...editorCompList
                                        .flatMap(editorComp => editorComp.getUserComponents())
                                        .map(info => info.component.getName()),
                                    ...editorCompList.flatMap(editorComp => editorComp.getPrefabUserComponents())
                                        .flatMap(info => info.components)
                                        .map(c => c.getName())
                                ]);
                                class ContentProvider {
                                    getRoots(input) {
                                        return finder.getUserComponentsModels()
                                            .filter(info => info.model.getComponents().filter(c => !used.has(c.getName())).length > 0);
                                    }
                                    getChildren(parentObj) {
                                        if (parentObj instanceof UserComponent) {
                                            return [];
                                        }
                                        return parentObj.model.getComponents().filter(c => !used.has(c.getName()));
                                    }
                                }
                                const viewer = new controls.viewers.TreeViewer("UserComponentInstancePropertySection.addComponentDialogViewer");
                                viewer.setStyledLabelProvider({
                                    getStyledTexts: (obj, dark) => {
                                        const theme = controls.Controls.getTheme();
                                        if (obj instanceof UserComponent) {
                                            return [{
                                                    text: obj.getName(),
                                                    color: theme.viewerForeground
                                                }];
                                        }
                                        return [{
                                                text: obj.file.getNameWithoutExtension(),
                                                color: theme.viewerForeground
                                            }, {
                                                text: " - " + obj.file.getParent().getProjectRelativeName()
                                                    .split("/").filter(s => s !== "").reverse().join("/"),
                                                color: theme.viewerForeground + "90"
                                            }];
                                    }
                                });
                                viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider((obj) => new controls.viewers.IconImageCellRenderer(obj instanceof UserComponent ?
                                    scene.ScenePlugin.getInstance().getIcon(scene.ICON_USER_COMPONENT)
                                    : colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER))));
                                viewer.setContentProvider(new ContentProvider());
                                viewer.setInput([]);
                                viewer.expandRoots(false);
                                const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                                dlg.setSize(undefined, 400, true);
                                dlg.create();
                                dlg.setTitle("User Component");
                                dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Add Component", () => {
                                    const selComp = viewer.getSelectionFirstElement();
                                    if (selComp) {
                                        this.runOperation(() => {
                                            for (const editorComp of editorCompList) {
                                                editorComp.addUserComponent(selComp.getName());
                                            }
                                        });
                                        this.updateWithSelection();
                                    }
                                }), obj => obj instanceof UserComponent);
                                dlg.addCancelButton();
                            });
                            btn.style.width = "100%";
                            btn.style.justifySelf = "self-center";
                            btn.style.marginTop = "10px";
                        });
                    }
                    createComponentMenuIcon(headerDiv, editorCompList, compName, localComponent) {
                        this.createMenuIcon(headerDiv, () => {
                            const menu = new controls.Menu();
                            menu.addAction({
                                text: `Select All With ${compName}`,
                                callback: () => {
                                    const sel = [];
                                    this.getEditor().getScene().visitAll(obj => {
                                        if (sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.UserComponentsEditorComponent)) {
                                            const userComp = sceneobjects.GameObjectEditorSupport
                                                .getObjectComponent(obj, sceneobjects.UserComponentsEditorComponent);
                                            if (userComp.hasUserComponent(compName)) {
                                                sel.push(obj);
                                            }
                                        }
                                    });
                                    this.getEditor().setSelection(sel);
                                }
                            });
                            if (localComponent) {
                                if (editorCompList.length === 1) {
                                    menu.addAction({
                                        text: "Move Up",
                                        callback: () => {
                                            this.runOperation(() => {
                                                const editorComp = editorCompList[0];
                                                editorComp.moveUpUserComponent(compName);
                                            });
                                            this.updateWithSelection();
                                        }
                                    });
                                    menu.addAction({
                                        text: "Move Down",
                                        callback: () => {
                                            this.runOperation(() => {
                                                const editorComp = editorCompList[0];
                                                editorComp.moveDownUserComponent(compName);
                                            });
                                            this.updateWithSelection();
                                        }
                                    });
                                }
                                menu.addAction({
                                    text: "Delete",
                                    callback: () => {
                                        this.runOperation(() => {
                                            for (const editorComp of editorCompList) {
                                                editorComp.removeUserComponent(compName);
                                            }
                                        });
                                        this.updateWithSelection();
                                    }
                                });
                            }
                            return menu;
                        });
                    }
                    runOperation(action) {
                        const editor = this.getEditor();
                        editor.getUndoManager().add(new ui.editor.undo.SimpleSceneSnapshotOperation(editor, action));
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasEditorSupport(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.UserComponentInstancePropertySection = UserComponentInstancePropertySection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                var io = colibri.core.io;
                class UserComponentsEditorComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, []);
                        this._propData = {};
                        this._compNames = [];
                    }
                    writeJSON(ser) {
                        ser.getData()["components"] = [...this._compNames];
                        super.writeJSON(ser);
                    }
                    writeProperty(ser, prop) {
                        if (prop instanceof sceneobjects.UserComponentPropertyWrapper) {
                            // This may happen when you add a user component to a prefab instance.
                            // in that case, the properties are local.
                            // But if the user property is inherited from the prefab, then it is not local.
                            const local = this.getEditorSupport().isLocalUserProperty(prop);
                            super.writeProperty(ser, prop, local);
                            return;
                        }
                        super.writeProperty(ser, prop);
                    }
                    readJSON(ser) {
                        this._compNames = ser.getData()["components"] || [];
                        super.readJSON(ser);
                    }
                    setPropertyValue(compName, prop, value) {
                        this._propData[this.getPropertyKey(compName, prop.getName())] = value;
                    }
                    getPropertyValue(compName, prop) {
                        return this._propData[this.getPropertyKey(compName, prop.getName())];
                    }
                    isPropertySet(compName, prop) {
                        return this.getPropertyKey(compName, prop.getName()) in this._propData;
                    }
                    hasLocalUserComponent(compName) {
                        return this._compNames.indexOf(compName) >= 0;
                    }
                    hasUserComponent(compName) {
                        if (this.hasLocalUserComponent(compName)) {
                            return true;
                        }
                        const find = this.getPrefabUserComponents()
                            .flatMap(info => info.components)
                            .find(c => c.getName() === compName);
                        return find !== undefined;
                    }
                    addUserComponent(compName) {
                        this._compNames.push(compName);
                    }
                    removeUserComponent(compName) {
                        this._compNames = this._compNames.filter(name => name !== compName);
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const compInfo = finder.getUserComponentByName(compName);
                        if (compInfo) {
                            for (const prop of compInfo.component.getUserProperties().getProperties()) {
                                delete this._propData[this.getPropertyKey(compName, prop.getName())];
                            }
                        }
                    }
                    moveUpUserComponent(compName) {
                        const i = this._compNames.indexOf(compName);
                        if (i > 0) {
                            const temp = this._compNames[i - 1];
                            this._compNames[i - 1] = compName;
                            this._compNames[i] = temp;
                        }
                    }
                    moveDownUserComponent(compName) {
                        const i = this._compNames.indexOf(compName);
                        const lastIndex = this._compNames.length - 1;
                        if (i >= 0 && i < lastIndex) {
                            const temp = this._compNames[i + 1];
                            this._compNames[i + 1] = compName;
                            this._compNames[i] = temp;
                        }
                    }
                    getPropertyKey(compName, propName) {
                        return `${compName}.${propName}`;
                    }
                    getUserComponents() {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        return this._compNames
                            .map(compName => finder.getUserComponentByName(compName))
                            .filter(c => c !== undefined);
                    }
                    getPrefabUserComponents() {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const result = [];
                        const support = this.getObject().getEditorSupport();
                        if (support.isPrefabInstance()) {
                            const objData = finder.getPrefabData(support.getPrefabId());
                            if (objData) {
                                if (objData.components) {
                                    this.getUserComponentsOfPrefab(support.getPrefabId(), result);
                                }
                            }
                        }
                        return result;
                    }
                    getUserComponentsOfPrefab(prefabId, result) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabFile = finder.getPrefabFile(prefabId);
                        const objData = finder.getPrefabData(prefabId);
                        if (objData) {
                            if (objData.components) {
                                const components = objData.components
                                    .map(compName => finder.getUserComponentByName(compName))
                                    .filter(info => info !== undefined)
                                    .map(info => info.component);
                                if (components.length > 0) {
                                    result.push({ prefabFile, components });
                                }
                            }
                            if (objData.prefabId) {
                                this.getUserComponentsOfPrefab(objData.prefabId, result);
                            }
                        }
                    }
                    getProperties() {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const compNames = [...this._compNames];
                        compNames.push(...this.getPrefabUserComponents()
                            .flatMap(info => info.components)
                            .map(c => c.getName()));
                        const properties = compNames
                            .map(compName => finder.getUserComponentByName(compName))
                            .filter(c => c !== undefined)
                            .flatMap(c => c.component.getUserProperties().getProperties())
                            .flatMap(p => p.getComponentProperty());
                        return new Set(properties);
                    }
                    formatComponentVarName(name) {
                        return name.replaceAll(".", "_");
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const allPropsStart = args.lazyStatements.length;
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        for (const compName of this._compNames) {
                            const compInfo = finder.getUserComponentByName(compName);
                            if (compInfo) {
                                const compVarName = this.formatComponentVarName(args.objectVarName + compName);
                                const compPropsStart = args.lazyStatements.length;
                                this.buildSetObjectPropertiesCodeDOM2(compInfo.component, compName, compVarName, args);
                                args.lazyStatements.splice(compPropsStart, 0, new code.RawCodeDOM(compPropsStart === args.lazyStatements.length ?
                                    `new ${compName}(${args.objectVarName});`
                                    : `const ${compVarName} = new ${compName}(${args.objectVarName});`));
                                const filePath = code.getImportPath(args.sceneFile, new io.FilePath(compInfo.file.getParent(), {
                                    isFile: true,
                                    modTime: 0,
                                    name: compName,
                                    size: 0,
                                    children: []
                                }));
                                args.unit.addImport(compName, filePath);
                            }
                        }
                        const prefabUserComponents = this.getPrefabUserComponents();
                        for (const prefabUserComps of prefabUserComponents) {
                            for (const comp of prefabUserComps.components) {
                                const compName = comp.getName();
                                const compVarName = this.formatComponentVarName(args.objectVarName + compName);
                                const prefabPropsStart = args.lazyStatements.length;
                                this.buildSetObjectPropertiesCodeDOM2(comp, compName, compVarName, args);
                                if (prefabPropsStart !== args.lazyStatements.length) {
                                    args.lazyStatements.splice(prefabPropsStart, 0, new code.RawCodeDOM(`const ${compVarName} = ${compName}.getComponent(${args.objectVarName});`));
                                    const compInfo = finder.getUserComponentByName(compName);
                                    const filePath = code.getImportPath(args.sceneFile, new io.FilePath(compInfo.file.getParent(), {
                                        isFile: true,
                                        modTime: 0,
                                        name: compName,
                                        size: 0,
                                        children: []
                                    }));
                                    args.unit.addImport(compName, filePath);
                                }
                            }
                        }
                        if (allPropsStart !== args.lazyStatements.length) {
                            args.lazyStatements.splice(allPropsStart, 0, new code.RawCodeDOM(""), new code.RawCodeDOM(`// ${args.objectVarName} (components)`));
                        }
                    }
                    buildSetObjectPropertiesCodeDOM2(comp, compName, compVarName, args) {
                        const temp = args.statements;
                        args.statements = args.lazyStatements;
                        const props = comp.getUserProperties().getProperties();
                        if (props.length > 0) {
                            const objVarName = args.objectVarName;
                            for (const userProp of props) {
                                args.objectVarName = compVarName;
                                userProp.getType().buildSetObjectPropertyCodeDOM(this, args, userProp);
                            }
                            args.objectVarName = objVarName;
                        }
                        args.statements = temp;
                    }
                }
                sceneobjects.UserComponentsEditorComponent = UserComponentsEditorComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class VisibleSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, VisibleSection.SECTION_ID, "Visible", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/visible-property.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createPropertyBoolean(comp, sceneobjects.VisibleComponent.visible);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.VisibleComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                VisibleSection.SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.VisibleSection";
                sceneobjects.VisibleSection = VisibleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseObjectTool extends ui.editor.tools.SceneTool {
                    constructor(config, ...properties) {
                        super(config);
                        this._properties = properties;
                    }
                    getProperties(obj) {
                        return this._properties;
                    }
                    canEdit(obj) {
                        if (sceneobjects.isGameObject(obj)) {
                            const support = obj.getEditorSupport();
                            const props = this.getProperties(obj);
                            for (const prop of props) {
                                if (!support.hasProperty(prop)) {
                                    return false;
                                }
                                if (!support.isUnlockedProperty(prop)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        return false;
                    }
                    canRender(obj) {
                        if (sceneobjects.isGameObject(obj)) {
                            const support = obj.getEditorSupport();
                            const props = this.getProperties(obj);
                            for (const prop of props) {
                                if (support.hasProperty(prop)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    confirmUnlockProperty(args, props, propLabel, ...sectionId) {
                        args.editor.confirmUnlockProperty(props, propLabel, ...sectionId);
                    }
                }
                sceneobjects.BaseObjectTool = BaseObjectTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                const containerOriginProperty = {
                    defValue: undefined,
                    setValue: (obj, value) => {
                        obj.setPosition(value.x, value.y);
                        let i = 0;
                        for (const child of obj.list) {
                            child.setPosition(value.children[i].x, value.children[i].y);
                            i++;
                        }
                    },
                    getValue: obj => {
                        return {
                            x: obj.x,
                            y: obj.y,
                            children: obj.list.map((child) => ({
                                x: child.x,
                                y: child.y
                            }))
                        };
                    },
                    name: "containerOrigin"
                };
                class ContainerOriginToolItem extends ui.editor.tools.SceneToolItem {
                    constructor(axis) {
                        super();
                        this._axis = axis;
                    }
                    isValidFor(objects) {
                        return objects.length === 1 && objects[0] instanceof sceneobjects.Container;
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return d < 20;
                    }
                    onStartDrag(args) {
                        if (this.containsPoint(args)) {
                            const container = this.getContainer(args);
                            this._initCursorPos = { x: args.x, y: args.y };
                            this._position_1 = new Phaser.Math.Vector2(container.x, container.y);
                            this._localTx = container.getLocalTransformMatrix();
                            this._worldTx = container.getWorldTransformMatrix();
                            this._worldPosition_1 = new Phaser.Math.Vector2();
                            container.getWorldTransformMatrix().transformPoint(0, 0, this._worldPosition_1);
                            for (const obj of container.list) {
                                const sprite = obj;
                                sprite.setData("ContainerOriginTool.position", { x: sprite.x, y: sprite.y });
                            }
                            this._initValue = containerOriginProperty.getValue(container);
                        }
                    }
                    getContainer(args) {
                        return args.objects[0];
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        const cursorDx = args.x - this._initCursorPos.x;
                        const cursorDy = args.y - this._initCursorPos.y;
                        const xAxis = this._axis === "x" || this._axis === "xy" ? 1 : 0;
                        const yAxis = this._axis === "y" || this._axis === "xy" ? 1 : 0;
                        const worldDx = cursorDx / args.camera.zoom * xAxis;
                        const worldDy = cursorDy / args.camera.zoom * yAxis;
                        const worldPoint = new Phaser.Math.Vector2(this._worldPosition_1.x + worldDx, this._worldPosition_1.y + worldDy);
                        const container = this.getContainer(args);
                        const localPoint = new Phaser.Math.Vector2();
                        this._worldTx.applyInverse(worldPoint.x, worldPoint.y, localPoint);
                        for (const child of container.list) {
                            const sprite = child;
                            const { x, y } = sprite.getData("ContainerOriginTool.position");
                            sprite.x = x - localPoint.x;
                            sprite.y = y - localPoint.y;
                        }
                        const delta = new Phaser.Math.Vector2();
                        this._localTx.transformPoint(localPoint.x, localPoint.y, delta);
                        delta.x -= this._position_1.x;
                        delta.y -= this._position_1.y;
                        container.setPosition(this._position_1.x + delta.x, this._position_1.y + delta.y);
                        args.editor.dispatchSelectionChanged();
                    }
                    onStopDrag(args) {
                        if (this._initCursorPos) {
                            const editor = args.editor;
                            const container = this.getContainer(args);
                            const value = containerOriginProperty.getValue(container);
                            containerOriginProperty.setValue(container, this._initValue);
                            editor.getUndoManager().add(new sceneobjects.SimpleOperation(editor, [container], containerOriginProperty, value));
                        }
                        this._initCursorPos = null;
                    }
                    getPoint(args) {
                        return this.getSimpleTranslationPoint(this._axis, args);
                    }
                    render(args) {
                        const { x, y } = this.getPoint(args);
                        this.renderSimpleAxis(this._axis, x, y, "#fff", args);
                    }
                }
                sceneobjects.ContainerOriginToolItem = ContainerOriginToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/tools/SceneToolOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.OriginToolItem.getInitObjectOriginAndPosition(obj);
                    }
                    getFinalValue(obj) {
                        return sceneobjects.OriginToolItem.createFinalData(obj);
                    }
                    setValue(obj, value) {
                        const sprite = obj;
                        sprite.x = value.x;
                        sprite.y = value.y;
                        sprite.setOrigin(value.originX, value.originY);
                    }
                }
                sceneobjects.OriginOperation = OriginOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginTool extends sceneobjects.BaseObjectTool {
                    constructor() {
                        super({
                            id: OriginTool.ID,
                            command: ui.editor.commands.CMD_SET_ORIGIN_SCENE_OBJECT,
                        });
                        const x = new sceneobjects.OriginToolItem("x");
                        const y = new sceneobjects.OriginToolItem("y");
                        const xy = new sceneobjects.OriginToolItem("xy");
                        const containerX = new sceneobjects.ContainerOriginToolItem("x");
                        const containerY = new sceneobjects.ContainerOriginToolItem("y");
                        const containerXY = new sceneobjects.ContainerOriginToolItem("xy");
                        this.addItems(new ui.editor.tools.LineToolItem("#f00", xy, x), new ui.editor.tools.LineToolItem("#0f0", xy, y), xy, x, y, new ui.editor.tools.LineToolItem("#f00", containerXY, containerX), new ui.editor.tools.LineToolItem("#0f0", containerXY, containerY), containerXY, containerX, containerY);
                    }
                    getProperties(obj) {
                        return obj.getEditorSupport().getOriginProperties();
                    }
                    canEdit(obj) {
                        if (obj instanceof sceneobjects.Container) {
                            if (obj.getEditorSupport().isPrefabInstance()) {
                                for (const test of [obj, ...obj.getChildren()]) {
                                    if (!test.getEditorSupport().isUnlockedPropertyXY(sceneobjects.TransformComponent.position)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        return super.canEdit(obj);
                    }
                    canRender(obj) {
                        if (obj instanceof sceneobjects.Container) {
                            return true;
                        }
                        return super.canRender(obj);
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        const props = args.objects.flatMap(obj => obj.getEditorSupport().getOriginProperties());
                        const sections = args.objects.flatMap(obj => obj.getEditorSupport().getOriginSectionId());
                        this.confirmUnlockProperty(args, props, "origin", ...sections);
                    }
                }
                OriginTool.ID = "phasereditor2d.scene.ui.sceneobjects.OriginTool";
                sceneobjects.OriginTool = OriginTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginToolItem extends ui.editor.tools.SceneToolItem {
                    constructor(axis) {
                        super();
                        this._axis = axis;
                    }
                    isValidFor(objects) {
                        return objects.length === 1
                            && objects[0].getEditorSupport().supportsOrigin();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return d < 20;
                    }
                    onStartDrag(args) {
                        if (this.containsPoint(args)) {
                            this._initCursorPos = { x: args.x, y: args.y };
                            const sprite = this.getSprite(args);
                            const worldPoint = new Phaser.Math.Vector2();
                            const tx = sprite.getWorldTransformMatrix();
                            tx.transformPoint(0, 0, worldPoint);
                            const { originX, originY } = sprite.getEditorSupport().computeOrigin();
                            const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                            this._spriteWorldPosition_1 = worldPoint;
                            this._spriteWorldTx_1 = tx;
                            this._localTx_1 = sprite.getLocalTransformMatrix();
                            this._displayOrigin_1 = new Phaser.Math.Vector2(displayOriginX, displayOriginY);
                            this._origin_1 = new Phaser.Math.Vector2(originX, originY);
                            this._position_1 = new Phaser.Math.Vector2(sprite.x, sprite.y);
                        }
                    }
                    getSprite(args) {
                        return args.objects[0];
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        const sprite = this.getSprite(args);
                        const worldDelta = this.getTranslationInAxisWorldDelta(this._axis, this._initCursorPos.x, this._initCursorPos.y, args);
                        const worldPoint2 = this._spriteWorldPosition_1.clone().add(worldDelta);
                        const displayOriginPoint_2 = new Phaser.Math.Vector2();
                        this._spriteWorldTx_1.applyInverse(worldPoint2.x, worldPoint2.y, displayOriginPoint_2);
                        // when get the display point, it uses the initial origin,
                        // so we have to add it to the result, to get a 0,0 based display origin.
                        const originX_2 = (this._displayOrigin_1.x + displayOriginPoint_2.x) / sprite.width;
                        const originY_2 = (this._displayOrigin_1.y + displayOriginPoint_2.y) / sprite.height;
                        OriginToolItem.changeOriginKeepPosition(sprite, this._displayOrigin_1.x, this._displayOrigin_1.y, originX_2, originY_2, this._localTx_1, this._position_1.x, this._position_1.y);
                        args.editor.updateInspectorViewSection(sprite.getEditorSupport().getOriginSectionId());
                    }
                    static simpleChangeOriginKeepPosition(sprite, newOriginX, newOriginY) {
                        const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        this.changeOriginKeepPosition(sprite, displayOriginX, displayOriginY, newOriginX, newOriginY, sprite.getLocalTransformMatrix(), sprite.x, sprite.y);
                    }
                    static changeOriginKeepPosition(sprite, displayOriginX_1, displayOriginY_1, originX_2, originY_2, localTx_1, x_1, y_1) {
                        sprite.setOrigin(originX_2, originY_2);
                        const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        const displayOriginDx = displayOriginX - displayOriginX_1;
                        const displayOriginDy = displayOriginY - displayOriginY_1;
                        const displayOriginDelta = new Phaser.Math.Vector2(displayOriginDx, displayOriginDy);
                        localTx_1.transformPoint(displayOriginDelta.x, displayOriginDelta.y, displayOriginDelta);
                        displayOriginDelta.add(new Phaser.Math.Vector2(-x_1, -y_1));
                        sprite.setPosition(x_1 + displayOriginDelta.x, y_1 + displayOriginDelta.y);
                    }
                    static getInitObjectOriginAndPosition(obj) {
                        return obj.getData("OriginTool.initData");
                    }
                    static createFinalData(sprite) {
                        const { originX, originY } = sprite.getEditorSupport().computeOrigin();
                        return {
                            x: sprite.x,
                            y: sprite.y,
                            originX: originX,
                            originY: originY
                        };
                    }
                    onStopDrag(args) {
                        if (this._initCursorPos) {
                            const editor = args.editor;
                            const sprite = this.getSprite(args);
                            const data = {
                                x: this._position_1.x,
                                y: this._position_1.y,
                                originX: this._origin_1.x,
                                originY: this._origin_1.y
                            };
                            sprite.setData("OriginTool.initData", data);
                            editor.getUndoManager().add(new sceneobjects.OriginOperation(args));
                        }
                        this._initCursorPos = null;
                    }
                    getPoint(args) {
                        return this.getSimpleTranslationPoint(this._axis, args);
                    }
                    render(args) {
                        const { x, y } = this.getPoint(args);
                        this.renderSimpleAxis(this._axis, x, y, "#fff", args);
                    }
                }
                sceneobjects.OriginToolItem = OriginToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PanTool extends ui.editor.tools.SceneTool {
                    constructor() {
                        super({
                            command: ui.editor.commands.CMD_PAN_SCENE,
                            id: PanTool.ID
                        });
                    }
                    onActivated(args) {
                        this.setCursor(args.editor, "grab");
                    }
                    onDeactivated(args) {
                        this.setCursor(args.editor, "auto");
                    }
                    setCursor(editor, style) {
                        editor.getOverlayLayer().getCanvas().style.cursor = style;
                    }
                    onStartDrag(args) {
                        const camera = args.camera;
                        const e = args.event;
                        this._dragStartPoint = new Phaser.Math.Vector2(e.offsetX, e.offsetY);
                        this._dragStartCameraScroll = new Phaser.Math.Vector2(camera.scrollX, camera.scrollY);
                        args.event.preventDefault();
                    }
                    onDrag(args) {
                        this.setCursor(args.editor, "grabbing");
                        const e = args.event;
                        const dx = this._dragStartPoint.x - e.offsetX;
                        const dy = this._dragStartPoint.y - e.offsetY;
                        const camera = args.camera;
                        camera.scrollX = this._dragStartCameraScroll.x + dx / camera.zoom;
                        camera.scrollY = this._dragStartCameraScroll.y + dy / camera.zoom;
                        e.preventDefault();
                        args.editor.repaint();
                    }
                    onStopDrag(args) {
                        this.setCursor(args.editor, "grab");
                    }
                    render(args) {
                        // nothing
                    }
                    canEdit(obj) {
                        return false;
                    }
                    canRender(obj) {
                        return false;
                    }
                    isObjectTool() {
                        return false;
                    }
                }
                PanTool.ID = "phasereditor2d.scene.ui.sceneobjects.PanTool";
                sceneobjects.PanTool = PanTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateLineToolItem extends ui.editor.tools.SceneToolItem {
                    constructor(start) {
                        super();
                        this._start = start;
                    }
                    render(args) {
                        let globalStartAngle = 0;
                        let globalEndAngle = 0;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const endAngle = this.globalAngle(sprite);
                            let startAngle = 0;
                            if (args.localCoords) {
                                if (sprite.parentContainer) {
                                    startAngle = this.globalAngle(sprite.parentContainer);
                                }
                            }
                            globalStartAngle += startAngle;
                            globalEndAngle += endAngle;
                        }
                        const len = args.objects.length;
                        globalStartAngle /= len;
                        globalEndAngle /= len;
                        const angle = this._start ? globalStartAngle : globalEndAngle;
                        const point = this.getAvgScreenPointOfObjects(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(100, 0);
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 4;
                        ctx.stroke();
                        ctx.strokeStyle = args.canEdit ? sceneobjects.RotateToolItem.COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    }
                    containsPoint(args) {
                        return false;
                    }
                    onStartDrag(args) {
                        // nothing
                    }
                    onDrag(args) {
                        // nothing
                    }
                    onStopDrag(args) {
                        // nothing
                    }
                }
                sceneobjects.RotateLineToolItem = RotateLineToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/tools/SceneToolOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.RotateToolItem.getInitialAngle(obj);
                    }
                    getFinalValue(obj) {
                        return obj.angle;
                    }
                    setValue(obj, value) {
                        obj.angle = value;
                    }
                }
                sceneobjects.RotateOperation = RotateOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseObjectTool.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateTool extends sceneobjects.BaseObjectTool {
                    constructor() {
                        super({
                            id: RotateTool.ID,
                            command: ui.editor.commands.CMD_ROTATE_SCENE_OBJECT,
                        }, sceneobjects.TransformComponent.angle);
                        this.addItems(new sceneobjects.RotateLineToolItem(true), new sceneobjects.RotateLineToolItem(false), new ui.editor.tools.CenterPointToolItem(sceneobjects.RotateToolItem.COLOR), new sceneobjects.RotateToolItem());
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        this.confirmUnlockProperty(args, [sceneobjects.TransformComponent.angle], "angle", sceneobjects.TransformSection.SECTION_ID);
                    }
                }
                RotateTool.ID = "phasereditor2d.scene.ui.sceneobjects.RotateTool";
                sceneobjects.RotateTool = RotateTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateToolItem extends ui.editor.tools.SceneToolItem {
                    constructor() {
                        super();
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args);
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 100, 0, Math.PI * 2);
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = "#000";
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = args.canEdit ? RotateToolItem.COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                        ctx.stroke();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return Math.abs(d - 100) < 10;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._initCursorPos = { x: args.x, y: args.y };
                        for (const obj of args.objects) {
                            obj.setData("AngleToolItem.initAngle", obj.angle);
                        }
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        const dx = this._initCursorPos.x - args.x;
                        const dy = this._initCursorPos.y - args.y;
                        if (Math.abs(dx) < 1 || Math.abs(dy) < 1) {
                            return;
                        }
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const deltaRadians = angleBetweenTwoPointsWithFixedPoint(args.x, args.y, this._initCursorPos.x, this._initCursorPos.y, point.x, point.y);
                            const initAngle = sprite.getData("AngleToolItem.initAngle");
                            const deltaAngle = Phaser.Math.RadToDeg(deltaRadians);
                            sprite.angle = Math.round(initAngle + deltaAngle);
                        }
                        args.editor.updateInspectorViewSection(sceneobjects.TransformSection.SECTION_ID);
                    }
                    static getInitialAngle(obj) {
                        return obj.getData("AngleToolItem.initAngle");
                    }
                    onStopDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        args.editor.getUndoManager().add(new sceneobjects.RotateOperation(args));
                        this._initCursorPos = null;
                    }
                }
                RotateToolItem.COLOR = "#aaf";
                sceneobjects.RotateToolItem = RotateToolItem;
                function angleBetweenTwoPointsWithFixedPoint(point1X, point1Y, point2X, point2Y, fixedX, fixedY) {
                    const angle1 = Math.atan2(point1Y - fixedY, point1X - fixedX);
                    const angle2 = Math.atan2(point2Y - fixedY, point2X - fixedX);
                    return angle1 - angle2;
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScaleOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.ScaleToolItem.getInitialScale(obj);
                    }
                    getFinalValue(obj) {
                        const sprite = obj;
                        return { x: sprite.scaleX, y: sprite.scaleY };
                    }
                    setValue(obj, value) {
                        const sprite = obj;
                        sprite.setScale(value.x, value.y);
                    }
                }
                sceneobjects.ScaleOperation = ScaleOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseObjectTool.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScaleTool extends sceneobjects.BaseObjectTool {
                    constructor() {
                        super({
                            id: ScaleTool.ID,
                            command: ui.editor.commands.CMD_SCALE_SCENE_OBJECT,
                        }, sceneobjects.TransformComponent.scaleX, sceneobjects.TransformComponent.scaleY);
                        this.addItems(new sceneobjects.ScaleToolItem(1, 0.5), new sceneobjects.ScaleToolItem(1, 1), new sceneobjects.ScaleToolItem(0.5, 1));
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        this.confirmUnlockProperty(args, [sceneobjects.TransformComponent.scale.x, sceneobjects.TransformComponent.scale.y], "scale", sceneobjects.TransformSection.SECTION_ID);
                    }
                }
                ScaleTool.ID = "phasereditor2d.scene.ui.sceneobjects.ScaleTool";
                sceneobjects.ScaleTool = ScaleTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScaleToolItem extends ui.editor.tools.SceneToolItem {
                    constructor(x, y) {
                        super();
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => {
                            const originX = sprite.getEditorSupport().computeOrigin().originX;
                            return this._x - originX;
                        }, (sprite) => {
                            const originY = sprite.getEditorSupport().computeOrigin().originY;
                            return this._y - originY;
                        });
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        const angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ? "#0ff" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            const { width, height } = sprite.getEditorSupport().computeSize();
                            sprite.setData("ScaleToolItem", {
                                initScaleX: sprite.scaleX,
                                initScaleY: sprite.scaleY,
                                initWidth: width,
                                initHeight: height,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    static getInitialScale(obj) {
                        const data = obj.getData("ScaleToolItem");
                        return { x: data.initScaleX, y: data.initScaleY };
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get("ScaleToolItem");
                            const initLocalPos = data.initLocalPos;
                            const localPos = new Phaser.Math.Vector2();
                            const worldTx = data.initWorldTx;
                            worldTx.applyInverse(args.x, args.y, localPos);
                            let flipX = sprite.flipX ? -1 : 1;
                            let flipY = sprite.flipY ? -1 : 1;
                            if (sprite instanceof Phaser.GameObjects.TileSprite) {
                                flipX = 1;
                                flipY = 1;
                            }
                            const dx = (localPos.x - initLocalPos.x) * flipX / args.camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / args.camera.zoom;
                            const { displayOriginX, displayOriginY } = sprite.getEditorSupport()
                                .computeDisplayOrigin();
                            let width = data.initWidth - displayOriginX;
                            let height = data.initHeight - displayOriginY;
                            if (width === 0) {
                                width = data.initWidth;
                            }
                            if (height === 0) {
                                height = data.initHeight;
                            }
                            const scaleDX = dx / width * data.initScaleX;
                            const scaleDY = dy / height * data.initScaleY;
                            const newScaleX = data.initScaleX + scaleDX;
                            const newScaleY = data.initScaleY + scaleDY;
                            const changeAll = this._x === 1 && this._y === 1;
                            const changeX = this._x === 1 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 1 || changeAll;
                            if (args.event.shiftKey) {
                                if (changeX && changeY) {
                                    const scale = Math.max(newScaleX, newScaleY);
                                    sprite.setScale(scale);
                                }
                                else {
                                    sprite.setScale(changeX ? newScaleX : newScaleY);
                                }
                            }
                            else {
                                if (changeX) {
                                    sprite.scaleX = newScaleX;
                                }
                                if (changeY) {
                                    sprite.scaleY = newScaleY;
                                }
                            }
                            args.editor.updateInspectorViewSection(sceneobjects.TransformSection.SECTION_ID);
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(new sceneobjects.ScaleOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.ScaleToolItem = ScaleToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_44) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SelectionRegionTool extends ui.editor.tools.SceneTool {
                    constructor() {
                        super({
                            command: ui.editor.commands.CMD_SELECT_REGION,
                            id: SelectionRegionTool.ID
                        });
                    }
                    onStartDrag(args) {
                        this._cursorStartPoint = new Phaser.Math.Vector2(args.x, args.y);
                        if (!args.event.ctrlKey) {
                            args.editor.setSelection([]);
                        }
                    }
                    onDrag(args) {
                        if (this._cursorStartPoint) {
                            this._cursorCurrentPoint = new Phaser.Math.Vector2(args.x, args.y);
                            args.editor.getOverlayLayer().render();
                        }
                    }
                    onStopDrag(args) {
                        if (this._cursorStartPoint && this._cursorCurrentPoint) {
                            const result = this.getRegionResult(args.editor);
                            const newSel = result
                                .filter(item => item.points.length === item.points.filter(p => p.contains).length)
                                .map(item => item.obj);
                            this._cursorStartPoint = null;
                            this._cursorCurrentPoint = null;
                            if (args.event.ctrlKey) {
                                const sel = [...args.editor.getSelection()];
                                for (const obj of newSel) {
                                    if (sel.indexOf(obj) < 0) {
                                        sel.push(obj);
                                    }
                                }
                                args.editor.setSelection(sel);
                            }
                            else {
                                args.editor.setSelection(newSel);
                            }
                        }
                        else {
                            args.editor.repaint();
                        }
                    }
                    canEdit(obj) {
                        return false;
                    }
                    canRender(obj) {
                        return false;
                    }
                    isObjectTool() {
                        return false;
                    }
                    getRegionResult(editor) {
                        const scene = editor.getScene();
                        const start = this._cursorStartPoint;
                        const end = this._cursorCurrentPoint;
                        const result = [];
                        // TODO: don't enter in prefab objects
                        scene.visitAllAskChildren(obj => {
                            if (sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TransformComponent)) {
                                const points = obj.getEditorSupport().getScreenBounds(scene.getCamera());
                                const x1 = Math.min(start.x, end.x);
                                const x2 = Math.max(start.x, end.x);
                                const y1 = Math.min(start.y, end.y);
                                const y2 = Math.max(start.y, end.y);
                                const pointsData = points.map(point => {
                                    if (point.x >= x1 && point.x <= x2 && point.y >= y1 && point.y <= y2) {
                                        return {
                                            point,
                                            contains: true
                                        };
                                    }
                                    else {
                                        return {
                                            point,
                                            contains: false
                                        };
                                    }
                                });
                                result.push({
                                    obj,
                                    points: pointsData
                                });
                            }
                            if (obj.getEditorSupport().isPrefabInstance()) {
                                return false;
                            }
                            if (obj instanceof sceneobjects.Container) {
                                if (!obj.getEditorSupport().isAllowPickChildren()) {
                                    return false;
                                }
                            }
                            return true;
                        });
                        return result;
                    }
                    render(args) {
                        if (!this._cursorStartPoint || !this._cursorCurrentPoint) {
                            return;
                        }
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 4;
                        ctx.strokeRect(this._cursorStartPoint.x, this._cursorStartPoint.y, this._cursorCurrentPoint.x - this._cursorStartPoint.x, this._cursorCurrentPoint.y - this._cursorStartPoint.y);
                        ctx.strokeStyle = "#00ff00";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this._cursorStartPoint.x, this._cursorStartPoint.y, this._cursorCurrentPoint.x - this._cursorStartPoint.x, this._cursorCurrentPoint.y - this._cursorStartPoint.y);
                        ctx.restore();
                        ctx.save();
                        const result = this.getRegionResult(args.editor);
                        for (const resultItem of result) {
                            if (resultItem.points.filter(p => p.contains).length > 0) {
                                for (const pointData of resultItem.points) {
                                    ctx.beginPath();
                                    ctx.arc(pointData.point.x, pointData.point.y, 2, 0, Math.PI * 2);
                                    ctx.fillStyle = pointData.contains ? "#0f0" : "#fff";
                                    ctx.fill();
                                    ctx.strokeStyle = "#000";
                                    ctx.stroke();
                                }
                            }
                        }
                        ctx.restore();
                    }
                }
                SelectionRegionTool.ID = "phasereditor2d.scene.ui.sceneobjects.SelectionRegionTool";
                sceneobjects.SelectionRegionTool = SelectionRegionTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_44.ui || (scene_44.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.SizeToolItem.getInitialSize(obj);
                    }
                    getFinalValue(obj) {
                        const [w, h] = obj.getEditorSupport().getSizeProperties();
                        return { x: w.getValue(obj), y: h.getValue(obj) };
                    }
                    setValue(obj, value) {
                        const [w, h] = obj.getEditorSupport().getSizeProperties();
                        w.setValue(obj, value.x);
                        h.setValue(obj, value.y);
                    }
                }
                sceneobjects.SizeOperation = SizeOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeTool extends sceneobjects.BaseObjectTool {
                    constructor() {
                        super({
                            id: SizeTool.ID,
                            command: ui.editor.commands.CMD_RESIZE_SCENE_OBJECT,
                        });
                        this.addItems(new sceneobjects.SizeToolItem(1, 0.5), new sceneobjects.SizeToolItem(1, 1), new sceneobjects.SizeToolItem(0.5, 1));
                    }
                    getProperties(obj) {
                        return obj.getEditorSupport().getSizeProperties();
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        const props = args.objects.flatMap(obj => obj.getEditorSupport().getSizeProperties());
                        const sections = args.objects.flatMap(obj => obj.getEditorSupport().getSizeSectionId());
                        this.confirmUnlockProperty(args, props, "size", ...sections);
                    }
                }
                SizeTool.ID = "phasereditor2d.scene.ui.sceneobjects.SizeTool";
                sceneobjects.SizeTool = SizeTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeToolItem extends ui.editor.tools.SceneToolItem {
                    constructor(x, y) {
                        super();
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => this._x - sprite.getEditorSupport().computeOrigin().originX, (sprite) => this._y - sprite.getEditorSupport().computeOrigin().originY);
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        const angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ? "#00f" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            sprite.setData("SizeTool", {
                                initWidth: sprite.width,
                                initHeight: sprite.height,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    static getInitialSize(obj) {
                        const data = obj.getData("SizeTool");
                        return { x: data.initWidth, y: data.initHeight };
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get("SizeTool");
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const flipX = sprite.flipX ? -1 : 1;
                            const flipY = sprite.flipY ? -1 : 1;
                            const { originX, originY } = sprite.getEditorSupport()
                                .computeOrigin();
                            const dx = (localPos.x - initLocalPos.x) * flipX / camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / camera.zoom;
                            const dw = dx / (1 - (originX === 1 ? 0 : originX));
                            const dh = dy / (1 - (originY === 1 ? 0 : originY));
                            const { x: width, y: height } = args.editor.getScene().snapPoint(data.initWidth + dw, data.initHeight + dh);
                            const changeAll = this._x === 1 && this._y === 1;
                            const changeX = this._x === 1 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 1 || changeAll;
                            const [widthProp, heightProp] = sprite.getEditorSupport().getSizeProperties();
                            if (changeX) {
                                widthProp.setValue(sprite, Math.floor(width));
                            }
                            if (changeY) {
                                heightProp.setValue(sprite, Math.floor(height));
                            }
                            args.editor.updateInspectorViewSection(obj.getEditorSupport().getSizeSectionId());
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(new sceneobjects.SizeOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.SizeToolItem = SizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/tools/SceneToolOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TranslateOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.TranslateToolItem.getInitObjectPosition(obj);
                    }
                    getFinalValue(obj) {
                        const sprite = obj;
                        return { x: sprite.x, y: sprite.y };
                    }
                    setValue(obj, value) {
                        const sprite = obj;
                        sprite.x = value.x;
                        sprite.y = value.y;
                    }
                }
                sceneobjects.TranslateOperation = TranslateOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TranslateTool extends sceneobjects.BaseObjectTool {
                    constructor() {
                        super({
                            id: TranslateTool.ID,
                            command: ui.editor.commands.CMD_TRANSLATE_SCENE_OBJECT,
                        }, sceneobjects.TransformComponent.x, sceneobjects.TransformComponent.y);
                        const x = new sceneobjects.TranslateToolItem("x");
                        const y = new sceneobjects.TranslateToolItem("y");
                        const xy = new sceneobjects.TranslateToolItem("xy");
                        this.addItems(new ui.editor.tools.LineToolItem("#f00", xy, x), new ui.editor.tools.LineToolItem("#0f0", xy, y), xy, x, y);
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        this.confirmUnlockProperty(args, [sceneobjects.TransformComponent.x, sceneobjects.TransformComponent.y], "position", sceneobjects.TransformSection.SECTION_ID);
                    }
                }
                TranslateTool.ID = "phasereditor2d.scene.ui.sceneobjects.TranslateTool";
                sceneobjects.TranslateTool = TranslateTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TranslateToolItem extends ui.editor.tools.SceneToolItem {
                    constructor(axis) {
                        super();
                        this._axis = axis;
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return d < 20;
                    }
                    onStartDrag(args) {
                        if (this.containsPoint(args)) {
                            this._initCursorPos = { x: args.x, y: args.y };
                            for (const obj of args.objects) {
                                const sprite = obj;
                                const worldPoint = new Phaser.Math.Vector2();
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                                sprite.setData("TranslateTool.localInitPosition", { x: sprite.x, y: sprite.y });
                                sprite.setData("TranslateTool.objInitWorldPosition", worldPoint);
                            }
                        }
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldDelta = this.getTranslationInAxisWorldDelta(this._axis, this._initCursorPos.x, this._initCursorPos.y, args);
                            const spriteWorldPosition1 = sprite.getData("TranslateTool.objInitWorldPosition");
                            const spriteWorldPosition2 = worldDelta.add(spriteWorldPosition1);
                            args.editor.getScene().snapVector(spriteWorldPosition2);
                            let spriteLocalPosition2 = new Phaser.Math.Vector2();
                            if (sprite.parentContainer) {
                                sprite.parentContainer.getWorldTransformMatrix()
                                    .applyInverse(spriteWorldPosition2.x, spriteWorldPosition2.y, spriteLocalPosition2);
                            }
                            else {
                                spriteLocalPosition2 = spriteWorldPosition2;
                            }
                            sprite.setPosition(Math.round(spriteLocalPosition2.x), Math.round(spriteLocalPosition2.y));
                        }
                        args.editor.updateInspectorViewSection(sceneobjects.TransformSection.SECTION_ID);
                    }
                    static getInitObjectPosition(obj) {
                        return obj.getData("TranslateTool.localInitPosition");
                    }
                    onStopDrag(args) {
                        if (this._initCursorPos) {
                            const editor = args.editor;
                            editor.getUndoManager().add(new sceneobjects.TranslateOperation(args));
                        }
                        this._initCursorPos = null;
                    }
                    getPoint(args) {
                        return this.getSimpleTranslationPoint(this._axis, args);
                    }
                    render(args) {
                        const { x, y } = this.getPoint(args);
                        this.renderSimpleAxis(this._axis, x, y, "#ff0", args);
                    }
                }
                sceneobjects.TranslateToolItem = TranslateToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ShapeBlockCellRenderer {
                    renderCell(args) {
                        const ctx = args.canvasContext;
                        ctx.save();
                        const selected = args.viewer.isSelected(args.obj);
                        const theme = controls.Controls.getTheme();
                        ctx.strokeStyle = selected ? theme.viewerSelectionForeground : theme.viewerForeground;
                        ctx.translate(0.5, 0.5);
                        this.renderShapeCell(ctx, args);
                        ctx.restore();
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                sceneobjects.ShapeBlockCellRenderer = ShapeBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ShapeComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            ShapeComponent.isFilled,
                            ShapeComponent.fillColor,
                            ShapeComponent.fillAlpha,
                            ShapeComponent.strokeColor,
                            ShapeComponent.strokeAlpha,
                            ShapeComponent.lineWidth,
                            ShapeComponent.isStroked
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ShapeComponent.isFilled);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, sceneobjects.NumberColorPropertyCodeDomAdapter(ShapeComponent.fillColor));
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ShapeComponent.fillAlpha);
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ShapeComponent.isStroked);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, sceneobjects.NumberColorPropertyCodeDomAdapter(ShapeComponent.strokeColor));
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ShapeComponent.strokeAlpha);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ShapeComponent.lineWidth);
                    }
                }
                ShapeComponent.fillColor = sceneobjects.NumberColorProperty("fillColor", "#fff", "Fill Color", "phaser:Phaser.GameObjects.Shape.fillColor");
                ShapeComponent.isFilled = sceneobjects.SimpleProperty("isFilled", false, "Is Filled", "phaser:Phaser.GameObjects.Shape.isFilled");
                ShapeComponent.fillAlpha = sceneobjects.SimpleProperty("fillAlpha", 1, "Fill Alpha", "phaser:Phaser.GameObjects.Shape.fillAlpha");
                ShapeComponent.isStroked = sceneobjects.SimpleProperty("isStroked", false, "Is Stroked", "phaser:Phaser.GameObjects.Shape.isStroked");
                ShapeComponent.strokeColor = sceneobjects.NumberColorProperty("strokeColor", "#fff", "Stroke Color", "phaser:Phaser.GameObjects.Shape.strokeColor");
                ShapeComponent.strokeAlpha = sceneobjects.SimpleProperty("strokeAlpha", 1, "Stroke Alpha", "phaser:Phaser.GameObjects.Shape.strokeAlpha");
                ShapeComponent.lineWidth = sceneobjects.SimpleProperty("lineWidth", 1, "Line Width", "phaser:Phaser.GameObjects.Shape.lineWidth");
                sceneobjects.ShapeComponent = ShapeComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_45) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ShapeEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    static isShape(obj) {
                        return sceneobjects.isGameObject(obj)
                            && obj.getEditorSupport() instanceof ShapeEditorSupport;
                    }
                    constructor(ext, obj, scene) {
                        super(ext, obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.ShapeComponent(obj));
                    }
                    getCellRenderer() {
                        return new sceneobjects.ObjectCellRenderer();
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_shape);
                    }
                    computeContentHash() {
                        const json = this.getObject().toJSON();
                        const hash = JSON.stringify(json);
                        return hash;
                    }
                }
                sceneobjects.ShapeEditorSupport = ShapeEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_45.ui || (scene_45.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ShapeSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ShapeSection", "Shape", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr auto";
                        this.createPropertyBoolean(comp, sceneobjects.ShapeComponent.isFilled)
                            .checkElement.style.gridColumn = "3 / span 2";
                        this.createPropertyColorRow(comp, sceneobjects.ShapeComponent.fillColor, false)
                            .element.style.gridColumn = "3 / span 2";
                        this.createPropertyFloatRow(comp, sceneobjects.ShapeComponent.fillAlpha)
                            .style.gridColumn = "3 / span 2";
                        this.createPropertyBoolean(comp, sceneobjects.ShapeComponent.isStroked)
                            .checkElement.style.gridColumn = "3 / span 2";
                        this.createPropertyColorRow(comp, sceneobjects.ShapeComponent.strokeColor, false)
                            .element.style.gridColumn = "3 / span 2";
                        this.createPropertyFloatRow(comp, sceneobjects.ShapeComponent.strokeAlpha)
                            .style.gridColumn = "3 / span 2";
                        this.createPropertyFloatRow(comp, sceneobjects.ShapeComponent.lineWidth)
                            .style.gridColumn = "3 / span 2";
                    }
                    canEdit(obj, n) {
                        return sceneobjects.ShapeEditorSupport.isShape(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ShapeSection = ShapeSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_46) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Ellipse extends Phaser.GameObjects.Ellipse {
                    constructor(scene, x, y) {
                        super(scene, x, y);
                        this._editorSupport = new sceneobjects.EllipseEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    setSize(width, height) {
                        const self = this;
                        const geom = this.geom;
                        geom.setPosition(width / 2, height / 2);
                        geom.setSize(width, height);
                        this.width = width;
                        this.height = height;
                        this.updateDisplayOrigin();
                        self.updateData();
                        return this;
                    }
                }
                sceneobjects.Ellipse = Ellipse;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_46.ui || (scene_46.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new EllipseBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + args.w / 2);
                        const y = Math.floor(args.y + args.h / 2);
                        const r = Math.floor(size / 2);
                        ctx.beginPath();
                        ctx.ellipse(x, y, r, r, 0, 0, 360);
                        ctx.stroke();
                    }
                }
                sceneobjects.EllipseBlockCellRenderer = EllipseBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class EllipseCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("ellipse");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        args.methodCallDOM.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        this.buildCreatePrefabInstanceCodeDOM_Size_Arguments(args);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_SizeParameters(args);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("ellipse", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        return call;
                    }
                }
                sceneobjects.EllipseCodeDOMBuilder = EllipseCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            EllipseComponent.smoothness
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, EllipseComponent.smoothness);
                    }
                }
                EllipseComponent.smoothness = sceneobjects.SimpleProperty("smoothness", 64, "Smoothness", "phaser:Phaser.GameObjects.Ellipse.smoothness");
                sceneobjects.EllipseComponent = EllipseComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_47) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.EllipseExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SizeComponent(obj), new sceneobjects.EllipseComponent(obj));
                    }
                }
                sceneobjects.EllipseEditorSupport = EllipseEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_47.ui || (scene_47.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            icon: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Ellipse",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                            typeName: "Ellipse"
                        });
                    }
                    static getInstance() {
                        return this._instance ?? (this._instance = new EllipseExtension());
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.EllipseBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Ellipse(args.scene, 0, 0);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Ellipse(args.scene, args.x, args.y);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.EllipseCodeDOMBuilder();
                    }
                }
                sceneobjects.EllipseExtension = EllipseExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.EllipseSection", "Ellipse", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createNumberProperty(comp, sceneobjects.EllipseComponent.smoothness);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Ellipse;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.EllipseSection = EllipseSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_48) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Rectangle extends Phaser.GameObjects.Rectangle {
                    constructor(scene, x, y) {
                        super(scene, x, y);
                        this._editorSupport = new sceneobjects.RectangleEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    setSize(width, height) {
                        super.setSize(width, height);
                        const geom = this.geom;
                        geom.setSize(width, height);
                        this.updateDisplayOrigin();
                        const self = this;
                        self.updateData();
                        return this;
                    }
                }
                sceneobjects.Rectangle = Rectangle;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_48.ui || (scene_48.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new RectangleBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + (args.w - size) / 2);
                        const y = Math.floor(args.y + (args.h - size) / 2);
                        ctx.beginPath();
                        ctx.rect(x, y, size, size);
                        ctx.stroke();
                    }
                }
                sceneobjects.RectangleBlockCellRenderer = RectangleBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class RectangleCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("rectangle");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        this.buildCreatePrefabInstanceCodeDOM_Size_Arguments(args);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_SizeParameters(args);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("rectangle", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        return call;
                    }
                }
                sceneobjects.RectangleCodeDOMBuilder = RectangleCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_49) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.RectangleExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SizeComponent(obj));
                    }
                }
                sceneobjects.RectangleEditorSupport = RectangleEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_49.ui || (scene_49.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            icon: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Rectangle",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                            typeName: "Rectangle"
                        });
                    }
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new RectangleExtension());
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.RectangleBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Rectangle(args.scene, 0, 0);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Rectangle(args.scene, args.x, args.y);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.RectangleCodeDOMBuilder();
                    }
                }
                sceneobjects.RectangleExtension = RectangleExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_50) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Triangle extends Phaser.GameObjects.Triangle {
                    constructor(scene, x, y) {
                        super(scene, x, y);
                        this._editorSupport = new sceneobjects.TriangleEditorSupport(scene, this);
                        this._triangle = this.geom;
                    }
                    getTriangleGeom() {
                        return this._triangle;
                    }
                    get x1() {
                        return this.getTriangleGeom().x1;
                    }
                    set x1(val) {
                        this.setTo(val, this.y1, this.x2, this.y2, this.x3, this.y3);
                    }
                    get x2() {
                        return this.getTriangleGeom().x2;
                    }
                    set x2(val) {
                        this.setTo(this.x1, this.y1, val, this.y2, this.x3, this.y3);
                    }
                    get x3() {
                        return this.getTriangleGeom().x3;
                    }
                    set x3(val) {
                        this.setTo(this.x1, this.y1, this.x2, this.y2, val, this.y3);
                    }
                    get y1() {
                        return this.getTriangleGeom().y1;
                    }
                    set y1(val) {
                        this.setTo(this.x1, val, this.x2, this.y2, this.x3, this.y3);
                    }
                    get y2() {
                        return this.getTriangleGeom().y2;
                    }
                    set y2(val) {
                        this.setTo(this.x1, this.y1, this.x2, val, this.x3, this.y3);
                    }
                    get y3() {
                        return this.getTriangleGeom().y3;
                    }
                    set y3(val) {
                        this.setTo(this.x1, this.y1, this.x2, this.y2, this.x3, val);
                    }
                    setTo(x1, y1, x2, y2, x3, y3) {
                        super.setTo(x1, y1, x2, y2, x3, y3);
                        const geom = this.getTriangleGeom();
                        const width = geom.right - geom.left;
                        const height = geom.bottom - geom.top;
                        this["setSize"](width, height);
                        this.updateDisplayOrigin();
                        return this;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Triangle = Triangle;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_50.ui || (scene_50.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new TriangleBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + args.w / 2);
                        const y = Math.floor(args.y + args.h / 2);
                        const r = Math.floor(size / 2);
                        ctx.beginPath();
                        ctx.moveTo(x - r, y + r);
                        ctx.lineTo(x, y - r);
                        ctx.lineTo(x + r, y + r);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                sceneobjects.TriangleBlockCellRenderer = TriangleBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TriangleCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("triangle");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        for (const p of [sceneobjects.TriangleComponent.p1, sceneobjects.TriangleComponent.p2, sceneobjects.TriangleComponent.p3]) {
                            if (support.isUnlockedPropertyXY(p)) {
                                call.argFloat(p.x.getValue(obj));
                                call.argFloat(p.y.getValue(obj));
                            }
                            else {
                                call.arg("undefined");
                                call.arg("undefined");
                            }
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("x1", "number", true);
                        ctr.arg("y1", "number", true);
                        ctr.arg("x2", "number", true);
                        ctr.arg("y2", "number", true);
                        ctr.arg("x3", "number", true);
                        ctr.arg("y3", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        for (const p of [sceneobjects.TriangleComponent.p1, sceneobjects.TriangleComponent.p2, sceneobjects.TriangleComponent.p3]) {
                            if (support.isUnlockedPropertyXY(p)) {
                                call.arg(`${p.x.name} ?? ${p.x.getValue(obj)}`);
                                call.arg(`${p.y.name} ?? ${p.y.getValue(obj)}`);
                            }
                            else {
                                call.arg("undefined");
                                call.arg("undefined");
                            }
                        }
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("triangle", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.x1);
                        call.argFloat(obj.y1);
                        call.argFloat(obj.x2);
                        call.argFloat(obj.y2);
                        call.argFloat(obj.x3);
                        call.argFloat(obj.y3);
                        return call;
                    }
                }
                sceneobjects.TriangleCodeDOMBuilder = TriangleCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [TriangleComponent.x1,
                            TriangleComponent.y1,
                            TriangleComponent.x2,
                            TriangleComponent.y2,
                            TriangleComponent.x3,
                            TriangleComponent.y3]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        if (support.isNestedPrefabInstance() &&
                            (support.isUnlockedPropertyXY(TriangleComponent.p1)
                                || support.isUnlockedPropertyXY(TriangleComponent.p2)
                                || support.isUnlockedPropertyXY(TriangleComponent.p3))) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setTo", args.objectVarName);
                            dom.argFloat(obj.x1);
                            dom.argFloat(obj.y1);
                            dom.argFloat(obj.x2);
                            dom.argFloat(obj.y2);
                            dom.argFloat(obj.x3);
                            dom.argFloat(obj.y3);
                            args.statements.push(dom);
                        }
                    }
                }
                TriangleComponent.x1 = sceneobjects.SimpleProperty("x1", 0, "X", "phaser:Phaser.Geom.Triangle.x1");
                TriangleComponent.y1 = sceneobjects.SimpleProperty("y1", 128, "Y", "phaser:Phaser.Geom.Triangle.y1");
                TriangleComponent.x2 = sceneobjects.SimpleProperty("x2", 64, "X", "phaser:Phaser.Geom.Triangle.x2");
                TriangleComponent.y2 = sceneobjects.SimpleProperty("y2", 0, "Y", "phaser:Phaser.Geom.Triangle.y2");
                TriangleComponent.x3 = sceneobjects.SimpleProperty("x3", 128, "X", "phaser:Phaser.Geom.Triangle.x3");
                TriangleComponent.y3 = sceneobjects.SimpleProperty("y3", 128, "Y", "phaser:Phaser.Geom.Triangle.y3");
                TriangleComponent.p1 = {
                    label: "Point 1",
                    x: TriangleComponent.x1,
                    y: TriangleComponent.y1
                };
                TriangleComponent.p2 = {
                    label: "Point 2",
                    x: TriangleComponent.x2,
                    y: TriangleComponent.y2
                };
                TriangleComponent.p3 = {
                    label: "Point 3",
                    x: TriangleComponent.x3,
                    y: TriangleComponent.y3
                };
                sceneobjects.TriangleComponent = TriangleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_51) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.TriangleExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TriangleComponent(obj));
                    }
                }
                sceneobjects.TriangleEditorSupport = TriangleEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_51.ui || (scene_51.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            icon: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Triangle",
                            typeName: "Triangle",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                        });
                    }
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new TriangleExtension());
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.TriangleBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Triangle(args.scene, 0, 0);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Triangle(args.scene, args.x, args.y);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TriangleCodeDOMBuilder();
                    }
                }
                sceneobjects.TriangleExtension = TriangleExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TriangleSection", "Triangle", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.TriangleComponent.p1);
                        this.createPropertyXYRow(comp, sceneobjects.TriangleComponent.p2);
                        this.createPropertyXYRow(comp, sceneobjects.TriangleComponent.p3);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Triangle;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TriangleSection = TriangleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_52) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Sprite extends Phaser.GameObjects.Image {
                    constructor(scene, x, y, texture, frame) {
                        super(scene, x, y, texture, frame);
                        this._editorSupport = new sceneobjects.SpriteEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Sprite = Sprite;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_52.ui || (scene_52.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../image/BaseImageEditorSupport.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_53) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpriteEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.SpriteExtension.getInstance(), obj, scene);
                    }
                }
                sceneobjects.SpriteEditorSupport = SpriteEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_53.ui || (scene_53.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_54) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpriteExtension extends sceneobjects.BaseImageExtension {
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.Sprite",
                            typeName: "Sprite",
                            category: scene_54.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: scene_54.ScenePlugin.getInstance().getIconDescriptor(scene_54.ICON_SPRITE_TYPE)
                        });
                    }
                    static getInstance() {
                        return this._instance;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.BaseImageCodeDOMBuilder("sprite");
                    }
                    newObject(scene, x, y, key, frame) {
                        return new sceneobjects.Sprite(scene, x, y, key || null, frame);
                    }
                }
                SpriteExtension._instance = new SpriteExtension();
                sceneobjects.SpriteExtension = SpriteExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_54.ui || (scene_54.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_55) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Text extends Phaser.GameObjects.Text {
                    constructor(scene, x, y, text, style) {
                        super(scene, x, y, text, style);
                        this._editorSupport = new sceneobjects.TextEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Text = Text;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_55.ui || (scene_55.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TextCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("text", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argLiteral("");
                        call.arg("{}");
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        const call = args.superMethodCallCodeDOM;
                        if (!args.prefabObj.getEditorSupport().isPrefabInstance()) {
                            call.argLiteral("");
                            call.arg("{}");
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                    }
                }
                sceneobjects.TextCodeDOMBuilder = TextCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TextComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            TextComponent.fixedWidth,
                            TextComponent.fixedHeight,
                            TextComponent.paddingLeft,
                            TextComponent.paddingTop,
                            TextComponent.paddingRight,
                            TextComponent.paddingBottom,
                            TextComponent.lineSpacing,
                            TextComponent.align,
                            TextComponent.fontFamily,
                            TextComponent.fontSize,
                            TextComponent.fontStyle,
                            TextComponent.color,
                            TextComponent.stroke,
                            TextComponent.strokeThickness,
                            TextComponent.backgroundColor,
                            TextComponent.shadowOffsetX,
                            TextComponent.shadowOffsetY,
                            TextComponent.shadowStroke,
                            TextComponent.shadowFill,
                            TextComponent.shadowColor,
                            TextComponent.shadowBlur,
                            TextComponent.baselineX,
                            TextComponent.baselineY,
                            TextComponent.maxLines,
                            TextComponent.wordWrapWidth,
                            TextComponent.useAdvancedWrap
                        ]);
                    }
                    styleToJson() {
                        const comp = TextComponent;
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const data = {};
                        const simpleProps = [
                            comp.align,
                            comp.backgroundColor,
                            comp.baselineX,
                            comp.baselineY,
                            comp.color,
                            comp.fixedWidth,
                            comp.fixedHeight,
                            comp.fontFamily,
                            comp.fontSize,
                            comp.fontStyle,
                            comp.maxLines,
                            comp.stroke,
                            comp.strokeThickness,
                            comp.shadowOffsetX,
                            comp.shadowOffsetY,
                            comp.shadowColor,
                            comp.shadowBlur,
                            comp.shadowStroke,
                            comp.shadowFill
                        ];
                        if (support.isPrefabInstance()) {
                            for (const prop of simpleProps) {
                                if (support.isUnlockedProperty(prop)) {
                                    data[prop.name] = prop.getValue(obj);
                                }
                            }
                        }
                        else {
                            for (const prop of simpleProps) {
                                const value = prop.getValue(obj);
                                if (value !== prop.defValue) {
                                    data[prop.name] = value;
                                }
                            }
                        }
                        return data;
                    }
                    stringify(style) {
                        let s = JSON.stringify(style);
                        s = s.replaceAll("\":\"", "\": \"")
                            .replaceAll("{\"", "{ \"")
                            .replaceAll("\"}", "\" }")
                            .replaceAll("\",", "\", ");
                        return s;
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        {
                            // style
                            const style = this.styleToJson();
                            const literal = this.stringify(style);
                            if (literal !== "{}") {
                                const dom = new code.MethodCallCodeDOM("setStyle", args.objectVarName);
                                dom.arg(literal);
                                args.statements.push(dom);
                            }
                        }
                        {
                            // padding
                            const comp = TextComponent;
                            const padding = {};
                            const map = {
                                left: comp.paddingLeft,
                                top: comp.paddingTop,
                                right: comp.paddingRight,
                                bottom: comp.paddingBottom
                            };
                            if (support.isPrefabInstance()) {
                                // tslint:disable-next-line:forin
                                for (const key in map) {
                                    const prop = map[key];
                                    if (support.isUnlockedProperty(prop)) {
                                        padding[key] = prop.getValue(obj);
                                    }
                                }
                            }
                            else {
                                // tslint:disable-next-line:forin
                                for (const key in map) {
                                    const prop = map[key];
                                    const value = prop.getValue(obj);
                                    if (value !== prop.defValue) {
                                        padding[key] = value;
                                    }
                                }
                            }
                            const literal = JSON.stringify(padding);
                            if (literal !== "{}") {
                                const dom = new code.MethodCallCodeDOM("setPadding", args.objectVarName);
                                dom.arg(literal);
                                args.statements.push(dom);
                            }
                        }
                        {
                            // lineSpacing
                            this.buildSetObjectPropertyCodeDOM([TextComponent.lineSpacing], args2 => {
                                const dom = new code.MethodCallCodeDOM("setLineSpacing", args.objectVarName);
                                dom.arg(args2.value);
                                args.statements.push(dom);
                            });
                        }
                        {
                            // wordWrapWidth
                            const widthProp = TextComponent.wordWrapWidth;
                            const advancedProp = TextComponent.useAdvancedWrap;
                            const widthValue = widthProp.getValue(obj);
                            const advancedValue = advancedProp.getValue(obj);
                            const dom = new code.MethodCallCodeDOM("setWordWrapWidth", args.objectVarName);
                            let addDom = false;
                            if (support.isUnlockedProperty(widthProp) && widthValue !== 0) {
                                addDom = true;
                                dom.arg(widthValue);
                            }
                            else {
                                dom.arg(args.objectVarName + ".style.wordWrapWidth");
                            }
                            if (support.isUnlockedProperty(advancedProp) && advancedValue) {
                                addDom = true;
                                dom.arg(advancedValue);
                            }
                            if (addDom) {
                                args.statements.push(dom);
                            }
                        }
                    }
                }
                TextComponent.fixedWidth = {
                    name: "fixedWidth",
                    label: "Width",
                    tooltip: "phaser:Phaser.Types.GameObjects.Text.TextStyle.fixedWidth",
                    defValue: 0,
                    getValue: obj => obj.style.fixedWidth,
                    setValue: (obj, value) => obj.setFixedSize(value, obj.style.fixedHeight)
                };
                TextComponent.fixedHeight = {
                    name: "fixedHeight",
                    label: "Height",
                    tooltip: "phaser:Phaser.Types.GameObjects.Text.TextStyle.fixedHeight",
                    defValue: 0,
                    getValue: obj => obj.style.fixedHeight,
                    setValue: (obj, value) => obj.setFixedSize(obj.style.fixedWidth, value)
                };
                TextComponent.fixedSize = {
                    label: "Fixed Size",
                    tooltip: "phaser:Phaser.GameObjects.TextStyle.setFixedSize",
                    x: TextComponent.fixedWidth,
                    y: TextComponent.fixedHeight
                };
                TextComponent.paddingLeft = {
                    name: "paddingLeft",
                    label: "Padding Left",
                    tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.left",
                    defValue: 0,
                    getValue: obj => obj.padding["left"],
                    setValue: (obj, value) => { obj.padding["left"] = value; obj.updateText(); }
                };
                TextComponent.paddingTop = {
                    name: "paddingTop",
                    label: "Padding Top",
                    tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.top",
                    defValue: 0,
                    getValue: obj => obj.padding["top"],
                    setValue: (obj, value) => { obj.padding["top"] = value; obj.updateText(); }
                };
                TextComponent.paddingRight = {
                    name: "paddingRight",
                    label: "Padding Right",
                    tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.right",
                    defValue: 0,
                    getValue: obj => obj.padding["right"],
                    setValue: (obj, value) => { obj.padding["right"] = value; obj.updateText(); }
                };
                TextComponent.paddingBottom = {
                    name: "paddingBottom",
                    label: "Padding Bottom",
                    tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.bottom",
                    defValue: 0,
                    getValue: obj => obj.padding["bottom"],
                    setValue: (obj, value) => { obj.padding["bottom"] = value; obj.updateText(); }
                };
                TextComponent.lineSpacing = {
                    name: "lineSpacing",
                    label: "Line Spacing",
                    tooltip: "phaser:Phaser.GameObjects.Text.lineSpacing",
                    defValue: 0,
                    getValue: obj => obj.lineSpacing,
                    setValue: (obj, value) => obj.setLineSpacing(value)
                };
                TextComponent.align = {
                    name: "align",
                    label: "Align",
                    tooltip: "phaser:Phaser.GameObjects.Text.setAlign",
                    defValue: "left",
                    getValue: obj => obj.style.align,
                    setValue: (obj, value) => obj.setAlign(value),
                    values: ["left", "right", "center", "justify"],
                    getValueLabel: value => value.toUpperCase()
                };
                TextComponent.fontFamily = {
                    name: "fontFamily",
                    label: "Font Family",
                    tooltip: "phaser:Phaser.GameObjects.Text.setFontFamily",
                    defValue: "Courier",
                    getValue: obj => obj.style.fontFamily,
                    setValue: (obj, value) => obj.setFontFamily(value)
                };
                TextComponent.fontSize = {
                    name: "fontSize",
                    label: "Font Size",
                    tooltip: "phaser:Phaser.GameObjects.Text.setFontSize",
                    defValue: "16px",
                    getValue: obj => obj.style.fontSize,
                    setValue: (obj, value) => obj.setFontSize(value)
                };
                TextComponent.fontStyle = {
                    name: "fontStyle",
                    label: "Font Style",
                    tooltip: "phaser:Phaser.GameObjects.Text.setFontStyle",
                    defValue: "",
                    getValue: obj => obj.style.fontStyle,
                    setValue: (obj, value) => obj.setFontStyle(value),
                    values: ["", "italic", "bold", "bold italic"],
                    getValueLabel: value => value === "" ? "(Default)" : value.toUpperCase()
                };
                TextComponent.color = {
                    name: "color",
                    label: "Color",
                    tooltip: "phaser:Phaser.GameObjects.Text.setColor",
                    defValue: "#fff",
                    getValue: obj => obj.style.color,
                    setValue: (obj, value) => obj.setColor(value)
                };
                TextComponent.stroke = {
                    name: "stroke",
                    label: "Stroke",
                    tooltip: "phaser:Phaser.GameObjects.Text.setStroke(color)",
                    defValue: "#fff",
                    getValue: obj => obj.style.stroke,
                    setValue: (obj, value) => obj.setStroke(value, obj.style.strokeThickness)
                };
                TextComponent.strokeThickness = {
                    name: "strokeThickness",
                    label: "Stroke Thickness",
                    tooltip: "phaser:Phaser.GameObjects.Text.setStroke(thickness)",
                    defValue: 0,
                    getValue: obj => obj.style.strokeThickness,
                    setValue: (obj, value) => obj.setStroke(obj.style.stroke, value)
                };
                TextComponent.backgroundColor = {
                    name: "backgroundColor",
                    label: "Background Color",
                    tooltip: "phaser:Phaser.GameObjects.Text.setBackgroundColor",
                    defValue: null,
                    getValue: obj => obj.style.backgroundColor,
                    setValue: (obj, value) => obj.setBackgroundColor(value)
                };
                TextComponent.shadowOffsetX = {
                    name: "shadow.offsetX",
                    label: "X",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowOffset(x)",
                    defValue: 0,
                    getValue: obj => obj.style.shadowOffsetX,
                    setValue: (obj, value) => obj.setShadowOffset(value, obj.style.shadowOffsetY)
                };
                TextComponent.shadowOffsetY = {
                    name: "shadow.offsetY",
                    label: "Y",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowOffset(y)",
                    defValue: 0,
                    getValue: obj => obj.style.shadowOffsetY,
                    setValue: (obj, value) => obj.setShadowOffset(obj.style.shadowOffsetX, value)
                };
                TextComponent.shadowOffset = {
                    label: "Shadow Offset",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowOffset",
                    x: TextComponent.shadowOffsetX,
                    y: TextComponent.shadowOffsetY
                };
                TextComponent.shadowStroke = {
                    name: "shadow.stroke",
                    label: "Stroke",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowStroke",
                    defValue: false,
                    getValue: obj => obj.style.shadowStroke,
                    setValue: (obj, value) => obj.setShadowStroke(value)
                };
                TextComponent.shadowFill = {
                    name: "shadow.fill",
                    label: "Fill",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowFill",
                    defValue: false,
                    getValue: obj => obj.style.shadowFill,
                    setValue: (obj, value) => obj.setShadowFill(value)
                };
                TextComponent.shadow = {
                    label: "Shadow",
                    tooltip: "Shadow stroke and fill.",
                    x: TextComponent.shadowStroke,
                    y: TextComponent.shadowFill
                };
                TextComponent.shadowColor = {
                    name: "shadow.color",
                    label: "Shadow Color",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowColor",
                    defValue: "#000",
                    getValue: obj => obj.style.shadowColor,
                    setValue: (obj, value) => obj.setShadowColor(value)
                };
                TextComponent.shadowBlur = {
                    name: "shadow.blur",
                    label: "Shadow Blur",
                    tooltip: "phaser:Phaser.GameObjects.Text.setShadowBlur",
                    defValue: 0,
                    getValue: obj => obj.style.shadowBlur,
                    setValue: (obj, value) => obj.setShadowBlur(value)
                };
                TextComponent.baselineX = {
                    name: "baselineX",
                    label: "X",
                    tooltip: "phaser:Phaser.GameObjects.TextStyle.baselineX",
                    defValue: 1.2,
                    getValue: obj => obj.style.baselineX,
                    setValue: (obj, value) => obj.style.baselineX = value
                };
                TextComponent.baselineY = {
                    name: "baselineY",
                    label: "Y",
                    tooltip: "phaser:Phaser.GameObjects.TextStyle.baselineY",
                    defValue: 1.4,
                    getValue: obj => obj.style.baselineY,
                    setValue: (obj, value) => obj.style.baselineY = value
                };
                TextComponent.baseline = {
                    label: "Baseline",
                    tooltip: "Baseline",
                    x: TextComponent.baselineX,
                    y: TextComponent.baselineY
                };
                TextComponent.maxLines = {
                    name: "maxLines",
                    label: "Max Lines",
                    tooltip: "phaser:Phaser.GameObjects.Text.setMaxLines",
                    defValue: 0,
                    getValue: obj => obj.style.maxLines,
                    setValue: (obj, value) => obj.setMaxLines(value)
                };
                TextComponent.wordWrapWidth = {
                    name: "wordWrapWidth",
                    label: "Word Wrap Width",
                    tooltip: "phaser:Phaser.GameObjects.Text.setWordWrapWidth(width)",
                    defValue: 0,
                    getValue: obj => obj.style.wordWrapWidth || 0,
                    setValue: (obj, value) => {
                        try {
                            obj.setWordWrapWidth(value, obj.style.wordWrapUseAdvanced === true);
                        }
                        catch (e) {
                            alert(e.message);
                        }
                    }
                };
                TextComponent.useAdvancedWrap = {
                    name: "wordWrapUseAdvanced",
                    label: "Advanced Wrap",
                    tooltip: "phaser:Phaser.GameObjects.Text.setWordWrapWidth(useAdvancedWrap)",
                    defValue: false,
                    getValue: obj => obj.style.wordWrapUseAdvanced || false,
                    setValue: (obj, value) => obj.setWordWrapWidth(obj.style.wordWrapWidth || 0, value)
                };
                sceneobjects.TextComponent = TextComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_56) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.TextExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.FlipComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaComponent(obj), new sceneobjects.TintComponent(obj), new sceneobjects.TextContentComponent(obj), new sceneobjects.TextComponent(obj));
                    }
                    computeContentHash() {
                        return this.computeContentHashWithComponent(this.getObject(), sceneobjects.FlipComponent, sceneobjects.TintComponent, sceneobjects.TextContentComponent, sceneobjects.TextComponent);
                    }
                    getCellRenderer() {
                        return new sceneobjects.ObjectCellRenderer();
                    }
                    setInteractive() {
                        this.getObject().setInteractive();
                    }
                    getPropertyDefaultValue(prop) {
                        if (prop === sceneobjects.OriginComponent.originX || prop === sceneobjects.OriginComponent.originY) {
                            return 0;
                        }
                        return super.getPropertyDefaultValue(prop);
                    }
                }
                sceneobjects.TextEditorSupport = TextEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_56.ui || (scene_56.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.Text",
                            typeName: "Text",
                            category: scene.SCENE_OBJECT_TEXT_CATEGORY,
                            icon: scene.ScenePlugin.getInstance().getIconDescriptor(scene.ICON_TEXT_TYPE)
                        });
                    }
                    static getInstance() {
                        return this._instance;
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        return null;
                    }
                    createDefaultSceneObject(args) {
                        const text = new sceneobjects.Text(args.scene, args.x, args.y, "New text", {});
                        return [text];
                    }
                    createGameObjectWithData(args) {
                        const text = new sceneobjects.Text(args.scene, 0, 0, "", {});
                        text.getEditorSupport().readJSON(args.data);
                        return text;
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TextCodeDOMBuilder();
                    }
                }
                TextExtension._instance = new TextExtension();
                sceneobjects.TextExtension = TextExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor.scene.ui.sceneobjects.TextSection", "Text");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/text-object.html#text-type-properties";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        // fontFamily
                        this.createPropertyStringRow(comp, sceneobjects.TextComponent.fontFamily).style.gridColumn = "3 / span 4";
                        // fontSize
                        this.createPropertyStringRow(comp, sceneobjects.TextComponent.fontSize).style.gridColumn = "3 / span 4";
                        // fontStyle
                        this.createPropertyEnumRow(comp, sceneobjects.TextComponent.fontStyle).style.gridColumn = "3 / span 4";
                        // align
                        this.createPropertyEnumRow(comp, sceneobjects.TextComponent.align).style.gridColumn = "3 / span 4";
                        // color
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.color).element.style.gridColumn = "3 / span 4";
                        // stroke
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.stroke).element.style.gridColumn = "3 / span 4";
                        // strokeThickness
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.strokeThickness).style.gridColumn = "3 / span 4";
                        // backgroundColor
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.backgroundColor).element.style.gridColumn = "3 / span 4";
                        // shadow
                        this.createPropertyBoolXYRow(comp, sceneobjects.TextComponent.shadow);
                        // shadowOffset
                        this.createPropertyXYRow(comp, sceneobjects.TextComponent.shadowOffset);
                        // shadowColor
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.shadowColor).element.style.gridColumn = "3 / span 4";
                        // shadowBlur
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.shadowBlur).style.gridColumn = "3 / span 4";
                        // fixedSize
                        this.createPropertyXYRow(comp, sceneobjects.TextComponent.fixedSize);
                        {
                            // padding
                            const comp2 = this.createGridElement(comp);
                            comp2.style.gridTemplateColumns = "1fr 1fr 1fr 1fr";
                            comp2.style.gridColumn = "3 / span 4";
                            comp2.style.paddingBottom = "0px";
                            comp.appendChild(comp2);
                            this.createLabel(comp2, "Left").style.justifySelf = "center";
                            this.createLabel(comp2, "Top").style.justifySelf = "center";
                            this.createLabel(comp2, "Right").style.justifySelf = "center";
                            this.createLabel(comp2, "Bottom").style.justifySelf = "center";
                            this.createLock(comp, sceneobjects.TextComponent.paddingLeft, sceneobjects.TextComponent.paddingTop, sceneobjects.TextComponent.paddingRight, sceneobjects.TextComponent.paddingBottom);
                            this.createLabel(comp, "Padding", scene.PhaserHelp("phaser:Phaser.GameObjects.Text.setPadding"));
                            const comp3 = this.createGridElement(comp);
                            comp3.style.gridTemplateColumns = "1fr 1fr 1fr 1fr";
                            comp3.style.gridColumn = "3 / span 4";
                            comp.appendChild(comp3);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingLeft);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingTop);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingRight);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingBottom);
                        }
                        // baseline
                        this.createPropertyXYRow(comp, sceneobjects.TextComponent.baseline);
                        // lineSpacing
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.lineSpacing).style.gridColumn = "3 / span 4";
                        // maxLines
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.maxLines).style.gridColumn = "3 / span 4";
                        // wordWrapWidth
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.wordWrapWidth).style.gridColumn = "3 / span 4";
                        // useAdvancedWrap
                        this.createPropertyBoolean(comp, sceneobjects.TextComponent.useAdvancedWrap)
                            .checkElement.style.gridColumn = "3 / span 4";
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Text;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TextSection = TextSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChangeTextureOperation extends sceneobjects.SceneGameObjectOperation {
                    static canChangeTextureOf(obj) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TextureComponent)
                            && (!obj.getEditorSupport().isPrefabInstance()
                                || obj.getEditorSupport().isUnlockedProperty(sceneobjects.TextureComponent.texture));
                    }
                    static async runDialog(editor, atlasKey) {
                        const cache = editor.getScene().getPackCache();
                        const lockedObjects = editor.getSelectedGameObjects().filter(obj => obj.getEditorSupport().isLockedProperty(sceneobjects.TextureComponent.texture));
                        if (lockedObjects.length > 0) {
                            const ok = await editor.confirmUnlockProperty([sceneobjects.TextureComponent.texture], "texture", sceneobjects.TextureSection.SECTION_ID);
                            if (!ok) {
                                return;
                            }
                        }
                        const objects = editor.getSelectedGameObjects().filter(obj => this.canChangeTextureOf(obj));
                        const objectKeys = objects
                            .map(obj => sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.TextureComponent))
                            .map(comp => comp.getTextureKeys());
                        const selectedFrames = objectKeys.map(k => cache.getImage(k.key, k.frame));
                        const callback = async (sel) => {
                            const frame = sel[0];
                            let newKeys;
                            const item = frame.getPackItem();
                            item.addToPhaserCache(editor.getGame(), cache);
                            if (item instanceof phasereditor2d.pack.core.ImageAssetPackItem) {
                                newKeys = { key: item.getKey() };
                            }
                            else {
                                newKeys = { key: item.getKey(), frame: frame.getName() };
                            }
                            editor
                                .getUndoManager().add(new ChangeTextureOperation(editor, objects, newKeys));
                        };
                        if (atlasKey) {
                            sceneobjects.TextureFrameSelectionDialog.createDialog(editor.getPackFinder(), selectedFrames, callback, atlasKey);
                        }
                        else {
                            sceneobjects.TextureSelectionDialog.createDialog(editor, selectedFrames, callback);
                        }
                    }
                    constructor(editor, objects, value) {
                        super(editor, objects, value);
                    }
                    getValue(obj) {
                        const comp = obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                        return comp.getTextureKeys();
                    }
                    setValue(obj, value) {
                        const finder = this.getEditor().getPackFinder();
                        const item = finder.findAssetPackItem(value.key);
                        if (item) {
                            item.addToPhaserCache(this.getEditor().getGame(), this.getScene().getPackCache());
                        }
                        const comp = obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                        comp.setTextureKeys(value);
                        const editor = this.getEditor();
                        editor.refreshDependenciesHash();
                        editor.dispatchSelectionChanged();
                        editor.repaint();
                    }
                }
                sceneobjects.ChangeTextureOperation = ChangeTextureOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class PhaserTextureCellRenderer {
                    renderCell(args) {
                        const image = this.getImage(args);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, false);
                        }
                        else {
                            controls.DefaultImage.paintEmpty(args.canvasContext, args.x, args.y, args.w, args.h);
                        }
                    }
                    getImage(args) {
                        const obj = args.obj;
                        const texture = obj.scene.textures.get(obj.texture.key);
                        if (texture) {
                            const canvas = texture.getSourceImage();
                            return new controls.ImageWrapper(canvas);
                        }
                        return null;
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const image = this.getImage(args);
                        if (image) {
                            return image.preload();
                        }
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                sceneobjects.PhaserTextureCellRenderer = PhaserTextureCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TextureCellRenderer {
                    renderCell(args) {
                        const image = this.getImage(args);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, false);
                        }
                        else {
                            controls.DefaultImage.paintEmpty(args.canvasContext, args.x, args.y, args.w, args.h);
                        }
                    }
                    getImage(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const textureComp = support.getComponent(sceneobjects.TextureComponent);
                        if (textureComp) {
                            const { key, frame } = textureComp.getTextureKeys();
                            const image = support.getScene().getPackCache().getImage(key, frame);
                            return image;
                        }
                        return null;
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const image = this.getImage(args);
                        if (image) {
                            return image.preload();
                        }
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                sceneobjects.TextureCellRenderer = TextureCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../Component.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextureComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            TextureComponent.texture
                        ]);
                        this._textureKeys = {};
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const prop = TextureComponent.texture;
                        if (support.isNestedPrefabInstance()
                            && support.isUnlockedProperty(prop)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setTexture", args.objectVarName);
                            const keys = prop.getValue(obj);
                            dom.argLiteral(keys.key);
                            dom.argStringOrFloat(keys.frame);
                            args.statements.push(dom);
                        }
                    }
                    getTextureKeys() {
                        return this._textureKeys;
                    }
                    setTextureKeys(keys) {
                        this._textureKeys = keys;
                        if (this._textureKeys.frame === null) {
                            this._textureKeys.frame = undefined;
                        }
                        const obj = this.getObject();
                        const ox = obj.originX;
                        const oy = obj.originY;
                        obj.setTexture(keys.key || null, keys.frame);
                        if (obj.getEditorSupport().hasComponent(sceneobjects.OriginComponent)) {
                            obj.setOrigin(ox, oy);
                        }
                    }
                    removeTexture() {
                        this.setTextureKeys({});
                    }
                }
                TextureComponent.texture = {
                    name: "texture",
                    defValue: {},
                    getValue: obj => {
                        const textureComponent = obj.getEditorSupport().getComponent(TextureComponent);
                        return textureComponent.getTextureKeys();
                    },
                    setValue: (obj, value) => {
                        const textureComponent = obj.getEditorSupport().getComponent(TextureComponent);
                        textureComponent.setTextureKeys(value);
                    }
                };
                sceneobjects.TextureComponent = TextureComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TextureFrameSelectionDialog extends controls.dialogs.ViewerDialog {
                    constructor(finder, callback, atlasKey) {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TextureFrameSelectionDialog"), true);
                        this._finder = finder;
                        this._callback = callback;
                        this._atlasKey = atlasKey;
                        this.setSize(900, 500, true);
                    }
                    static async createDialog(finder, selected, callback, atlasKey) {
                        const dlg = new TextureFrameSelectionDialog(finder, callback, atlasKey);
                        dlg.create();
                        dlg.getViewer().setSelection(selected);
                        dlg.getViewer().reveal(...selected);
                        return dlg;
                    }
                    create() {
                        const viewer = this.getViewer();
                        viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                        viewer.setTreeRenderer(new phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer(viewer, false));
                        viewer.setCellRendererProvider(new phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider("grid"));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        viewer.setCellSize(64, true);
                        let input;
                        const item = this._finder.findAssetPackItem(this._atlasKey);
                        if (item instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                            input = item.getFrames();
                        }
                        else {
                            input = [];
                        }
                        viewer.setInput(input);
                        viewer.expandRoots();
                        super.create();
                        this.setTitle("Select Texture Frame");
                        const btn = this.addButton("Select", () => {
                            this._callback(this.getViewer().getSelection());
                            this.close();
                        });
                        btn.disabled = true;
                        viewer.eventSelectionChanged.addListener(() => {
                            btn.disabled = this.getViewer().getSelection().length !== 1
                                || !phasereditor2d.pack.core.AssetPackUtils.isImageFrameOrImage(this.getViewer().getSelectionFirstElement());
                        });
                        viewer.eventOpenItem.addListener(() => btn.click());
                        this.addButton("Cancel", () => this.close());
                    }
                }
                sceneobjects.TextureFrameSelectionDialog = TextureFrameSelectionDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var ide = colibri.ui.ide;
                class TextureSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, TextureSection.SECTION_ID, "Texture", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/texture-property.html";
                    }
                    createMenu(menu) {
                        this.getEditor().getMenuCreator().createTextureMenuItems(menu);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto 1fr auto";
                        // Preview
                        const imgComp = document.createElement("div");
                        imgComp.style.gridColumn = "1/ span 3";
                        imgComp.style.height = "200px";
                        comp.appendChild(imgComp);
                        const imgControl = new controls.ImageControl(ide.IMG_SECTION_PADDING);
                        imgControl.getElement().style.position = "relative";
                        this.getPage().eventControlLayout.addListener(() => {
                            imgControl.resizeTo();
                        });
                        imgComp.appendChild(imgControl.getElement());
                        requestAnimationFrame(() => imgControl.resizeTo());
                        this.addUpdater(async () => {
                            const frames = this.getSelectedFrames();
                            imgControl.setImage(new controls.MultiImage(frames, 10, 10));
                            requestAnimationFrame(() => imgControl.resizeTo());
                        });
                        {
                            // Size
                            const label = this.createLabel(comp);
                            label.style.gridColumn = "1 / span 3";
                            label.style.justifySelf = "center";
                            this.addUpdater(() => {
                                const frames = this.getSelectedFrames();
                                if (frames.length === 1) {
                                    const frame = frames[0];
                                    label.innerHTML = frame.getWidth() + "x" + frame.getHeight();
                                }
                                else {
                                    label.innerHTML = "";
                                }
                            });
                        }
                        {
                            // Lock
                            this.createLock(comp, sceneobjects.TextureComponent.texture);
                        }
                        {
                            // Buttons
                            const changeBtn = this.createButton(comp, "Select", e => {
                                sceneobjects.ChangeTextureOperation.runDialog(this.getEditor());
                            });
                            controls.Tooltip.tooltip(changeBtn, "Click to select a new texture.");
                            const deleteBtn = this.createButton(comp, "Delete", e => {
                                this.getEditor().getUndoManager()
                                    .add(new sceneobjects.ChangeTextureOperation(this.getEditor(), this.getSelection(), {}));
                            });
                            controls.Tooltip.tooltip(deleteBtn, "Removes the texture of the object.");
                            this.addUpdater(() => {
                                if (this.getSelection().length === 1) {
                                    const obj = this.getSelection()[0];
                                    const textureComp = this.getTextureComponent(obj);
                                    const { key, frame } = textureComp.getTextureKeys();
                                    let str = "(Select)";
                                    if (frame !== undefined) {
                                        str = frame + " @ " + key;
                                    }
                                    else if (key) {
                                        str = key;
                                    }
                                    changeBtn.textContent = str;
                                }
                                else {
                                    changeBtn.textContent = "Multiple Textures";
                                }
                                const unlocked = this.isUnlocked(sceneobjects.TextureComponent.texture);
                                changeBtn.disabled = !unlocked;
                                deleteBtn.disabled = !unlocked;
                            });
                        }
                    }
                    getSelectedFrames() {
                        // this happens when the editor is opened but the scene is not yet created
                        if (!this.getEditor().getScene()) {
                            return [];
                        }
                        const cache = this.getEditor().getScene().getPackCache();
                        const images = new Set();
                        for (const obj of this.getSelection()) {
                            const textureComp = this.getTextureComponent(obj);
                            const { key, frame } = textureComp.getTextureKeys();
                            const img = cache.getImage(key, frame);
                            if (img) {
                                images.add(img);
                            }
                        }
                        return [...images];
                    }
                    getTextureComponent(obj) {
                        return obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.TextureComponent) !== null;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                TextureSection.SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.TextureSection";
                sceneobjects.TextureSection = TextureSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                const grouping = phasereditor2d.pack.ui.viewers.AssetPackGrouping;
                const TYPES = [
                    phasereditor2d.pack.core.IMAGE_TYPE,
                    phasereditor2d.pack.core.SVG_TYPE,
                    phasereditor2d.pack.core.ATLAS_TYPE,
                    phasereditor2d.pack.core.SPRITESHEET_TYPE
                ];
                class TextureSelectionDialog extends controls.dialogs.ViewerDialog {
                    constructor(editor, callback) {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TextureSelectionDialog"), true);
                        this._editor = editor;
                        this._callback = callback;
                        this.setSize(900, 500, true);
                    }
                    static async createDialog(editor, selected, callback) {
                        const dlg = new TextureSelectionDialog(editor, callback);
                        dlg.create();
                        dlg.getViewer().setSelection(selected);
                        dlg.getViewer().reveal(...selected);
                        return dlg;
                    }
                    create() {
                        const viewer = this.getViewer();
                        viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                        viewer.setTreeRenderer(new phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer(viewer, false));
                        viewer.setCellRendererProvider(new phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider("grid"));
                        viewer.setContentProvider(new (class extends ui.blocks.SceneEditorBlocksContentProvider {
                            getRoots(input) {
                                return input;
                            }
                        })(this._editor, () => this._editor.getPackFinder().getPacks()));
                        viewer.setCellSize(64, true);
                        viewer.setInput(TYPES);
                        viewer.expandRoots();
                        super.create();
                        this.setTitle("Select Texture");
                        const btn = this.addButton("Select", () => {
                            this._callback(this.getViewer().getSelection());
                            this.close();
                        });
                        btn.disabled = true;
                        viewer.eventSelectionChanged.addListener(() => {
                            btn.disabled = this.getViewer().getSelection().length !== 1
                                || !phasereditor2d.pack.core.AssetPackUtils.isImageFrameOrImage(this.getViewer().getSelectionFirstElement());
                        });
                        viewer.eventOpenItem.addListener(() => btn.click());
                        this.addButton("Cancel", () => this.close());
                        this.updateFromGroupingType();
                    }
                    updateFromGroupingType() {
                        const type = grouping.getGroupingPreference();
                        const viewer = this.getViewer();
                        switch (type) {
                            case grouping.GROUP_ASSETS_BY_TYPE:
                                viewer.setInput(TYPES);
                                break;
                            case grouping.GROUP_ASSETS_BY_PACK:
                                viewer.setInput(this._editor.getPackFinder().getPacks());
                                break;
                            case grouping.GROUP_ASSETS_BY_LOCATION:
                                viewer.setInput(grouping.getAssetsFolders(this._editor.getPackFinder().getPacks()));
                                break;
                        }
                        viewer.repaint();
                        viewer.expandRoots();
                    }
                    fillContextMenu(menu) {
                        const selectedType = grouping.getGroupingPreference();
                        for (const type of grouping.GROUP_ASSET_TYPES) {
                            menu.addAction({
                                text: "Group By " + grouping.GROUP_ASSET_TYPE_LABEL_MAP[type],
                                selected: type === selectedType,
                                callback: () => {
                                    grouping.setGroupingPreference(type);
                                    this.updateFromGroupingType();
                                }
                            });
                        }
                    }
                }
                sceneobjects.TextureSelectionDialog = TextureSelectionDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_57) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Tilemap extends Phaser.Tilemaps.Tilemap {
                    constructor(scene, key) {
                        super(scene, Tilemap.createTilemapData(scene, key));
                        this._key = key;
                        this._editorSupport = new sceneobjects.TilemapEditorSupport(scene, this);
                        for (const tileset of this.tilesets) {
                            tileset["__tilemap"] = this;
                        }
                    }
                    static createTilemapData(scene, key) {
                        const tilemapData = scene.cache.tilemap.get(key);
                        if (tilemapData) {
                            const mapData = Phaser.Tilemaps.Parsers.Parse(key, tilemapData.format, tilemapData.data, undefined, undefined, undefined);
                            return mapData;
                        }
                        return new Phaser.Tilemaps.MapData();
                    }
                    static getTilemapFromTileset(tileset) {
                        return tileset["__tilemap"];
                    }
                    getTilemapAssetKey() {
                        return this._key;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Tilemap = Tilemap;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_57.ui || (scene_57.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilemapConfigWizard extends controls.dialogs.WizardDialog {
                    constructor(finder) {
                        super();
                        this._finder = finder;
                        this.setSize(undefined, 500, true);
                    }
                    getFinder() {
                        return this._finder;
                    }
                    create() {
                        this._tilemapKeyPage = new TilemapKeyPage();
                        this._tilesetsPage = new TilesetsPage();
                        this._tilemapLayerNamePage = new TilemapLayerNamePage();
                        this.addPages(this._tilemapKeyPage, this._tilesetsPage, this._tilemapLayerNamePage);
                        super.create();
                        this.setTitle("Tilemap Configuration");
                    }
                    getTilemapKeyPage() {
                        return this._tilemapKeyPage;
                    }
                    getTilesetsPage() {
                        return this._tilesetsPage;
                    }
                    getTilemapLayerNamePage() {
                        return this._tilemapLayerNamePage;
                    }
                    getTilemapAssets() {
                        return this._finder
                            .getAssets(a => a instanceof phasereditor2d.pack.core.TilemapTiledJSONAssetPackItem);
                    }
                    setFinishCallback(cb) {
                        this._finishCallback = cb;
                    }
                    setCancelCallback(cb) {
                        this._cancelCallback = cb;
                    }
                    finishButtonPressed() {
                        this._finishCallback();
                    }
                    cancelButtonPressed() {
                        this._cancelCallback();
                    }
                }
                sceneobjects.TilemapConfigWizard = TilemapConfigWizard;
                class BasePage extends controls.dialogs.WizardPage {
                    getWizard() {
                        return super.getWizard();
                    }
                }
                class TilemapKeyPage extends BasePage {
                    constructor() {
                        super("Tilemap Key", "Select the tilemap key.");
                    }
                    getTilemapAsset() {
                        return this._tilemapAsset;
                    }
                    createElements(parent) {
                        this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TilemapKeyPage");
                        this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._viewer.setLabelProvider(new controls.viewers.LabelProvider((tilemap) => {
                            return tilemap.getKey();
                        }));
                        this._viewer.setCellRendererProvider(controls.viewers.EmptyCellRendererProvider.withIcon(phasereditor2d.pack.AssetPackPlugin.getInstance().getIcon(phasereditor2d.pack.ICON_TILEMAP)));
                        this._viewer.setInput(this.getWizard().getTilemapAssets());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                        parent.appendChild(filteredViewer.getElement());
                        this._viewer.eventSelectionChanged.addListener(sel => {
                            this._tilemapAsset = this._viewer.getSelectionFirstElement();
                            this.getWizard().updateWizardButtons();
                        });
                        this.updateUI();
                    }
                    updateUI() {
                        if (this._tilemapAsset) {
                            this._viewer.setSelection([this._tilemapAsset]);
                            this._viewer.reveal(this._tilemapAsset);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return this.canGoNext();
                    }
                    canGoNext() {
                        return this._tilemapAsset !== undefined && this._tilemapAsset !== null;
                    }
                }
                class TilesetsPage extends BasePage {
                    constructor() {
                        super("Tilesets", "Assign an image to each tileset.");
                        this._imageMap = new Map();
                    }
                    getImageMap() {
                        return this._imageMap;
                    }
                    autoSetImages() {
                        this._imageMap = new Map();
                        const tilesets = this.getWizard().getTilemapKeyPage().getTilemapAsset().getTilesetsData();
                        for (const tileset of tilesets) {
                            if (tileset.source) {
                                alert("Phaser does not support external tilesets.");
                                continue;
                            }
                            const asset = this.findTilesetImage(tileset.image);
                            if (asset) {
                                this._imageMap.set(tileset.name, asset);
                            }
                        }
                    }
                    findTilesetImage(tilesetImage) {
                        const finder = this.getWizard().getFinder();
                        const image1 = tilesetImage;
                        const image2 = colibri.ui.ide.FileUtils.getFileNameWithoutExtension(image1);
                        const split1 = image2.split("/");
                        const image3 = split1[split1.length - 1];
                        const split2 = image2.split("\\");
                        const image4 = split2[split2.length - 1];
                        for (const image of [image1, image2, image3, image4]) {
                            const result = finder.findAssetPackItem(image);
                            if (result && (result instanceof phasereditor2d.pack.core.ImageAssetPackItem
                                || result instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem)) {
                                return result;
                            }
                        }
                        return undefined;
                    }
                    createElements(parent) {
                        this.autoSetImages();
                        const tilesets = this.getWizard().getTilemapKeyPage().getTilemapAsset().getTilesetsData();
                        const comp = document.createElement("div");
                        comp.style.display = "grid";
                        comp.style.gridTemplateRows = "1fr auto";
                        comp.style.gridTemplateColumns = "1fr";
                        comp.style.rowGap = "5px";
                        comp.style.height = "100%";
                        parent.appendChild(comp);
                        const viewerWrapperElement = document.createElement("div");
                        viewerWrapperElement.style.height = "100%";
                        comp.appendChild(viewerWrapperElement);
                        this._tilesetViewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TilesetsPage");
                        this._tilesetViewer.setCellSize(64);
                        this._tilesetViewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._tilesetViewer.setLabelProvider(new controls.viewers.LabelProvider((tileset) => {
                            return tileset.name;
                        }));
                        this._tilesetViewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider((obj) => {
                            const item = this._imageMap.get(obj.name);
                            if (item) {
                                return new controls.viewers.ImageCellRenderer(phasereditor2d.pack.core.AssetPackUtils.getImageFromPackUrl(item.getPack(), item.getUrl()));
                            }
                            return new controls.viewers.EmptyCellRenderer(false);
                        }));
                        this._tilesetViewer.setInput(tilesets);
                        this._tilesetViewer.eventSelectionChanged.addListener(e => this.updateUI());
                        this._tilesetViewer.eventOpenItem.addListener(e => this.openAssignImageDialog());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._tilesetViewer, true);
                        viewerWrapperElement.appendChild(filteredViewer.getElement());
                        this._assignButton = document.createElement("button");
                        this._assignButton.textContent = "Set Tileset Image";
                        this._assignButton.style.justifySelf = "self-end";
                        comp.appendChild(this._assignButton);
                        this._assignButton.addEventListener("click", e => this.openAssignImageDialog());
                    }
                    openAssignImageDialog() {
                        const finder = this.getWizard().getFinder();
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog("tree");
                        dlg.create(false);
                        dlg.getViewer().setInput(finder.getAssets(a => a instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem
                            || a instanceof phasereditor2d.pack.core.ImageAssetPackItem));
                        dlg.setSelectionCallback((sel) => {
                            const tileset = this._tilesetViewer.getSelectionFirstElement();
                            const asset = sel[0];
                            this._imageMap.set(tileset.name, asset);
                            this.updateUI();
                        });
                    }
                    canFinish() {
                        const tilemap = this.getWizard().getTilemapKeyPage().getTilemapAsset();
                        if (tilemap) {
                            const tilesets = tilemap.getTilesetsData();
                            for (const tileset of tilesets) {
                                if (!this._imageMap.has(tileset.name)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        return false;
                    }
                    canGoNext() {
                        return this.canFinish();
                    }
                    updateUI() {
                        this._assignButton.disabled = this._tilesetViewer.getSelection().length === 0;
                        this._tilesetViewer.repaint();
                        this.getWizard().updateWizardButtons();
                    }
                }
                class TilemapLayerNamePage extends BasePage {
                    constructor() {
                        super("Tilemap Layer", "Select a Tilemap Layer.");
                    }
                    createElements(parent) {
                        this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.LayerPage");
                        this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._viewer.setLabelProvider(new controls.viewers.LabelProvider((name) => name));
                        this._viewer.setCellRendererProvider(controls.viewers.EmptyCellRendererProvider.withIcon(phasereditor2d.pack.AssetPackPlugin.getInstance().getIcon(phasereditor2d.pack.ICON_TILEMAP_LAYER)));
                        this._viewer.setInput(this.getWizard().getTilemapKeyPage().getTilemapAsset().getLayerNames());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                        parent.appendChild(filteredViewer.getElement());
                        this._viewer.eventSelectionChanged.addListener(sel => {
                            this._tilemapLayerName = this._viewer.getSelectionFirstElement();
                            this.getWizard().updateWizardButtons();
                        });
                        this.updateUI();
                    }
                    getTilemapLayerName() {
                        return this._tilemapLayerName;
                    }
                    updateUI() {
                        if (this._tilemapLayerName) {
                            this._viewer.setSelection([this._tilemapLayerName]);
                            this._viewer.reveal(this._tilemapLayerName);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return true;
                    }
                    canGoBack() {
                        return true;
                    }
                    canGoNext() {
                        return true;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_58) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapEditorSupport extends sceneobjects.ScenePlainObjectEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.TilemapExtension.getInstance(), obj, scene);
                        this.setLabel(obj.getTilemapAssetKey());
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        const tilemap = this.getObject();
                        data.key = tilemap.getTilemapAssetKey();
                        data.tilesets = [];
                        for (const tileset of tilemap.tilesets) {
                            data.tilesets.push({
                                name: tileset.name,
                                imageKey: tileset.image ? tileset.image.key : undefined
                            });
                        }
                    }
                    readJSON(data) {
                        super.readJSON(data);
                        const scene = this.getScene();
                        const textures = scene.sys.textures;
                        const tilemap = this.getObject();
                        for (const tileset of tilemap.tilesets) {
                            const tilesetData = data.tilesets.find(t => t.name === tileset.name);
                            if (tilesetData && tilesetData.imageKey) {
                                const imageKey = tilesetData.imageKey;
                                if (textures.exists(imageKey)) {
                                    tileset.setImage(textures.get(imageKey));
                                }
                            }
                        }
                    }
                    destroy() {
                        const tilemap = this.getObject();
                        const layers = [];
                        this.getScene().visitAll(obj => {
                            if (obj instanceof sceneobjects.TilemapLayer) {
                                if (obj.tilemap === tilemap) {
                                    layers.push(obj);
                                }
                            }
                        });
                        for (const layer of layers) {
                            layer.getEditorSupport().destroy();
                        }
                        tilemap.destroy();
                    }
                    async buildDependencyHash(args) {
                        //
                    }
                }
                sceneobjects.TilemapEditorSupport = TilemapEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_58.ui || (scene_58.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_59) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene_59.core.code;
                class TilemapExtension extends sceneobjects.ScenePlainObjectExtension {
                    constructor() {
                        super({
                            category: scene_59.SCENE_OBJECT_TILEMAP_CATEGORY,
                            icon: phasereditor2d.pack.AssetPackPlugin.getInstance().getIconDescriptor(phasereditor2d.pack.ICON_TILEMAP),
                            phaserTypeName: "Phaser.Tilemaps.Tilemap",
                            typeName: "Tilemap"
                        });
                    }
                    static getInstance() {
                        return this._instance ?? (this._instance = new TilemapExtension());
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const result = [];
                        const tilemap = args.obj;
                        const addTilemapDom = new code.MethodCallCodeDOM("tilemap", args.gameObjectFactoryExpr + ".add");
                        addTilemapDom.argLiteral(tilemap.getTilemapAssetKey());
                        result.push(addTilemapDom);
                        for (const tileset of tilemap.tilesets) {
                            const addTilesetImageDom = new code.MethodCallCodeDOM("addTilesetImage", args.varname);
                            addTilesetImageDom.argLiteral(tileset.name);
                            if (tileset.image) {
                                addTilesetImageDom.argLiteral(tileset.image.key);
                            }
                            result.push(addTilesetImageDom);
                        }
                        return result;
                    }
                    async getAssetsFromObjectData(args) {
                        const result = [];
                        const finder = args.finder;
                        const data = args.data;
                        const key = data.key;
                        const item = args.finder.findAssetPackItem(key);
                        if (item instanceof phasereditor2d.pack.core.TilemapTiledJSONAssetPackItem) {
                            result.push(item);
                        }
                        for (const tileset of data.tilesets) {
                            if (tileset.imageKey) {
                                const asset = finder.findAssetPackItem(tileset.imageKey);
                                if (asset instanceof phasereditor2d.pack.core.ImageAssetPackItem
                                    || asset instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem) {
                                    result.push(asset);
                                }
                            }
                        }
                        return result;
                    }
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const promise = new Promise((resolve, reject) => {
                            const dlg = new sceneobjects.TilemapConfigWizard(finder);
                            dlg.setFinishCallback(async () => {
                                const tilemap = dlg.getTilemapKeyPage().getTilemapAsset();
                                const tilesetsImages = dlg.getTilesetsPage().getImageMap();
                                const tilemapLayerName = dlg.getTilemapLayerNamePage().getTilemapLayerName();
                                const scene = editor.getScene();
                                let updater = scene_59.ScenePlugin.getInstance().getLoaderUpdaterForAsset(tilemap);
                                await updater.updateLoader(scene, tilemap);
                                for (const [name, image] of tilesetsImages.entries()) {
                                    updater = scene_59.ScenePlugin.getInstance().getLoaderUpdaterForAsset(image);
                                    await updater.updateLoader(scene, image);
                                }
                                const result = {
                                    data: {
                                        tilemap,
                                        tilesetsImages,
                                        tilemapLayerName
                                    }
                                };
                                resolve(result);
                            });
                            dlg.setCancelCallback(() => {
                                const result = {
                                    abort: true
                                };
                                resolve(result);
                            });
                            dlg.create();
                        });
                        return promise;
                    }
                    createDefaultSceneObject(args) {
                        const extraData = args.extraData;
                        const tilesetsImages = extraData.tilesetsImages;
                        const tilemap = new sceneobjects.Tilemap(args.scene, extraData.tilemap.getKey());
                        for (const [name, image] of tilesetsImages.entries()) {
                            tilemap.addTilesetImage(name, image.getKey());
                        }
                        if (extraData.tilemapLayerName) {
                            const layer = new sceneobjects.TilemapLayer(args.scene, tilemap, extraData.tilemapLayerName);
                            return [tilemap, layer];
                        }
                        return [tilemap];
                    }
                    createPlainObjectWithData(args) {
                        const data = args.data;
                        const key = data.key;
                        const tilemap = new sceneobjects.Tilemap(args.scene, key);
                        tilemap.getEditorSupport().readJSON(data);
                        return tilemap;
                    }
                    isAvailableAsPrefabElement() {
                        return false;
                    }
                }
                sceneobjects.TilemapExtension = TilemapExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_59.ui || (scene_59.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_60) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLayer extends Phaser.Tilemaps.TilemapLayer {
                    constructor(scene, tilemap, layerName) {
                        super(scene, tilemap, tilemap.getLayerIndex(layerName), tilemap.tilesets);
                        this.setRenderOrder(tilemap.renderOrder);
                        this.setOrigin(0, 0);
                        // we do this to prevent a wrong culling when the camera is scrolled and zoomed.
                        this.setCullPadding(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        this._editorSupport = new sceneobjects.TilemapLayerEditorSupport(this, scene);
                    }
                    static scanTilesets(layer) {
                        const gidMap = new Map();
                        const allTilesets = layer.tilemap.tilesets;
                        for (const tileset of allTilesets) {
                            const s = tileset.firstgid;
                            for (let t = 0; t < tileset.total; t++) {
                                gidMap.set(s + t, tileset);
                            }
                        }
                        const layerTilesets = new Set();
                        for (let x = 0; x < layer.width; x++) {
                            for (let y = 0; y < layer.height; y++) {
                                const tile = layer.getTileAt(x, y);
                                if (tile) {
                                    const tileset = gidMap.get(tile.index);
                                    if (tileset) {
                                        layerTilesets.add(tileset);
                                    }
                                }
                            }
                        }
                        return [...layerTilesets];
                    }
                    destroy() {
                        super.destroy(true);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.TilemapLayer = TilemapLayer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_60.ui || (scene_60.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TilemapLayerCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    constructor(factoryMethod) {
                        super();
                        this._factoryMethod = factoryMethod;
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const tilemapLayer = args.obj;
                        const tilesets = sceneobjects.TilemapLayer.scanTilesets(tilemapLayer);
                        const tilesetArray = "[" + tilesets.map(t => code.CodeDOM.quote(t.name)).join(",") + "]";
                        const tilemap = tilemapLayer.tilemap;
                        const tilemapVarName = code.formatToValidVarName(tilemap.getEditorSupport().getLabel());
                        const call = new code.MethodCallCodeDOM(this._factoryMethod, tilemapVarName);
                        call.argLiteral(tilemapLayer.layer.name);
                        call.arg(tilesetArray);
                        call.argInt(tilemapLayer.x);
                        call.argInt(tilemapLayer.y);
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        throw new Error("Not supported");
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        throw new Error("Not supported");
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        throw new Error("Not supported");
                    }
                }
                sceneobjects.TilemapLayerCodeDOMBuilder = TilemapLayerCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_61) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLayerEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.TilemapLayerExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.VisibleComponent(obj));
                        this.setLabel(obj.layer.name);
                    }
                    computeOrigin() {
                        if (this.getOrientation() === Phaser.Tilemaps.Orientation.ISOMETRIC) {
                            return { originX: 0.5, originY: 0 };
                        }
                        return super.computeOrigin();
                    }
                    isUnlockedProperty(property) {
                        if (property === sceneobjects.TransformComponent.angle) {
                            return false;
                        }
                        return super.isUnlockedProperty(property);
                    }
                    computeContentHash() {
                        const obj = this.getObject();
                        const tilesetHash = obj.tileset.map(t => t.image).filter(img => img).map(img => img.key);
                        return obj.tilemap.getEditorSupport().getId() + "-" + obj.layer.name + "-" + tilesetHash;
                    }
                    setInteractive() {
                        this.getObject().setInteractive(TilemapLayerEditorSupport.helper_interactiveCallback);
                    }
                    getCellRenderer() {
                        return new sceneobjects.ObjectCellRenderer();
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        const layer = this.getObject();
                        const tilemap = layer.tilemap;
                        data.tilemapId = tilemap.getEditorSupport().getId();
                        data.layerName = layer.layer.name;
                        data.tilesets = tilemap.tilesets.map(t => t.name);
                    }
                    getOrientation() {
                        return this.getObject().tilemap.orientation;
                    }
                    static helper_interactiveCallback(hitArea, x, y, layer) {
                        if (x >= -layer.width && y >= -layer.height && x <= layer.width && y <= layer.height) {
                            let worldToTile;
                            const orientation = layer.tilemap.orientation;
                            if (orientation === Phaser.Tilemaps.Orientation.ISOMETRIC) {
                                worldToTile = TilemapLayerEditorSupport.isometricWorldToTileXY;
                            }
                            else {
                                worldToTile = TilemapLayerEditorSupport.worldToTileXY;
                            }
                            const { tileX, tileY } = worldToTile(x, y, layer);
                            const tile = layer.getTileAt(tileX, tileY);
                            return tile !== null && tile !== undefined;
                        }
                        return false;
                    }
                    static worldToTileXY(worldX, worldY, tilemapLayer) {
                        const layerData = tilemapLayer.layer;
                        const tileX = Math.floor(worldX / layerData.baseTileWidth * tilemapLayer.scaleX);
                        const tileY = Math.floor(worldY / layerData.baseTileHeight * tilemapLayer.scaleY);
                        return { tileX, tileY };
                    }
                    ;
                    static isometricWorldToTileXY(worldX, worldY, tilemapLayer) {
                        const layerData = tilemapLayer.layer;
                        let tileWidth = layerData.baseTileWidth;
                        let tileHeight = layerData.baseTileHeight;
                        tileHeight *= tilemapLayer.scaleY;
                        tileWidth *= tilemapLayer.scaleX;
                        worldX -= tileWidth / 2;
                        const tileX = Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2);
                        const tileY = Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2);
                        return { tileX, tileY };
                    }
                    ;
                }
                sceneobjects.TilemapLayerEditorSupport = TilemapLayerEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_61.ui || (scene_61.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_62) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilemapLayerExtension extends sceneobjects.SceneGameObjectExtension {
                    constructor() {
                        super({
                            icon: phasereditor2d.pack.AssetPackPlugin.getInstance().getIconDescriptor(phasereditor2d.pack.ICON_TILEMAP_LAYER),
                            phaserTypeName: "Phaser.Tilemaps.TilemapLayer",
                            typeName: "TilemapLayer",
                            typeNameAlias: ["StaticTilemapLayer", "DynamicTilemapLayer"],
                            category: scene_62.SCENE_OBJECT_TILEMAP_CATEGORY,
                        });
                    }
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new TilemapLayerExtension());
                    }
                    createTilemapLayer(scene, tilemap, layerName) {
                        const layer = new sceneobjects.TilemapLayer(scene, tilemap, layerName);
                        return layer;
                    }
                    getCodeFactoryMethod() {
                        return "createLayer";
                    }
                    /**
                     * Collect the data used to create a new, empty object. For example, a BitmapText requires
                     * a BitmapFont key to be created, so this method opens a dialog to select the font.
                     */
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const tilemaps = editor.getScene().getPlainObjects()
                            .filter(o => o instanceof sceneobjects.Tilemap);
                        if (tilemaps.length === 0) {
                            return {
                                dataNotFoundMessage: "First, you need to add a Tilemap object to the scene."
                            };
                        }
                        const noImageTilesets = tilemaps
                            .flatMap(tilemap => tilemap.tilesets)
                            .filter(tileset => !tileset.image)
                            .map(tileset => tileset.name);
                        if (noImageTilesets.length > 0) {
                            const names = `<ul>${noImageTilesets.map(n => `<li>${n}</li>`).join("")}</ul>`;
                            return {
                                dataNotFoundMessage: "The following tilesets have no image:" + names
                            };
                        }
                        const layers = tilemaps
                            .flatMap(tilemap => tilemap.getTileLayerNames().map(layerName => {
                            return {
                                tilemap,
                                layerName
                            };
                        }));
                        if (layers.length === 0) {
                            return {
                                dataNotFoundMessage: "No layers are available in the current tilemaps."
                            };
                        }
                        if (layers.length === 1) {
                            return {
                                data: layers[0]
                            };
                        }
                        return new Promise((resolve, reject) => {
                            const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.CollectExtraDataDialog");
                            viewer.setLabelProvider(new DialogLabelProvider());
                            viewer.setCellRendererProvider(new DialogCellRendererProvider());
                            viewer.setContentProvider(new DialogContentProvider(editor));
                            // viewer.setTreeRenderer(new controls.viewers.TreeViewerRenderer(viewer));
                            viewer.setInput([]);
                            for (const tilemap of tilemaps) {
                                viewer.setExpanded(tilemap, true);
                            }
                            const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                            dlg.create();
                            dlg.setTitle("Select Layer Name");
                            dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Select", sel => {
                                const data = sel[0];
                                resolve({
                                    data
                                });
                            }), obj => !(obj instanceof sceneobjects.Tilemap));
                            dlg.addCancelButton();
                        });
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        throw new Error("Method not implemented.");
                    }
                    createGameObjectWithData(args) {
                        const data = args.data;
                        const scene = args.scene;
                        const tilemap = scene.getPlainObjectById(data.tilemapId);
                        if (!tilemap) {
                            throw new Error("Cannot find Tilemap with id " + data.tilemapId);
                        }
                        const layer = this.createTilemapLayer(scene, tilemap, data.layerName);
                        layer.getEditorSupport().readJSON(data);
                        return layer;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TilemapLayerCodeDOMBuilder(this.getCodeFactoryMethod());
                    }
                    createDefaultSceneObject(args) {
                        const data = args.extraData;
                        const layer = this.createTilemapLayer(args.scene, data.tilemap, data.layerName);
                        layer.setPosition(args.x, args.y);
                        return [layer];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    isAvailableAsPrefabElement() {
                        return false;
                    }
                }
                sceneobjects.TilemapLayerExtension = TilemapLayerExtension;
                class DialogLabelProvider {
                    getLabel(element) {
                        if (element instanceof sceneobjects.Tilemap) {
                            return element.getTilemapAssetKey();
                        }
                        return `${element.layerName}`;
                    }
                }
                class DialogCellRendererProvider {
                    getCellRenderer(element) {
                        if (element instanceof sceneobjects.Tilemap) {
                            return new controls.viewers.IconGridCellRenderer(phasereditor2d.pack.AssetPackPlugin.getInstance().getIcon(phasereditor2d.pack.ICON_TILEMAP));
                        }
                        return new controls.viewers.IconGridCellRenderer(phasereditor2d.pack.AssetPackPlugin.getInstance().getIcon(phasereditor2d.pack.ICON_TILEMAP_LAYER));
                    }
                    async preload(args) {
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                class DialogContentProvider {
                    constructor(editor) {
                        this._editor = editor;
                        this._map = new Map();
                    }
                    getRoots(input) {
                        const tilemaps = this._editor.getScene()
                            .getPlainObjects()
                            .filter(obj => obj instanceof sceneobjects.Tilemap);
                        return tilemaps;
                    }
                    getChildren(parent) {
                        if (parent instanceof sceneobjects.Tilemap) {
                            if (this._map.has(parent)) {
                                return this._map.get(parent);
                            }
                            const layers = parent.getTileLayerNames().map(layerName => {
                                return {
                                    tilemap: parent,
                                    layerName
                                };
                            });
                            this._map.set(parent, layers);
                            return layers;
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_62.ui || (scene_62.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLayerSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilemapLayerData", "Tilemap Layer", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tilemap-layer-object.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            this.createLabel(comp, "Tilemap");
                            const btn = this.createButton(comp, "", () => {
                                this.getEditor().setSelection([this.getSelectionFirstElement().tilemap]);
                            });
                            this.addUpdater(() => {
                                const tilemap = this.getSelectionFirstElement().tilemap;
                                btn.textContent = tilemap.getEditorSupport().getLabel();
                            });
                        }
                        this.layerProp(comp, "name", "Layer Name");
                        this.layerProp(comp, "width", "Width");
                        this.layerProp(comp, "height", "Height");
                        this.layerProp(comp, "widthInPixels", "Width In Pixels");
                        this.layerProp(comp, "heightInPixels", "Height In Pixels");
                        this.layerProp(comp, "tileHeight", "Tile Height");
                        this.layerProp(comp, "tileWidth", "Tile Width");
                    }
                    layerProp(comp, prop, name) {
                        this.createLabel(comp, name, scene.ScenePlugin.getInstance().getPhaserDocs().getDoc("Phaser.Tilemaps.LayerData." + prop));
                        const text = this.createText(comp, true);
                        this.addUpdater(() => {
                            const layer = this.getSelectionFirstElement();
                            const tilemap = layer.tilemap;
                            const layerData = tilemap.layer;
                            text.value = layerData[prop];
                        });
                    }
                    canEdit(obj, n) {
                        return (obj instanceof sceneobjects.TilemapLayer)
                            && obj.tilemap !== undefined;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilemapLayerSection = TilemapLayerSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_63) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLoaderUpdater extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(game) {
                        const keys = game.cache.tilemap.getKeys();
                        for (const key of keys) {
                            game.cache.tilemap.remove(key);
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.TilemapTiledJSONAssetPackItem;
                    }
                    async updateLoader(scene, asset) {
                        const item = asset;
                        await item.preload();
                        item.addToPhaserCache(scene.game, scene.getPackCache());
                    }
                    async updateLoaderWithObjData(scene, data) {
                        // nothing
                    }
                }
                sceneobjects.TilemapLoaderUpdater = TilemapLoaderUpdater;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_63.ui || (scene_63.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/outline/SceneEditorOutlineExtension.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilemapOutlineExtension extends ui.editor.outline.SceneEditorOutlineExtension {
                    isLabelProviderFor(element) {
                        return element instanceof Phaser.Tilemaps.Tileset;
                    }
                    getLabelProvider() {
                        return new controls.viewers.LabelProvider(obj => {
                            if (obj instanceof Phaser.Tilemaps.Tileset) {
                                return obj.name;
                            }
                            return "";
                        });
                    }
                    isCellRendererProviderFor(element) {
                        return this.isLabelProviderFor(element);
                    }
                    getCellRendererProvider() {
                        return new controls.viewers.EmptyCellRendererProvider(obj => {
                            if (obj instanceof Phaser.Tilemaps.Tileset) {
                                if (obj.image) {
                                    const editor = colibri.Platform.getWorkbench().getActiveEditor();
                                    if (editor instanceof ui.editor.SceneEditor) {
                                        const cache = editor.getScene().getPackCache();
                                        const image = cache.getImage(obj.image.key)
                                            || cache.getSpritesheetImage(obj.image.key);
                                        if (image) {
                                            return new controls.viewers.ImageCellRenderer(image);
                                        }
                                    }
                                }
                            }
                            return new controls.viewers.EmptyCellRenderer(false);
                        });
                    }
                    isContentProviderFor(parent) {
                        return parent instanceof sceneobjects.Tilemap;
                    }
                    getContentProvider() {
                        return new TilemapContentProvider();
                    }
                }
                sceneobjects.TilemapOutlineExtension = TilemapOutlineExtension;
                class TilemapContentProvider {
                    getRoots(input) {
                        return [];
                    }
                    getChildren(parent) {
                        if (parent instanceof sceneobjects.Tilemap) {
                            return parent.tilesets;
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilemapSection", "Tilemap", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tilemap-object.html";
                    }
                    createForm(parent) {
                        const docs = scene.ScenePlugin.getInstance().getPhaserDocs();
                        const comp = this.createGridElement(parent, 2);
                        {
                            this.createLabel(comp, "Asset Key", docs.getDoc("Phaser.GameObjects.GameObjectFactory.tilemap(key)"));
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().getTilemapAssetKey();
                            });
                        }
                        {
                            this.createLabel(comp, "Tile Width", docs.getDoc("Phaser.Tilemaps.Tilemap.tileWidth"));
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().tileWidth.toString();
                            });
                        }
                        {
                            this.createLabel(comp, "Tile Height", docs.getDoc("Phaser.Tilemaps.Tilemap.tileHeight"));
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().tileHeight.toString();
                            });
                        }
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Tilemap;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilemapSection = TilemapSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_64) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilesetPreviewSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilesetPreviewSection", "Tileset Preview", true, false);
                    }
                    createForm(parent) {
                        colibri.ui.ide.properties.BaseImagePreviewSection.createSectionForm(parent, this, () => this.getSelectedImage());
                    }
                    hasMenu() {
                        return false;
                    }
                    getSelectedImage() {
                        const tileset = this.getSelectionFirstElement();
                        if (tileset.image) {
                            const key = tileset.image.key;
                            const tilemap = sceneobjects.Tilemap.getTilemapFromTileset(tileset);
                            if (tilemap) {
                                const scene = tilemap.scene;
                                return scene.getPackCache().getImage(key) || scene.getPackCache().getSpritesheetImage(key);
                            }
                        }
                        return null;
                    }
                    canEdit(obj, n) {
                        return obj instanceof Phaser.Tilemaps.Tileset;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilesetPreviewSection = TilesetPreviewSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_64.ui || (scene_64.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_65) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilesetSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilesetSection2", "Tileset", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.simpleProperty(comp, "name", "Name");
                        {
                            this.createLabel(comp, "Image", this.help("image"));
                            const btn = this.createButton(comp, "", () => this.selectImage());
                            this.addUpdater(() => {
                                let text = "Select Image...";
                                const image = this.getSelectionFirstElement().image;
                                if (image) {
                                    text = image.key;
                                }
                                btn.textContent = text;
                            });
                            controls.Tooltip.tooltip(btn, "Select a new image for this tileset.");
                        }
                        this.simpleProperty(comp, "tileWidth", "Tile Width");
                        this.simpleProperty(comp, "tileHeight", "Tile Height");
                        this.simpleProperty(comp, "tileMargin", "Tile Margin");
                        this.simpleProperty(comp, "tileSpacing", "Tile Spacing");
                    }
                    help(prop) {
                        return scene_65.ScenePlugin.getInstance().getPhaserDocs().getDoc("Phaser.Tilemaps.Tileset." + prop);
                    }
                    simpleProperty(comp, prop, name) {
                        this.createLabel(comp, name, this.help(prop));
                        const text = this.createText(comp, true);
                        this.addUpdater(() => {
                            const tileset = this.getSelectionFirstElement();
                            text.value = tileset[prop].toString();
                        });
                    }
                    async selectImage() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog("tree");
                        dlg.create();
                        dlg.getViewer().setInput(finder.getAssets(i => i instanceof phasereditor2d.pack.core.ImageAssetPackItem
                            || i instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem));
                        dlg.setSelectionCallback(async (sel) => {
                            const editor = this.getEditor();
                            const scene = this.getEditor().getScene();
                            const imageAsset = sel[0];
                            const textures = scene.sys.textures;
                            const imageKey = imageAsset.getKey();
                            let texture;
                            if (textures.exists(imageKey)) {
                                texture = textures.get(imageKey);
                            }
                            else {
                                const loaderExt = scene_65.ScenePlugin.getInstance().getLoaderUpdaterForAsset(imageAsset);
                                await loaderExt.updateLoader(scene, imageAsset);
                                texture = textures.get(imageKey);
                            }
                            editor.getUndoManager().add(new ui.editor.undo.SceneSnapshotOperation(editor, async () => {
                                const tileset = this.getSelectionFirstElement();
                                tileset.setImage(texture);
                                this.getEditor().refreshScene();
                            }));
                        });
                    }
                    canEdit(obj, n) {
                        return obj instanceof Phaser.Tilemaps.Tileset;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilesetSection = TilesetSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_65.ui || (scene_65.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_66) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSprite extends Phaser.GameObjects.TileSprite {
                    constructor(scene, x, y, width, height, texture, frame) {
                        super(scene, x, y, width, height, texture, frame);
                        this._editorSupport = new sceneobjects.TileSpriteEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.TileSprite = TileSprite;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_66.ui || (scene_66.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TileSpriteCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("tileSprite");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        this.buildCreatePrefabInstanceCodeDOM_Size_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.TextureComponent.texture)) {
                            this.addTextureFrameArgsToObjectFactoryMethodCallDOM(args.methodCallDOM, args.obj);
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                        ctr.arg("texture", "string", true);
                        ctr.arg("frame", "number | string", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        if (support.isUnlockedProperty(sceneobjects.SizeComponent.width)) {
                            call.arg("width ?? " + obj.width);
                            call.arg("height ?? " + obj.height);
                        }
                        else {
                            call.arg("width");
                            call.arg("height");
                        }
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("tileSprite", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        this.addTextureFrameArgsToObjectFactoryMethodCallDOM(call, obj);
                        return call;
                    }
                }
                sceneobjects.TileSpriteCodeDOMBuilder = TileSpriteCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteComponent extends sceneobjects.Component {
                    constructor(obj) {
                        super(obj, [
                            TileSpriteComponent.tilePositionX,
                            TileSpriteComponent.tilePositionY,
                            TileSpriteComponent.tileScaleX,
                            TileSpriteComponent.tileScaleY
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TileSpriteComponent.tilePositionX, TileSpriteComponent.tilePositionY, TileSpriteComponent.tileScaleX, TileSpriteComponent.tileScaleY);
                    }
                }
                TileSpriteComponent.tilePositionX = sceneobjects.SimpleProperty("tilePositionX", 0, "X", "phaser:Phaser.GameObjects.TileSprite.tilePositionX");
                TileSpriteComponent.tilePositionY = sceneobjects.SimpleProperty("tilePositionY", 0, "Y", "phaser:Phaser.GameObjects.TileSprite.tilePositionY");
                TileSpriteComponent.tileScaleX = sceneobjects.SimpleProperty("tileScaleX", 1, "X", "Phaser.GameObjects.TileSprite.tileScaleX");
                TileSpriteComponent.tileScaleY = sceneobjects.SimpleProperty("tileScaleY", 1, "Y", "Phaser.GameObjects.TileSprite.tileScaleY");
                TileSpriteComponent.tilePosition = {
                    label: "Tile Position",
                    tooltip: "phaser:Phaser.GameObjects.TileSprite.setTilePosition",
                    x: TileSpriteComponent.tilePositionX,
                    y: TileSpriteComponent.tilePositionY
                };
                TileSpriteComponent.tileScale = {
                    label: "Tile Scale",
                    tooltip: "phaser:Phaser.GameObjects.TileSprite.setTileScale",
                    x: TileSpriteComponent.tileScaleX,
                    y: TileSpriteComponent.tileScaleY
                };
                sceneobjects.TileSpriteComponent = TileSpriteComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_67) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.TileSpriteExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SizeComponent(obj));
                        this.addComponent(new sceneobjects.TileSpriteComponent(obj));
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_RenderTexture);
                    }
                }
                sceneobjects.TileSpriteEditorSupport = TileSpriteEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_67.ui || (scene_67.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_68) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteExtension extends sceneobjects.BaseImageExtension {
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.TileSprite",
                            typeName: "TileSprite",
                            category: scene_68.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: scene_68.ScenePlugin.getInstance().getIconDescriptor(scene_68.ICON_TILESPRITE_TYPE)
                        });
                    }
                    static getInstance() {
                        return this._instance;
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        super.adaptDataAfterTypeConversion(serializer, originalObject, extraData);
                        const obj = originalObject;
                        const width = obj.width === undefined ? 20 : obj.width;
                        const height = obj.height === undefined ? 20 : obj.height;
                        serializer.getData()[sceneobjects.SizeComponent.width.name] = width;
                        serializer.getData()[sceneobjects.SizeComponent.height.name] = height;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TileSpriteCodeDOMBuilder();
                    }
                    newObject(scene, x, y, key, frame) {
                        if (key) {
                            return new sceneobjects.TileSprite(scene, x, y, 0, 0, key, frame);
                        }
                        return new sceneobjects.TileSprite(scene, x, y, 64, 64, null, null);
                    }
                }
                TileSpriteExtension._instance = new TileSpriteExtension();
                sceneobjects.TileSpriteExtension = TileSpriteExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_68.ui || (scene_68.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, TileSpriteSection.SECTION_ID, "Tile Sprite", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tile-sprite-object.html#tile-sprite-properties";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.SizeTool.ID);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.TileSpriteComponent.tilePosition);
                        this.createPropertyXYRow(comp, sceneobjects.TileSpriteComponent.tileScale);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.TileSprite && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                TileSpriteSection.SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.TileSprite";
                sceneobjects.TileSpriteSection = TileSpriteSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TintSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TintSection", "Tint", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tint-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createPropertyBoolean(comp, sceneobjects.TintComponent.tintFill);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintTopLeft, false);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintTopRight, false);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintBottomLeft, false);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintBottomRight, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TintComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TintSection = TintSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class UserPropertyType {
                    constructor(id, defValue) {
                        this._id = id;
                        this._defValue = defValue;
                        this._expressionType = "any";
                    }
                    getExpressionType() {
                        return this._expressionType;
                    }
                    setExpressionType(expressionType) {
                        this._expressionType = expressionType;
                    }
                    hasCustomPropertyType() {
                        return false;
                    }
                    getId() {
                        return this._id;
                    }
                    getDefaultValue() {
                        return this._defValue;
                    }
                    writeJSON(data) {
                        data.id = this._id;
                        if (this.hasCustomPropertyType()) {
                            data.expressionType = this.getExpressionType();
                        }
                    }
                    readJSON(data) {
                        if (this.hasCustomPropertyType()) {
                            this._expressionType = data.expressionType || "any";
                        }
                    }
                    buildStringFieldCode(prop, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, "string", true);
                        decl.setInitialValueExpr(code.CodeDOM.quote(value));
                        return decl;
                    }
                    buildExpressionFieldCode(prop, type, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, type, true);
                        decl.setAllowUndefined(true);
                        decl.setInitialValueExpr(value);
                        return decl;
                    }
                    buildNumberFieldCode(prop, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, "number", true);
                        decl.setInitialValueExpr(value.toString());
                        return decl;
                    }
                    buildBooleanFieldCode(prop, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, "boolean", true);
                        decl.setInitialValueExpr(value.toString());
                        return decl;
                    }
                }
                sceneobjects.UserPropertyType = UserPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class StringPropertyType extends sceneobjects.UserPropertyType {
                    constructor(typeId = "string", defValue = "") {
                        super(typeId, defValue);
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyStringDialogRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildStringFieldCode(prop, value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringProperty(args, userProp.getComponentProperty());
                    }
                    getName() {
                        return "String";
                    }
                    renderValue(value) {
                        return value;
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "text";
                        element.classList.add("formText");
                        element.addEventListener("change", e => {
                            setValue(element.value);
                        });
                        const update = () => {
                            element.value = getValue();
                        };
                        return {
                            element,
                            update
                        };
                    }
                }
                sceneobjects.StringPropertyType = StringPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class AbstractDialogPropertyType extends sceneobjects.StringPropertyType {
                    constructor(config) {
                        super(config.id);
                        this._name = config.name;
                        this._dialogTitle = config.dialogTitle;
                        this._hasCustomIcon = config.hasCustomIcon === undefined ? false : config.hasCustomIcon;
                    }
                    getName() {
                        return this._name;
                    }
                    getEditor() {
                        return colibri.Platform.getWorkbench()
                            .getActiveWindow().getEditorArea()
                            .getSelectedEditor();
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        const prop = userProp.getComponentProperty();
                        if (lockIcon) {
                            section.createLock(parent, prop);
                        }
                        const label = section.createLabel(parent, prop.label, scene.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const comp = this.createEditorComp();
                        parent.appendChild(comp);
                        const text = section.createStringField(comp, prop);
                        const btn = this.createSearchButton(() => prop.getValue(section.getSelectionFirstElement()), value => {
                            text.value = value;
                            const editor = section.getEditor();
                            editor.getUndoManager().add(new sceneobjects.SimpleOperation(editor, section.getSelection(), prop, value));
                        });
                        section.addUpdater(() => {
                            btn.disabled = !section.isUnlocked(prop);
                        });
                        comp.appendChild(btn);
                    }
                    createEditorComp() {
                        const comp = document.createElement("div");
                        comp.style.display = "grid";
                        comp.style.gridTemplateColumns = "1fr auto";
                        comp.style.gap = "5px";
                        comp.style.alignItems = "center";
                        return comp;
                    }
                    createSearchButton(getValue, callback) {
                        const iconControl = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        const btn = document.createElement("button");
                        btn.appendChild(iconControl.getCanvas());
                        btn.addEventListener("click", async (e) => {
                            const value = getValue();
                            this.createSearchDialog(value, callback);
                        });
                        if (this._hasCustomIcon) {
                            this.updateIcon(iconControl, getValue());
                        }
                        return btn;
                    }
                    async updateIcon(iconControl, value) {
                        // iconControl.setIcon(icon);
                    }
                    hasCustomIcon() {
                        return false;
                    }
                    getDialogTitle() {
                        return this._dialogTitle;
                    }
                    getDialogSize() {
                        return {
                            width: undefined,
                            height: window.innerHeight * 2 / 3
                        };
                    }
                    async createSearchDialog(revealValue, callback) {
                        const viewer = await this.createViewer();
                        viewer.setInput([]);
                        const dlg = new controls.dialogs.ViewerDialog(viewer, true);
                        const size = this.getDialogSize();
                        dlg.setSize(size.width, size.height);
                        dlg.create();
                        dlg.setTitle(this.getDialogTitle());
                        dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Select", sel => {
                            const value = this.valueToString(viewer, sel[0]);
                            callback(value);
                        }));
                        dlg.addCancelButton();
                        this.loadViewerInput(viewer);
                        this.revealValue(viewer, revealValue);
                        controls.viewers.GridTreeViewerRenderer.expandSections(viewer);
                    }
                    revealValue(viewer, value) {
                        const found = viewer.findElementByLabel(value);
                        if (found) {
                            viewer.setSelection([found]);
                            viewer.reveal(found);
                        }
                    }
                    createEditorElement(getValue, setValue) {
                        const comp = this.createEditorComp();
                        const inputElement = document.createElement("input");
                        comp.appendChild(inputElement);
                        inputElement.type = "text";
                        inputElement.classList.add("formText");
                        inputElement.addEventListener("change", e => {
                            setValue(inputElement.value);
                        });
                        const update = () => {
                            inputElement.value = getValue();
                        };
                        const btn = this.createSearchButton(getValue, setValue);
                        comp.appendChild(btn);
                        return {
                            element: comp,
                            update
                        };
                    }
                    formatKeyFrame(key, frame) {
                        if (frame === undefined || frame === null) {
                            return key;
                        }
                        return frame.toString();
                    }
                }
                sceneobjects.AbstractDialogPropertyType = AbstractDialogPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
/// <reference path="./AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class AbstractAssetKeyPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    async updateIcon(iconControl, value) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const icon = this.getIcon(finder, value);
                        if (icon) {
                            iconControl.setIcon(icon);
                        }
                    }
                    getIcon(finder, value) {
                        return null;
                    }
                    async createViewer() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.SelectAssetDialog." + this.getId());
                        viewer.setCellRendererProvider(new CellRendererProvider(finder, "tree"));
                        viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                        viewer.setTreeRenderer(new controls.viewers.TreeViewerRenderer(viewer));
                        viewer.setContentProvider(new AssetKeyContentProvider());
                        return viewer;
                    }
                    async loadViewerInput(viewer) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        viewer.setInput(finder.getPacks());
                        for (const pack of finder.getPacks()) {
                            viewer.setExpanded(pack, true);
                        }
                    }
                    valueToString(viewer, selected) {
                        if (selected instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                            return this.formatKeyFrame(selected.getPackItem().getKey(), selected.getName());
                        }
                        const key = viewer.getLabelProvider().getLabel(selected);
                        return this.formatKeyFrame(key);
                    }
                    formatKeyFrame(key, frame) {
                        if (frame === undefined || frame === null) {
                            return key;
                        }
                        return frame.toString();
                    }
                }
                sceneobjects.AbstractAssetKeyPropertyType = AbstractAssetKeyPropertyType;
                class CellRendererProvider extends phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider {
                    constructor(finder, layout) {
                        super(layout);
                        this._finder = finder;
                    }
                    getCellRenderer(element) {
                        if (element instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                            return new AnimationCellRenderer(this._finder);
                        }
                        return super.getCellRenderer(element);
                    }
                }
                class AnimationCellRenderer {
                    constructor(finder) {
                        this.layout = "full-width";
                        this._finder = finder;
                    }
                    renderCell(args) {
                        const anim = args.obj;
                        const frames = anim.getFrames();
                        if (frames.length === 0) {
                            return;
                        }
                        const cellSize = args.viewer.getCellSize();
                        const len = frames.length;
                        const indexes = [0, Math.floor(len / 2), len - 1];
                        const ctx = args.canvasContext;
                        ctx.save();
                        if (cellSize <= controls.ROW_HEIGHT) {
                            const img = this.getImage(frames[0]);
                            if (img) {
                                img.paint(ctx, args.x, args.y, args.w, args.h, true);
                            }
                        }
                        else {
                            // tslint:disable-next-line:prefer-for-of
                            for (let i = 0; i < indexes.length; i++) {
                                const frame = frames[indexes[i]];
                                const img = this.getImage(frame);
                                if (img) {
                                    const x = Math.floor(args.x + i * cellSize * 0.8);
                                    img.paint(ctx, x, args.y + 2, cellSize, args.h - 4, true);
                                }
                            }
                        }
                        ctx.restore();
                    }
                    getImage(frame) {
                        const image = this._finder.getAssetPackItemImage(frame.getTextureKey(), frame.getFrameKey());
                        return image;
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        let result = controls.PreloadResult.NOTHING_LOADED;
                        const anim = args.obj;
                        for (const frame of anim.getFrames()) {
                            const obj = this._finder.getAssetPackItemOrFrame(frame.getTextureKey(), frame.getFrameKey());
                            if (obj) {
                                const objResult = await obj.preload();
                                result = Math.max(result, objResult);
                            }
                        }
                        return result;
                    }
                }
                class AssetKeyContentProvider {
                    getRoots(input) {
                        return input;
                    }
                    getChildren(parent) {
                        if (parent instanceof phasereditor2d.pack.core.AssetPack) {
                            return parent.getItems();
                        }
                        if (parent instanceof phasereditor2d.pack.core.ImageAssetPackItem) {
                            return [];
                        }
                        if (parent instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                            return parent.getFrames();
                        }
                        if (parent instanceof phasereditor2d.pack.core.AnimationsAssetPackItem) {
                            return parent.getAnimations();
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./AbstractAssetKeyPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AnimationKeyPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "animation-key",
                            name: "Animation Key",
                            dialogTitle: "Select Animation Key",
                            hasCustomIcon: true
                        });
                    }
                    getIcon(finder, value) {
                        const animation = finder.getPacks()
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.AnimationsAssetPackItem)
                            .flatMap((item) => item.getAnimations())
                            .find(anim => anim.getKey() === value);
                        if (animation) {
                            const frames = animation.getFrames();
                            if (frames.length > 0) {
                                const frame = frames[Math.floor(frames.length / 2)];
                                if (frame) {
                                    return finder.getAssetPackItemImage(frame.getTextureKey(), frame.getFrameKey());
                                }
                            }
                        }
                        return null;
                    }
                    async createViewer() {
                        const viewer = await super.createViewer();
                        viewer.setCellSize(64, true);
                        viewer.setContentProvider(new AnimationKeyContentProvider());
                        return viewer;
                    }
                }
                sceneobjects.AnimationKeyPropertyType = AnimationKeyPropertyType;
                class AnimationKeyContentProvider {
                    getRoots(input) {
                        const packs = input;
                        return packs
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.AnimationsAssetPackItem)
                            .flatMap((item) => item.getAnimations());
                    }
                    getChildren(parent) {
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AssetKeyPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "asset-key",
                            name: "Asset Key",
                            dialogTitle: "Select Asset Key"
                        });
                    }
                }
                sceneobjects.AssetKeyPropertyType = AssetKeyPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AudioKeyPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "audio-key",
                            name: "Audio Key",
                            dialogTitle: "Select Audio Key"
                        });
                    }
                    getDialogSize() {
                        const size = super.getDialogSize();
                        size.height = window.innerHeight / 2;
                        return size;
                    }
                    async createViewer() {
                        const viewer = await super.createViewer();
                        viewer.setContentProvider(new AudioKeyContentProvider());
                        return viewer;
                    }
                }
                sceneobjects.AudioKeyPropertyType = AudioKeyPropertyType;
                class AudioKeyContentProvider {
                    getRoots(input) {
                        const packs = input;
                        return packs
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.AudioAssetPackItem);
                    }
                    getChildren(parent) {
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="UserPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BooleanPropertyType extends sceneobjects.UserPropertyType {
                    constructor() {
                        super("boolean", false);
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyBoolean(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    getName() {
                        return "Boolean";
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_BooleanProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildBooleanFieldCode(prop, value);
                    }
                    renderValue(value) {
                        if (value === null || value === undefined) {
                            return "";
                        }
                        return value.toString();
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "checkbox";
                        element.classList.add("formCheckbox");
                        element.addEventListener("change", e => {
                            const value = element.checked;
                            setValue(value);
                        });
                        const update = () => {
                            element.checked = getValue();
                        };
                        return {
                            element,
                            update
                        };
                    }
                }
                sceneobjects.BooleanPropertyType = BooleanPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ColorPropertyType extends sceneobjects.StringPropertyType {
                    constructor(typeId = "color") {
                        super(typeId, "#ffffff");
                    }
                    getName() {
                        return "Color";
                    }
                    createEditorElement(getValue, setValue) {
                        const formBuilder = new controls.properties.FormBuilder();
                        const colorForm = formBuilder.createColor(undefined, false, true);
                        colorForm.text.addEventListener("change", e => {
                            setValue(colorForm.text.value);
                        });
                        const update = () => {
                            colorForm.text.value = getValue();
                            colorForm.btn.style.background = colorForm.text.value;
                        };
                        return {
                            element: colorForm.element,
                            update
                        };
                    }
                    createEditorComp() {
                        const comp = document.createElement("div");
                        comp.style.display = "grid";
                        comp.style.gridTemplateColumns = "1fr auto";
                        comp.style.gap = "5px";
                        comp.style.alignItems = "center";
                        return comp;
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyColorRow(parent, userProp.getComponentProperty(), true, lockIcon);
                    }
                }
                sceneobjects.ColorPropertyType = ColorPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ExpressionPropertyType extends sceneobjects.UserPropertyType {
                    constructor() {
                        super("expression", "");
                        this.setExpressionType("any");
                    }
                    hasCustomPropertyType() {
                        return true;
                    }
                    getName() {
                        return "Expression";
                    }
                    renderValue(value) {
                        return value;
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "text";
                        element.classList.add("formText");
                        element.addEventListener("change", e => {
                            setValue(element.value);
                        });
                        const update = () => {
                            element.value = getValue();
                        };
                        return {
                            element,
                            update
                        };
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, this.getExpressionType(), value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyStringRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                }
                sceneobjects.ExpressionPropertyType = ExpressionPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="UserPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NumberPropertyType extends sceneobjects.UserPropertyType {
                    constructor(typeId = "number") {
                        super(typeId, 0);
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyFloatRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    getName() {
                        return "Number";
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_FloatProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildNumberFieldCode(prop, value);
                    }
                    renderValue(value) {
                        if (value === null || value === undefined) {
                            return "";
                        }
                        return value.toString();
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "text";
                        element.classList.add("formText");
                        element.addEventListener("change", e => {
                            const value = Number.parseFloat(element.value);
                            setValue(value);
                        });
                        const update = () => {
                            element.value = getValue().toString();
                        };
                        return {
                            element,
                            update
                        };
                    }
                }
                sceneobjects.NumberPropertyType = NumberPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
/// <reference path="./AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var io = colibri.core.io;
                class ObjectConstructorPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "constructor",
                            dialogTitle: "Select a Type",
                            name: "Object Constructor",
                            hasCustomIcon: true
                        });
                        this.setExpressionType("any");
                    }
                    hasCustomPropertyType() {
                        return true;
                    }
                    getName() {
                        return "Object Constructor";
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, this.getExpressionType(), value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    async updateIcon(iconControl, value) {
                        let icon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER);
                        if (value.startsWith("Phaser.GameObjects.")) {
                            icon = this.findIcon(value) || icon;
                        }
                        else {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            await finder.preload(controls.EMPTY_PROGRESS_MONITOR);
                            const file = finder.getSceneFiles()
                                .find(f => this.valueToString(null, f) === value);
                            if (file) {
                                const cache = ui.SceneThumbnailCache.getInstance();
                                await cache.preload(file);
                                const img = cache.getContent(file);
                                if (img) {
                                    await img.preloadSize();
                                    await img.preload();
                                    icon = img;
                                }
                            }
                        }
                        iconControl.setIcon(icon);
                    }
                    findIcon(type) {
                        const ext = scene.ScenePlugin.getInstance().getGameObjectExtensions().find(ext => ext.getPhaserTypeName() === type);
                        if (ext) {
                            return ext.getIcon();
                        }
                        return undefined;
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer(this.getId());
                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider((element) => {
                            if (element instanceof io.FilePath) {
                                return new ui.viewers.SceneFileCellRenderer();
                            }
                            const icon = this.findIcon(element);
                            if (icon) {
                                return new controls.viewers.IconImageCellRenderer(icon);
                            }
                            return new controls.viewers.EmptyCellRenderer();
                        }));
                        viewer.setLabelProvider(new controls.viewers.LabelProvider((element) => {
                            const label = this.valueToString(viewer, element);
                            return label;
                        }));
                        // viewer.setTreeRenderer(new controls.viewers.GridTreeViewerRenderer(viewer));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        viewer.setCellSize(32);
                        return viewer;
                    }
                    async loadViewerInput(viewer) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const types = scene.ScenePlugin.getInstance().getGameObjectExtensions().map(ext => ext.getPhaserTypeName());
                        viewer.setInput([...finder.getPrefabFiles(), ...types]);
                    }
                    valueToString(viewer, selected) {
                        if (selected instanceof io.FilePath) {
                            return selected.getNameWithoutExtension();
                        }
                        return selected;
                    }
                }
                sceneobjects.ObjectConstructorPropertyType = ObjectConstructorPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_69) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ObjectVarPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "object-var",
                            dialogTitle: "Select Object",
                            name: "Object Dialog",
                            hasCustomIcon: true
                        });
                        this.setExpressionType("Phaser.GameObjects.GameObject");
                    }
                    hasCustomPropertyType() {
                        return true;
                    }
                    getName() {
                        return "Object Variable";
                    }
                    renderValue(value) {
                        return value;
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, this.getExpressionType(), value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.editor.ObjectVarExpressionType.Dialog");
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setStyledLabelProvider(new ui.editor.outline.SceneEditorOutlineStyledLabelProvider());
                        viewer.setContentProvider(new ObjectVarContentProvider(this.getEditor()));
                        return viewer;
                    }
                    valueToString(viewer, value) {
                        const support = sceneobjects.EditorSupport.getEditorSupport(value);
                        if (support) {
                            return support.getLabel();
                        }
                        return viewer.getLabelProvider().getLabel(value);
                    }
                    loadViewerInput(viewer) {
                        viewer.setInput(this.getEditor().getScene().getDisplayListChildren());
                    }
                    async updateIcon(iconControl, value) {
                        const scene = this.getEditor().getScene();
                        const foundElement = [undefined];
                        scene.visitAll(obj => {
                            if (!foundElement[0]) {
                                if (obj.getEditorSupport().getLabel() === value) {
                                    foundElement[0] = obj;
                                }
                            }
                        });
                        const found = foundElement[0];
                        if (found) {
                            const renderer = new ui.editor.outline.SceneEditorOutlineRendererProvider()
                                .getCellRenderer(found);
                            const icon = new controls.viewers.ImageFromCellRenderer(found, renderer, controls.RENDER_ICON_SIZE, controls.RENDER_ICON_SIZE);
                            iconControl.setIcon(icon);
                        }
                        else {
                            iconControl.setIcon(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                    }
                }
                sceneobjects.ObjectVarPropertyType = ObjectVarPropertyType;
                class ObjectVarContentProvider extends ui.editor.outline.SceneEditorOutlineContentProvider {
                    getRoots(input) {
                        return input;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_69.ui || (scene_69.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var code = scene.core.code;
                class OptionPropertyType extends sceneobjects.UserPropertyType {
                    constructor() {
                        super("option", "");
                        this._options = [];
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        const prop = userProp.getComponentProperty();
                        section.createPropertyEnumRow(parent, prop, lockIcon);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        const decl = this.buildStringFieldCode(prop, value);
                        const typeName = this._options.map(opt => code.CodeDOM.quote(opt)).join("|");
                        decl.setType(typeName);
                        return decl;
                    }
                    getOptions() {
                        return this._options;
                    }
                    setOptions(options) {
                        this._options = options;
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        data.options = this._options;
                    }
                    readJSON(data) {
                        super.readJSON(data);
                        this._options = data.options;
                    }
                    getName() {
                        return "Option";
                    }
                    renderValue(value) {
                        return value;
                    }
                    createEditorElement(getValue, setValue) {
                        const items = this._options.map(option => ({
                            name: option,
                            value: option
                        }));
                        const element = document.createElement("button");
                        element.addEventListener("click", e => {
                            const menu = new controls.Menu();
                            for (const item of items) {
                                menu.add(new controls.Action({
                                    text: item.name,
                                    callback: () => {
                                        setValue(item.value);
                                    }
                                }));
                            }
                            menu.createWithEvent(e);
                        });
                        const update = () => {
                            element.innerHTML = getValue();
                        };
                        return { element, update };
                    }
                }
                sceneobjects.OptionPropertyType = OptionPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./PrefabUserPropertyWrapper.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabOptionUserPropertyWrapper extends sceneobjects.PrefabUserPropertyWrapper {
                    constructor(userProp) {
                        super(userProp);
                    }
                    get values() {
                        return this.getUserProperty().getType().getOptions();
                    }
                    getValueLabel(value) {
                        return value;
                    }
                }
                sceneobjects.PrefabOptionUserPropertyWrapper = PrefabOptionUserPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="UserProperties.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function PrefabUserPropertyBuilder(prop) {
                    if (prop.getType() instanceof sceneobjects.OptionPropertyType) {
                        return new sceneobjects.PrefabOptionUserPropertyWrapper(prop);
                    }
                    return new sceneobjects.PrefabUserPropertyWrapper(prop);
                }
                sceneobjects.PrefabUserPropertyBuilder = PrefabUserPropertyBuilder;
                class PrefabUserProperties extends sceneobjects.UserProperties {
                    constructor() {
                        super(PrefabUserPropertyBuilder);
                    }
                }
                sceneobjects.PrefabUserProperties = PrefabUserProperties;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
/// <reference path="./AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SceneKeyPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "scene-key",
                            dialogTitle: "Select Scene Key",
                            name: "Scene Key",
                            hasCustomIcon: true
                        });
                    }
                    async updateIcon(iconControl, value) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        await finder.preload(controls.EMPTY_PROGRESS_MONITOR);
                        const file = finder.getSceneFiles()
                            .find(f => this.valueToString(null, f) === value);
                        if (file) {
                            const cache = ui.SceneThumbnailCache.getInstance();
                            await cache.preload(file);
                            const img = cache.getContent(file);
                            if (img) {
                                await img.preloadSize();
                                await img.preload();
                                iconControl.setIcon(img);
                            }
                            else {
                                iconControl.setIcon(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                            }
                        }
                    }
                    getDialogSize() {
                        return {
                            width: window.innerWidth / 2,
                            height: window.innerHeight / 2
                        };
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer(this.getId());
                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(() => new ui.viewers.SceneFileCellRenderer()));
                        viewer.setLabelProvider(new controls.viewers.LabelProvider((file) => {
                            const label = this.valueToString(viewer, file);
                            return label;
                        }));
                        viewer.setTreeRenderer(new controls.viewers.GridTreeViewerRenderer(viewer));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        return viewer;
                    }
                    async loadViewerInput(viewer) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabs = new Set(finder.getPrefabFiles());
                        viewer.setInput(finder.getSceneFiles().filter(f => !prefabs.has(f)));
                    }
                    valueToString(viewer, selected) {
                        const data = scene.ScenePlugin.getInstance().getSceneFinder().getSceneData(selected);
                        return data?.settings?.sceneKey || selected.getNameWithoutExtension();
                    }
                }
                sceneobjects.SceneKeyPropertyType = SceneKeyPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextureConfigPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "texture-config",
                            name: "Texture Config",
                            dialogTitle: "Select Texture",
                            hasCustomIcon: true
                        });
                    }
                    getDialogSize() {
                        return {
                            width: window.innerWidth * 2 / 3,
                            height: window.innerHeight * 2 / 3
                        };
                    }
                    getIcon(finder, value) {
                        try {
                            const config = JSON.parse(value);
                            if (config) {
                                const result = finder.getAssetPackItemImage(config.key, config.frame);
                                return result;
                            }
                        }
                        catch (e) {
                            // nothing
                        }
                        return null;
                    }
                    revealValue(viewer, value) {
                        try {
                            const obj = JSON.parse(value);
                            const finder = new phasereditor2d.pack.core.PackFinder(...viewer.getInput());
                            const found = finder.getAssetPackItemOrFrame(obj.key, obj.frame);
                            if (found) {
                                viewer.setSelection([found]);
                                viewer.reveal(found);
                            }
                        }
                        catch (e) {
                            // nothing
                        }
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, "{key:string,frame?:string|number}", value);
                    }
                    formatKeyFrame(key, frame) {
                        let data;
                        if (frame !== undefined) {
                            data = { key, frame };
                        }
                        else {
                            data = { key };
                        }
                        return JSON.stringify(data);
                    }
                    async createViewer() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const viewer = await super.createViewer();
                        viewer.setContentProvider(new TextureContentProvider(finder));
                        viewer.setTreeRenderer(new phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer(viewer, false));
                        viewer.setCellSize(72, true);
                        return viewer;
                    }
                }
                sceneobjects.TextureConfigPropertyType = TextureConfigPropertyType;
                class TextureContentProvider {
                    constructor(finder) {
                        this.finder = finder;
                    }
                    getRoots(input) {
                        return [
                            phasereditor2d.pack.core.IMAGE_TYPE,
                            phasereditor2d.pack.core.SVG_TYPE,
                            phasereditor2d.pack.core.ATLAS_TYPE,
                            phasereditor2d.pack.core.SPRITESHEET_TYPE
                        ];
                    }
                    getItems(type) {
                        return this.finder.getPacks()
                            .flatMap(p => p.getItems())
                            .filter(item => item.getType() === type || type === phasereditor2d.pack.core.ATLAS_TYPE &&
                            phasereditor2d.pack.core.AssetPackUtils.isAtlasType(item.getType()));
                    }
                    getChildren(parent) {
                        if (typeof parent === "string") {
                            return this.getItems(parent);
                        }
                        if (parent instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                            if (!(parent instanceof phasereditor2d.pack.core.ImageAssetPackItem)) {
                                return parent.getFrames();
                            }
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserProperty {
                    constructor(componentPropertyBuilder, info) {
                        this._componentPropertyBuilder = componentPropertyBuilder;
                        this._info = info;
                    }
                    getComponentProperty() {
                        if (!this._componentProperty) {
                            this._componentProperty = this._componentPropertyBuilder(this);
                        }
                        return this._componentProperty;
                    }
                    getType() {
                        return this._info.type;
                    }
                    getInfo() {
                        return this._info;
                    }
                    getName() {
                        return this._info.name;
                    }
                    getLabel() {
                        return this._info.label;
                    }
                    getTooltip() {
                        return this._info.tooltip;
                    }
                    getDefaultValue() {
                        return this._info.defValue;
                    }
                    isCustomDefinition() {
                        return this._info.customDefinition;
                    }
                    writeJSON(data) {
                        data.name = this._info.name;
                        data.label = this._info.label;
                        data.tooltip = this._info.tooltip;
                        data.defValue = this._info.defValue;
                        data.customDefinition = this._info.customDefinition;
                        data.type = {};
                        this._info.type.writeJSON(data.type);
                    }
                    readJSON(data) {
                        const typeData = data.type;
                        const typeId = typeData.id;
                        const propType = scene.ScenePlugin.getInstance().createUserPropertyType(typeId);
                        propType.readJSON(typeData);
                        this._info = {
                            name: data.name,
                            label: data.label,
                            tooltip: data.tooltip,
                            defValue: data.defValue,
                            customDefinition: data.customDefinition === undefined ? false : data.customDefinition,
                            type: propType
                        };
                        if (this._info.defValue === null || this._info.defValue === undefined) {
                            this._info.defValue = propType.getDefaultValue();
                        }
                    }
                    buildFieldDeclarationCode() {
                        return this.getType().buildDeclarePropertyCodeDOM(this, this._info.defValue);
                    }
                }
                sceneobjects.UserProperty = UserProperty;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                var controls = colibri.ui.controls;
                class ObjectExtensionAndPrefabViewer extends controls.viewers.TreeViewer {
                    constructor() {
                        super("phasereditor2d.scene.ui.viewers.ObjectExtensionAndPrefabViewer");
                        const treeRenderer = new controls.viewers.GridTreeViewerRenderer(this);
                        treeRenderer.setPaintItemShadow(true);
                        treeRenderer.setSectionCriteria(obj => ObjectExtensionAndPrefabViewer.SECTIONS.indexOf(obj) >= 0);
                        this.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        this.setCellRendererProvider(new ui.blocks.SceneEditorBlocksCellRendererProvider());
                        this.setContentProvider(new ObjectExtensionAndPrefabContentProvider());
                        this.setTreeRenderer(treeRenderer);
                        this.setInput(ObjectExtensionAndPrefabViewer.SECTIONS);
                        this.setCellSize(78, true);
                    }
                }
                ObjectExtensionAndPrefabViewer.PREFAB_SECTION = "User Prefab";
                ObjectExtensionAndPrefabViewer.SECTIONS = [
                    ...scene.SCENE_OBJECT_CATEGORIES,
                    ObjectExtensionAndPrefabViewer.PREFAB_SECTION,
                ];
                viewers.ObjectExtensionAndPrefabViewer = ObjectExtensionAndPrefabViewer;
                class ObjectExtensionAndPrefabContentProvider {
                    getRoots(input) {
                        return ObjectExtensionAndPrefabViewer.SECTIONS;
                    }
                    getChildren(parent) {
                        const plugin = scene.ScenePlugin.getInstance();
                        if (scene.SCENE_OBJECT_CATEGORY_SET.has(parent)) {
                            return plugin.getGameObjectExtensions().filter(ext => ext.getCategory() === parent);
                        }
                        else if (parent === ObjectExtensionAndPrefabViewer.PREFAB_SECTION) {
                            return plugin.getSceneFinder().getPrefabFiles();
                        }
                        return [];
                    }
                }
                viewers.ObjectExtensionAndPrefabContentProvider = ObjectExtensionAndPrefabContentProvider;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                var controls = colibri.ui.controls;
                class ObjectExtensionCellRendererProvider extends controls.viewers.EmptyCellRendererProvider {
                    constructor() {
                        super();
                    }
                    getCellRenderer(element) {
                        const ext = element;
                        return ext.getBlockCellRenderer();
                    }
                }
                viewers.ObjectExtensionCellRendererProvider = ObjectExtensionCellRendererProvider;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                var controls = colibri.ui.controls;
                class ObjectExtensionLabelProvider extends controls.viewers.LabelProvider {
                    getLabel(ext) {
                        return ext.getTypeName();
                    }
                }
                viewers.ObjectExtensionLabelProvider = ObjectExtensionLabelProvider;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                class PhaserTypeSymbol {
                    constructor(typeName) {
                        this.typeName = typeName;
                        this._displayName = typeName.split(".").pop();
                    }
                    static getSymbols() {
                        if (!this._symbols) {
                            this._symbols = scene.ScenePlugin.getInstance().getGameObjectExtensions()
                                .map(e => new PhaserTypeSymbol(e.getPhaserTypeName()));
                            this._symbols = [new PhaserTypeSymbol("Phaser.Scene"), ...this._symbols];
                        }
                        return this._symbols;
                    }
                    getPhaserType() {
                        return this.typeName;
                    }
                    getDisplayName() {
                        return this._displayName;
                    }
                }
                viewers.PhaserTypeSymbol = PhaserTypeSymbol;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                class SceneFileCellRenderer {
                    renderCell(args) {
                        const file = args.obj;
                        const image = ui.SceneThumbnailCache.getInstance().getContent(file);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, args.center);
                        }
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const file = args.obj;
                        return ui.SceneThumbnailCache.getInstance().preload(file);
                    }
                }
                viewers.SceneFileCellRenderer = SceneFileCellRenderer;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
